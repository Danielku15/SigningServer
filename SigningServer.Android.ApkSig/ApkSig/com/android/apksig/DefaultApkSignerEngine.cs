// <auto-generated>
// This code was auto-generated.
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
// </auto-generated>

/*
 * Copyright (C) 2022 Daniel Kuschny (C# port)
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

using System;
using SigningServer.Android.Collections;
using SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1;

namespace SigningServer.Android.Com.Android.Apksig
{
    /// <summary>
    /// Default implementation of {@link ApkSignerEngine}.
    /// 
    /// &lt;p&gt;Use {@link Builder} to obtain instances of this engine.
    /// </summary>
    public class DefaultApkSignerEngine: SigningServer.Android.Com.Android.Apksig.ApkSignerEngine
    {
        internal readonly bool mV1SigningEnabled;
        
        internal readonly bool mV2SigningEnabled;
        
        internal readonly bool mV3SigningEnabled;
        
        internal readonly bool mVerityEnabled;
        
        internal readonly bool mDebuggableApkPermitted;
        
        internal readonly bool mOtherSignersSignaturesPreserved;
        
        internal readonly string mCreatedBy;
        
        internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.SignerConfig> mSignerConfigs;
        
        internal readonly SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.SignerConfig mSourceStampSignerConfig;
        
        internal readonly SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage mSourceStampSigningCertificateLineage;
        
        internal readonly int mMinSdkVersion;
        
        internal readonly SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage mSigningCertificateLineage;
        
        internal SigningServer.Android.Collections.List<byte[]> mPreservedV2Signers = SigningServer.Android.Util.Collections.EmptyList<byte[]>();
        
        internal SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<byte[], int>> mPreservedSignatureBlocks = SigningServer.Android.Util.Collections.EmptyList<SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<byte[], int>>();
        
        internal SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeSigner.SignerConfig> mV1SignerConfigs = SigningServer.Android.Util.Collections.EmptyList<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeSigner.SignerConfig>();
        
        internal SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.DigestAlgorithm mV1ContentDigestAlgorithm;
        
        internal bool mClosed;
        
        internal bool mV1SignaturePending;
        
        /// <summary>
        /// Names of JAR entries which this engine is expected to output as part of v1 signing.
        /// </summary>
        internal SigningServer.Android.Collections.Set<string> mSignatureExpectedOutputJarEntryNames = SigningServer.Android.Util.Collections.EmptySet<string>();
        
        /// <summary>
        /// Requests for digests of output JAR entries.
        /// </summary>
        internal readonly SigningServer.Android.Collections.Map<string, SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.GetJarEntryDataDigestRequest> mOutputJarEntryDigestRequests = new SigningServer.Android.Collections.HashMap<string, SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.GetJarEntryDataDigestRequest>();
        
        /// <summary>
        /// Digests of output JAR entries.
        /// </summary>
        internal readonly SigningServer.Android.Collections.Map<string, byte[]> mOutputJarEntryDigests = new SigningServer.Android.Collections.HashMap<string, byte[]>();
        
        /// <summary>
        /// Data of JAR entries emitted by this engine as v1 signature.
        /// </summary>
        internal readonly SigningServer.Android.Collections.Map<string, byte[]> mEmittedSignatureJarEntryData = new SigningServer.Android.Collections.HashMap<string, byte[]>();
        
        /// <summary>
        /// Requests for data of output JAR entries which comprise the v1 signature.
        /// </summary>
        internal readonly SigningServer.Android.Collections.Map<string, SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.GetJarEntryDataRequest> mOutputSignatureJarEntryDataRequests = new SigningServer.Android.Collections.HashMap<string, SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.GetJarEntryDataRequest>();
        
        /// <summary>
        /// Request to obtain the data of MANIFEST.MF or {@code null} if the request hasn't been issued.
        /// </summary>
        internal SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.GetJarEntryDataRequest mInputJarManifestEntryDataRequest;
        
        /// <summary>
        /// Request to obtain the data of AndroidManifest.xml or {@code null} if the request hasn't been
        /// issued.
        /// </summary>
        internal SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.GetJarEntryDataRequest mOutputAndroidManifestEntryDataRequest;
        
        /// <summary>
        /// Whether the package being signed is marked as {@code android:debuggable} or {@code null} if
        /// this is not yet known.
        /// </summary>
        internal bool? mDebuggable;
        
        /// <summary>
        /// Request to output the emitted v1 signature or {@code null} if the request hasn't been issued.
        /// </summary>
        internal SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.OutputJarSignatureRequestImpl mAddV1SignatureRequest;
        
        internal bool mV2SignaturePending;
        
        internal bool mV3SignaturePending;
        
        /// <summary>
        /// Request to output the emitted v2 and/or v3 signature(s) {@code null} if the request hasn't
        /// been issued.
        /// </summary>
        internal SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.OutputApkSigningBlockRequestImpl mAddSigningBlockRequest;
        
        internal SigningServer.Android.Com.Android.Apksig.Util.RunnablesExecutor mExecutor = SigningServer.Android.Com.Android.Apksig.Util.RunnablesExecutors.MULTI_THREADED;
        
        /// <summary>
        /// A Set of block IDs to be discarded when requesting to preserve the original signatures.
        /// </summary>
        internal static readonly SigningServer.Android.Collections.Set<int> DISCARDED_SIGNATURE_BLOCK_IDS = new HashSet<int>
        {
            // ApkSigningBlockUtils.ANDROID_COMMON_PAGE_ALIGNMENT_BYTES boundary.
            Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERITY_PADDING_BLOCK_ID,
            // The source stamp block is not currently preserved; appending a new signature scheme
            // block will invalidate the previous source stamp.
            Constants.V1_SOURCE_STAMP_BLOCK_ID,
            Constants.V2_SOURCE_STAMP_BLOCK_ID
        };
        
        internal DefaultApkSignerEngine(SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.SignerConfig> signerConfigs, SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.SignerConfig sourceStampSignerConfig, SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage sourceStampSigningCertificateLineage, int minSdkVersion, bool v1SigningEnabled, bool v2SigningEnabled, bool v3SigningEnabled, bool verityEnabled, bool debuggableApkPermitted, bool otherSignersSignaturesPreserved, string createdBy, SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage signingCertificateLineage)
        {
            if (signerConfigs.IsEmpty())
            {
                throw new System.ArgumentException("At least one signer config must be provided");
            }
            mV1SigningEnabled = v1SigningEnabled;
            mV2SigningEnabled = v2SigningEnabled;
            mV3SigningEnabled = v3SigningEnabled;
            mVerityEnabled = verityEnabled;
            mV1SignaturePending = v1SigningEnabled;
            mV2SignaturePending = v2SigningEnabled;
            mV3SignaturePending = v3SigningEnabled;
            mDebuggableApkPermitted = debuggableApkPermitted;
            mOtherSignersSignaturesPreserved = otherSignersSignaturesPreserved;
            mCreatedBy = createdBy;
            mSignerConfigs = signerConfigs;
            mSourceStampSignerConfig = sourceStampSignerConfig;
            mSourceStampSigningCertificateLineage = sourceStampSigningCertificateLineage;
            mMinSdkVersion = minSdkVersion;
            mSigningCertificateLineage = signingCertificateLineage;
            if (v1SigningEnabled)
            {
                if (v3SigningEnabled)
                {
                    SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.SignerConfig oldestConfig = signerConfigs.Get(0);
                    if (signingCertificateLineage != null)
                    {
                        SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage subLineage = signingCertificateLineage.GetSubLineage(oldestConfig.mCertificates.Get(0));
                        if (subLineage.Size() != 1)
                        {
                            throw new System.ArgumentException("v1 signing enabled but the oldest signer in the" + " SigningCertificateLineage is missing.  Please provide the" + " oldest signer to enable v1 signing");
                        }
                    }
                    CreateV1SignerConfigs(SigningServer.Android.Util.Collections.SingletonList<SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.SignerConfig>(oldestConfig), minSdkVersion);
                }
                else 
                {
                    CreateV1SignerConfigs(signerConfigs, minSdkVersion);
                }
            }
        }
        
        internal void CreateV1SignerConfigs(SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.SignerConfig> signerConfigs, int minSdkVersion)
        {
            mV1SignerConfigs = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeSigner.SignerConfig>(signerConfigs.Size());
            SigningServer.Android.Collections.Map<string, int?> v1SignerNameToSignerIndex = new SigningServer.Android.Collections.HashMap<string, int?>(signerConfigs.Size());
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.DigestAlgorithm v1ContentDigestAlgorithm = null;
            for (int i = 0;i < signerConfigs.Size();i++)
            {
                SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.SignerConfig signerConfig = signerConfigs.Get(i);
                SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> certificates = signerConfig.GetCertificates();
                SigningServer.Android.Security.PublicKey publicKey = certificates.Get(0).GetPublicKey();
                string v1SignerName = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeSigner.GetSafeSignerName(signerConfig.GetName());
                int? indexOfOtherSignerWithSameName = v1SignerNameToSignerIndex.Put(v1SignerName, i);
                if (indexOfOtherSignerWithSameName != null)
                {
                    throw new System.ArgumentException("Signers #" + (indexOfOtherSignerWithSameName + 1) + " and #" + (i + 1) + " have the same name: " + v1SignerName + ". v1 signer names must be unique");
                }
                SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.DigestAlgorithm v1SignatureDigestAlgorithm = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeSigner.GetSuggestedSignatureDigestAlgorithm(publicKey, minSdkVersion);
                SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeSigner.SignerConfig v1SignerConfig = new SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeSigner.SignerConfig();
                v1SignerConfig.name = v1SignerName;
                v1SignerConfig.privateKey = signerConfig.GetPrivateKey();
                v1SignerConfig.certificates = certificates;
                v1SignerConfig.signatureDigestAlgorithm = v1SignatureDigestAlgorithm;
                v1SignerConfig.deterministicDsaSigning = signerConfig.GetDeterministicDsaSigning();
                if (v1ContentDigestAlgorithm == null)
                {
                    v1ContentDigestAlgorithm = v1SignatureDigestAlgorithm;
                }
                else 
                {
                    if (SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.DigestAlgorithm.BY_STRENGTH_COMPARATOR.Compare(v1SignatureDigestAlgorithm, v1ContentDigestAlgorithm) > 0)
                    {
                        v1ContentDigestAlgorithm = v1SignatureDigestAlgorithm;
                    }
                }
                mV1SignerConfigs.Add(v1SignerConfig);
            }

            mV1ContentDigestAlgorithm = v1ContentDigestAlgorithm;
            mSignatureExpectedOutputJarEntryNames = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeSigner.GetOutputEntryNames(mV1SignerConfigs);
        }
        
        internal SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignerConfig> CreateV2SignerConfigs(bool apkSigningBlockPaddingSupported)
        {
            if (mV3SigningEnabled)
            {
                SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignerConfig> signerConfig = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignerConfig>();
                SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.SignerConfig oldestConfig = mSignerConfigs.Get(0);
                if (mSigningCertificateLineage != null)
                {
                    SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage subLineage = mSigningCertificateLineage.GetSubLineage(oldestConfig.mCertificates.Get(0));
                    if (subLineage.Size() != 1)
                    {
                        throw new System.ArgumentException("v2 signing enabled but the oldest signer in" + " the SigningCertificateLineage is missing.  Please provide" + " the oldest signer to enable v2 signing.");
                    }
                }
                signerConfig.Add(CreateSigningBlockSignerConfig(mSignerConfigs.Get(0), apkSigningBlockPaddingSupported, SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V2));
                return signerConfig;
            }
            else 
            {
                return CreateSigningBlockSignerConfigs(apkSigningBlockPaddingSupported, SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V2);
            }
        }
        
        internal SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignerConfig> ProcessV3Configs(SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignerConfig> rawConfigs)
        {
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignerConfig> processedConfigs = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignerConfig>();
            var maxValue = int.MaxValue;
            int currentMinSdk = maxValue;
            for (int i = rawConfigs.Size() - 1;i >= 0;i--)
            {
                SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignerConfig config = rawConfigs.Get(i);
                if (config.signatureAlgorithms == null)
                {
                    string keyAlgorithm = config.certificates.Get(0).GetPublicKey().GetAlgorithm();
                    throw new SigningServer.Android.Security.InvalidKeyException("Unsupported key algorithm " + keyAlgorithm + " is " + "not supported for APK Signature Scheme v3 signing");
                }
                if (i == rawConfigs.Size() - 1)
                {
                    config.maxSdkVersion = maxValue;
                }
                else 
                {
                    config.maxSdkVersion = currentMinSdk - 1;
                }
                config.minSdkVersion = GetMinSdkFromV3SignatureAlgorithms(config.signatureAlgorithms);
                if (mSigningCertificateLineage != null)
                {
                    config.mSigningCertificateLineage = mSigningCertificateLineage.GetSubLineage(config.certificates.Get(0));
                }
                processedConfigs.Add(config);
                currentMinSdk = config.minSdkVersion;
                if (currentMinSdk <= mMinSdkVersion || currentMinSdk <= SigningServer.Android.Com.Android.Apksig.Internal.Util.AndroidSdkVersion.P)
                {
                    break;
                }
            }
            if (currentMinSdk > SigningServer.Android.Com.Android.Apksig.Internal.Util.AndroidSdkVersion.P && currentMinSdk > mMinSdkVersion)
            {
                throw new SigningServer.Android.Security.InvalidKeyException("Provided key algorithms not supported on all desired " + "Android SDK versions");
            }
            return processedConfigs;
        }
        
        internal SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignerConfig> CreateV3SignerConfigs(bool apkSigningBlockPaddingSupported)
        {
            return ProcessV3Configs(CreateSigningBlockSignerConfigs(apkSigningBlockPaddingSupported, SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V3));
        }
        
        internal SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignerConfig CreateV4SignerConfig()
        {
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignerConfig> configs = CreateSigningBlockSignerConfigs(true, SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V4);
            if (configs.Size() != 1)
            {
                configs = ProcessV3Configs(configs);
            }
            if (configs.Size() != 1)
            {
                throw new SigningServer.Android.Security.InvalidKeyException("Only accepting one signer config for V4 Signature.");
            }
            return configs.Get(0);
        }
        
        internal SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignerConfig CreateSourceStampSignerConfig()
        {
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignerConfig config = CreateSigningBlockSignerConfig(mSourceStampSignerConfig, false, SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_SOURCE_STAMP);
            if (mSourceStampSigningCertificateLineage != null)
            {
                config.mSigningCertificateLineage = mSourceStampSigningCertificateLineage.GetSubLineage(config.certificates.Get(0));
            }
            return config;
        }
        
        internal int GetMinSdkFromV3SignatureAlgorithms(SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm> algorithms)
        {
            int min = int.MaxValue;
            foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm algorithm in algorithms)
            {
                int current = algorithm.GetMinSdkVersion();
                if (current < min)
                {
                    if (current <= mMinSdkVersion || current <= SigningServer.Android.Com.Android.Apksig.Internal.Util.AndroidSdkVersion.P)
                    {
                        return current;
                    }
                    else 
                    {
                        min = current;
                    }
                }
            }
            return min;
        }
        
        internal SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignerConfig> CreateSigningBlockSignerConfigs(bool apkSigningBlockPaddingSupported, int schemeId)
        {
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignerConfig> signerConfigs = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignerConfig>(mSignerConfigs.Size());
            for (int i = 0;i < mSignerConfigs.Size();i++)
            {
                SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.SignerConfig signerConfig = mSignerConfigs.Get(i);
                signerConfigs.Add(CreateSigningBlockSignerConfig(signerConfig, apkSigningBlockPaddingSupported, schemeId));
            }
            return signerConfigs;
        }
        
        internal SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignerConfig CreateSigningBlockSignerConfig(SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.SignerConfig signerConfig, bool apkSigningBlockPaddingSupported, int schemeId)
        {
            SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> certificates = signerConfig.GetCertificates();
            SigningServer.Android.Security.PublicKey publicKey = certificates.Get(0).GetPublicKey();
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignerConfig newSignerConfig = new SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignerConfig();
            newSignerConfig.privateKey = signerConfig.GetPrivateKey();
            newSignerConfig.certificates = certificates;
            switch (schemeId)
            {
                case SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V2:
                    newSignerConfig.signatureAlgorithms = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V2.V2SchemeSigner.GetSuggestedSignatureAlgorithms(publicKey, mMinSdkVersion, apkSigningBlockPaddingSupported && mVerityEnabled, signerConfig.GetDeterministicDsaSigning());
                    break;
                case SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V3:
                    try
                    {
                        newSignerConfig.signatureAlgorithms = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SchemeSigner.GetSuggestedSignatureAlgorithms(publicKey, mMinSdkVersion, apkSigningBlockPaddingSupported && mVerityEnabled, signerConfig.GetDeterministicDsaSigning());
                    }
                    catch (SigningServer.Android.Security.InvalidKeyException e)
                    {
                        newSignerConfig.signatureAlgorithms = null;
                    }
                    break;
                case SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V4:
                    try
                    {
                        newSignerConfig.signatureAlgorithms = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V4.V4SchemeSigner.GetSuggestedSignatureAlgorithms(publicKey, mMinSdkVersion, apkSigningBlockPaddingSupported, signerConfig.GetDeterministicDsaSigning());
                    }
                    catch (SigningServer.Android.Security.InvalidKeyException e)
                    {
                        newSignerConfig.signatureAlgorithms = null;
                    }
                    break;
                case SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_SOURCE_STAMP:
                    newSignerConfig.signatureAlgorithms = SigningServer.Android.Util.Collections.SingletonList<SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm>(SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm.RSA_PKCS1_V1_5_WITH_SHA256);
                    break;
                default:
                    throw new System.ArgumentException("Unknown APK Signature Scheme ID requested");
            }
            return newSignerConfig;
        }
        
        internal bool IsDebuggable(string entryName)
        {
            return mDebuggableApkPermitted || !SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.ANDROID_MANIFEST_ZIP_ENTRY_NAME.Equals(entryName);
        }
        
        /// <summary>
        /// Initializes DefaultApkSignerEngine with the existing MANIFEST.MF. This reads existing digests
        /// from the MANIFEST.MF file (they are assumed correct) and stores them for the final signature
        /// without recalculation. This step has a significant performance benefit in case of incremental
        /// build.
        /// 
        /// &lt;p&gt;This method extracts and stored computed digest for every entry that it would compute it
        /// for in the {@link #outputJarEntry(String)} method
        /// 
        /// @param manifestBytes raw representation of MANIFEST.MF file
        /// @param entryNames a set of expected entries names
        /// @return set of entry names which were processed by the engine during the initialization, a
        ///     subset of entryNames
        /// </summary>
        public SigningServer.Android.Collections.Set<string> InitWith(byte[] manifestBytes, SigningServer.Android.Collections.Set<string> entryNames)
        {
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Result result = new SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Result();
            SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<SigningServer.Android.Com.Android.Apksig.Internal.Jar.ManifestParser.Section, SigningServer.Android.Collections.Map<string, SigningServer.Android.Com.Android.Apksig.Internal.Jar.ManifestParser.Section>> sections = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.ParseManifest(manifestBytes, entryNames, result);
            string alg = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeSigner.GetJcaMessageDigestAlgorithm(mV1ContentDigestAlgorithm);
            foreach (SigningServer.Android.Collections.MapEntry<string, SigningServer.Android.Com.Android.Apksig.Internal.Jar.ManifestParser.Section> entry in sections.GetSecond().EntrySet())
            {
                string entryName = entry.GetKey();
                if (SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeSigner.IsJarEntryDigestNeededInManifest(entry.GetKey()) && IsDebuggable(entryName))
                {
                    SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.NamedDigest extractedDigest = null;
                    SigningServer.Android.Collections.Collection<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.NamedDigest> digestsToVerify = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.GetDigestsToVerify(entry.GetValue(), "-Digest", mMinSdkVersion, int.MaxValue);
                    foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.NamedDigest digestToVerify in digestsToVerify)
                    {
                        if (digestToVerify.jcaDigestAlgorithm.Equals(alg))
                        {
                            extractedDigest = digestToVerify;
                            break;
                        }
                    }
                    if (extractedDigest != null)
                    {
                        mOutputJarEntryDigests.Put(entryName, extractedDigest.digest);
                    }
                }
            }
            return mOutputJarEntryDigests.KeySet();
        }
        
        public void SetExecutor(SigningServer.Android.Com.Android.Apksig.Util.RunnablesExecutor executor)
        {
            mExecutor = executor;
        }
        
        public void InputApkSigningBlock(SigningServer.Android.Com.Android.Apksig.Util.DataSource apkSigningBlock)
        {
            CheckNotClosed();
            if ((apkSigningBlock == null) || (apkSigningBlock.Size() == 0))
            {
                return;
            }
            if (mOtherSignersSignaturesPreserved)
            {
                bool schemeSignatureBlockPreserved = false;
                mPreservedSignatureBlocks = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<byte[], int>>();
                try
                {
                    SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<byte[], int>> signatureBlocks = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.GetApkSignatureBlocks(apkSigningBlock);
                    foreach (SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<byte[], int> signatureBlock in signatureBlocks)
                    {
                        if (signatureBlock.GetSecond() == SigningServer.Android.Com.Android.Apksig.Constants.APK_SIGNATURE_SCHEME_V2_BLOCK_ID)
                        {
                            if (mV2SigningEnabled)
                            {
                                SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate>, byte[]>> v2Signers = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.GetApkSignatureBlockSigners(signatureBlock.GetFirst());
                                mPreservedV2Signers = new SigningServer.Android.Collections.List<byte[]>(v2Signers.Size());
                                foreach (SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate>, byte[]> v2Signer in v2Signers)
                                {
                                    if (!IsConfiguredWithSigner(v2Signer.GetFirst()))
                                    {
                                        mPreservedV2Signers.Add(v2Signer.GetSecond());
                                        schemeSignatureBlockPreserved = true;
                                    }
                                }
                            }
                            else 
                            {
                                mPreservedSignatureBlocks.Add(signatureBlock);
                                schemeSignatureBlockPreserved = true;
                            }
                        }
                        else if (signatureBlock.GetSecond() == SigningServer.Android.Com.Android.Apksig.Constants.APK_SIGNATURE_SCHEME_V3_BLOCK_ID)
                        {
                            if (!mV3SigningEnabled)
                            {
                                throw new System.InvalidOperationException("Preserving an existing V3 signature is not supported");
                            }
                            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate>, byte[]>> v3Signers = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.GetApkSignatureBlockSigners(signatureBlock.GetFirst());
                            if (v3Signers.Size() > 1)
                            {
                                throw new System.ArgumentException("The provided APK signing block contains " + v3Signers.Size() + " V3 signers; the V3 signature scheme only supports" + " one signer");
                            }
                            if (v3Signers.Size() == 1 && !IsConfiguredWithSigner(v3Signers.Get(0).GetFirst()))
                            {
                                throw new System.InvalidOperationException("The V3 signature scheme only supports one signer; a request " + "was made to preserve the existing V3 signature, " + "but the engine is configured to sign with a " + "different signer");
                            }
                        }
                        else if (!SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.DISCARDED_SIGNATURE_BLOCK_IDS.Contains(signatureBlock.GetSecond()))
                        {
                            mPreservedSignatureBlocks.Add(signatureBlock);
                        }
                    }
                }
                catch (System.Exception e) when ( e is SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException || e is SigningServer.Android.Security.Cert.CertificateException || e is global::System.IO.IOException)
                {
                    throw new System.ArgumentException("Unable to parse the provided signing block", e);
                }
                if (mV3SigningEnabled && schemeSignatureBlockPreserved)
                {
                    throw new System.InvalidOperationException("Signature scheme V3+ only supports a single signer and cannot be " + "appended to the existing signature scheme blocks");
                }
                return;
            }
        }
        
        /// <summary>
        /// Returns whether the engine is configured to sign the APK with a signer using the specified
        /// {@code signerCerts}.
        /// </summary>
        internal bool IsConfiguredWithSigner(SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> signerCerts)
        {
            foreach (SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.SignerConfig signerConfig in mSignerConfigs)
            {
                if (signerCerts.ContainsAll(signerConfig.GetCertificates()))
                {
                    return true;
                }
            }
            return false;
        }
        
        public SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.InputJarEntryInstructions InputJarEntry(string entryName)
        {
            CheckNotClosed();
            var outputPolicy = GetInputJarEntryOutputPolicy(entryName);
            switch (outputPolicy)
            {
                case ApkSignerEngine.InputJarEntryInstructions.OutputPolicy.SKIP:
                    return new SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.InputJarEntryInstructions(SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.InputJarEntryInstructions.OutputPolicy.SKIP);
                case ApkSignerEngine.InputJarEntryInstructions.OutputPolicy.OUTPUT:
                    return new SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.InputJarEntryInstructions(SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.InputJarEntryInstructions.OutputPolicy.OUTPUT);
                case ApkSignerEngine.InputJarEntryInstructions.OutputPolicy.OUTPUT_BY_ENGINE:
                    if (SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeConstants.MANIFEST_ENTRY_NAME.Equals(entryName))
                    {
                        mInputJarManifestEntryDataRequest = new SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.GetJarEntryDataRequest(entryName);
                        return new SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.InputJarEntryInstructions(SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.InputJarEntryInstructions.OutputPolicy.OUTPUT_BY_ENGINE, mInputJarManifestEntryDataRequest);
                    }
                    return new SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.InputJarEntryInstructions(SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.InputJarEntryInstructions.OutputPolicy.OUTPUT_BY_ENGINE);
                default:
                    throw new SigningServer.Android.Core.RuntimeException("Unsupported output policy: " + outputPolicy);
            }
        }
        
        public SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.InspectJarEntryRequest OutputJarEntry(string entryName)
        {
            CheckNotClosed();
            InvalidateV2Signature();
            if (!IsDebuggable(entryName))
            {
                ForgetOutputApkDebuggableStatus();
            }
            if (!mV1SigningEnabled)
            {
                if (!IsDebuggable(entryName))
                {
                    mOutputAndroidManifestEntryDataRequest = new SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.GetJarEntryDataRequest(entryName);
                    return mOutputAndroidManifestEntryDataRequest;
                }
                return null;
            }
            if (SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeSigner.IsJarEntryDigestNeededInManifest(entryName))
            {
                InvalidateV1Signature();
                SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.GetJarEntryDataDigestRequest dataDigestRequest = new SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.GetJarEntryDataDigestRequest(entryName, SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeSigner.GetJcaMessageDigestAlgorithm(mV1ContentDigestAlgorithm));
                mOutputJarEntryDigestRequests.Put(entryName, dataDigestRequest);
                mOutputJarEntryDigests.Remove(entryName);
                if ((!mDebuggableApkPermitted) && (SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.ANDROID_MANIFEST_ZIP_ENTRY_NAME.Equals(entryName)))
                {
                    mOutputAndroidManifestEntryDataRequest = new SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.GetJarEntryDataRequest(entryName);
                    return new SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.CompoundInspectJarEntryRequest(entryName, mOutputAndroidManifestEntryDataRequest, dataDigestRequest);
                }
                return dataDigestRequest;
            }
            if (mSignatureExpectedOutputJarEntryNames.Contains(entryName))
            {
                InvalidateV1Signature();
                SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.GetJarEntryDataRequest dataRequest;
                if (SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeConstants.MANIFEST_ENTRY_NAME.Equals(entryName))
                {
                    dataRequest = new SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.GetJarEntryDataRequest(entryName);
                    mInputJarManifestEntryDataRequest = dataRequest;
                }
                else 
                {
                    dataRequest = (mEmittedSignatureJarEntryData.ContainsKey(entryName)) ? new SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.GetJarEntryDataRequest(entryName) : null;
                }
                if (dataRequest != null)
                {
                    mOutputSignatureJarEntryDataRequests.Put(entryName, dataRequest);
                }
                return dataRequest;
            }
            return null;
        }
        
        public SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.InputJarEntryInstructions.OutputPolicy InputJarEntryRemoved(string entryName)
        {
            CheckNotClosed();
            return GetInputJarEntryOutputPolicy(entryName);
        }
        
        public void OutputJarEntryRemoved(string entryName)
        {
            CheckNotClosed();
            InvalidateV2Signature();
            if (!mV1SigningEnabled)
            {
                return;
            }
            if (SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeSigner.IsJarEntryDigestNeededInManifest(entryName))
            {
                InvalidateV1Signature();
                mOutputJarEntryDigests.Remove(entryName);
                mOutputJarEntryDigestRequests.Remove(entryName);
                mOutputSignatureJarEntryDataRequests.Remove(entryName);
                return;
            }
            if (mSignatureExpectedOutputJarEntryNames.Contains(entryName))
            {
                InvalidateV1Signature();
                return;
            }
        }
        
        public SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.OutputJarSignatureRequest OutputJarEntries()
        {
            CheckNotClosed();
            if (!mV1SignaturePending)
            {
                return null;
            }
            if ((mInputJarManifestEntryDataRequest != null) && (!mInputJarManifestEntryDataRequest.IsDone()))
            {
                throw new System.InvalidOperationException("Still waiting to inspect input APK's " + mInputJarManifestEntryDataRequest.GetEntryName());
            }
            foreach (SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.GetJarEntryDataDigestRequest digestRequest in mOutputJarEntryDigestRequests.Values())
            {
                string entryName = digestRequest.GetEntryName();
                if (!digestRequest.IsDone())
                {
                    throw new System.InvalidOperationException("Still waiting to inspect output APK's " + entryName);
                }
                mOutputJarEntryDigests.Put(entryName, digestRequest.GetDigest());
            }
            if (IsEligibleForSourceStamp())
            {
                SigningServer.Android.Security.MessageDigest messageDigest = SigningServer.Android.Security.MessageDigest.GetInstance(SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeSigner.GetJcaMessageDigestAlgorithm(mV1ContentDigestAlgorithm));
                messageDigest.Update(GenerateSourceStampCertificateDigest());
                mOutputJarEntryDigests.Put(SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.SOURCE_STAMP_CERTIFICATE_HASH_ZIP_ENTRY_NAME, messageDigest.Digest());
            }
            mOutputJarEntryDigestRequests.Clear();
            foreach (SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.GetJarEntryDataRequest dataRequest in mOutputSignatureJarEntryDataRequests.Values())
            {
                if (!dataRequest.IsDone())
                {
                    throw new System.InvalidOperationException("Still waiting to inspect output APK's " + dataRequest.GetEntryName());
                }
            }
            SigningServer.Android.Collections.List<int?> apkSigningSchemeIds = new SigningServer.Android.Collections.List<int?>();
            if (mV2SigningEnabled)
            {
                apkSigningSchemeIds.Add(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V2);
            }
            if (mV3SigningEnabled)
            {
                apkSigningSchemeIds.Add(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V3);
            }
            byte[] inputJarManifest = (mInputJarManifestEntryDataRequest != null) ? mInputJarManifestEntryDataRequest.GetData() : null;
            if (IsEligibleForSourceStamp())
            {
                inputJarManifest = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeSigner.GenerateManifestFile(mV1ContentDigestAlgorithm, mOutputJarEntryDigests, inputJarManifest).contents;
            }
            CheckOutputApkNotDebuggableIfDebuggableMustBeRejected();
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<string, byte[]>> signatureZipEntries;
            if ((mAddV1SignatureRequest == null) || (!mAddV1SignatureRequest.IsDone()))
            {
                try
                {
                    signatureZipEntries = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeSigner.Sign(
                        mV1SignerConfigs
                        , 
                        mV1ContentDigestAlgorithm
                        , 
                        mOutputJarEntryDigests
                        , 
                        apkSigningSchemeIds
                        , 
                        inputJarManifest
                        , 
                        mCreatedBy
                    
                    );
                }
                catch (SigningServer.Android.Security.Cert.CertificateException e)
                {
                    throw new SigningServer.Android.Security.SignatureException("Failed to generate v1 signature", e);
                }
            }
            else 
            {
                SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeSigner.OutputManifestFile newManifest = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeSigner.GenerateManifestFile(mV1ContentDigestAlgorithm, mOutputJarEntryDigests, inputJarManifest);
                byte[] emittedSignatureManifest = mEmittedSignatureJarEntryData.Get(SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeConstants.MANIFEST_ENTRY_NAME);
                if (!SigningServer.Android.Collections.Arrays.Equals(newManifest.contents, emittedSignatureManifest))
                {
                    try
                    {
                        signatureZipEntries = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeSigner.SignManifest(mV1SignerConfigs, mV1ContentDigestAlgorithm, apkSigningSchemeIds, mCreatedBy, newManifest);
                    }
                    catch (SigningServer.Android.Security.Cert.CertificateException e)
                    {
                        throw new SigningServer.Android.Security.SignatureException("Failed to generate v1 signature", e);
                    }
                }
                else 
                {
                    signatureZipEntries = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<string, byte[]>>();
                    foreach (SigningServer.Android.Collections.MapEntry<string, byte[]> expectedOutputEntry in mEmittedSignatureJarEntryData.EntrySet())
                    {
                        string entryName = expectedOutputEntry.GetKey();
                        byte[] expectedData = expectedOutputEntry.GetValue();
                        SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.GetJarEntryDataRequest actualDataRequest = mOutputSignatureJarEntryDataRequests.Get(entryName);
                        if (actualDataRequest == null)
                        {
                            signatureZipEntries.Add(SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair.Of<string, byte[]>(entryName, expectedData));
                            continue;
                        }
                        byte[] actualData = actualDataRequest.GetData();
                        if (!SigningServer.Android.Collections.Arrays.Equals(expectedData, actualData))
                        {
                            signatureZipEntries.Add(SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair.Of<string, byte[]>(entryName, expectedData));
                        }
                    }
                    if (signatureZipEntries.IsEmpty())
                    {
                        return null;
                    }
                }
            }
            if (signatureZipEntries.IsEmpty())
            {
                mV1SignaturePending = false;
                return null;
            }
            var sigEntries = new SigningServer.Android.Collections.List<ApkSignerEngine.OutputJarSignatureRequest.JarEntry>(signatureZipEntries.Size());
            foreach (SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<string, byte[]> entry in signatureZipEntries)
            {
                string entryName = entry.GetFirst();
                byte[] entryData = entry.GetSecond();
                sigEntries.Add(new ApkSignerEngine.OutputJarSignatureRequest.JarEntry(entryName, entryData));
                mEmittedSignatureJarEntryData.Put(entryName, entryData);
            }
            mAddV1SignatureRequest = new SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.OutputJarSignatureRequestImpl(sigEntries);
            return mAddV1SignatureRequest;
        }
        
        [Obsolete]
        public SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.OutputApkSigningBlockRequest OutputZipSections(SigningServer.Android.Com.Android.Apksig.Util.DataSource zipEntries, SigningServer.Android.Com.Android.Apksig.Util.DataSource zipCentralDirectory, SigningServer.Android.Com.Android.Apksig.Util.DataSource zipEocd)
        {
            return OutputZipSectionsInternal(zipEntries, zipCentralDirectory, zipEocd, false);
        }
        
        public SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.OutputApkSigningBlockRequest2 OutputZipSections2(SigningServer.Android.Com.Android.Apksig.Util.DataSource zipEntries, SigningServer.Android.Com.Android.Apksig.Util.DataSource zipCentralDirectory, SigningServer.Android.Com.Android.Apksig.Util.DataSource zipEocd)
        {
            return OutputZipSectionsInternal(zipEntries, zipCentralDirectory, zipEocd, true);
        }
        
        internal SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.OutputApkSigningBlockRequestImpl OutputZipSectionsInternal(SigningServer.Android.Com.Android.Apksig.Util.DataSource zipEntries, SigningServer.Android.Com.Android.Apksig.Util.DataSource zipCentralDirectory, SigningServer.Android.Com.Android.Apksig.Util.DataSource zipEocd, bool apkSigningBlockPaddingSupported)
        {
            CheckNotClosed();
            CheckV1SigningDoneIfEnabled();
            if (!mV2SigningEnabled && !mV3SigningEnabled && !IsEligibleForSourceStamp())
            {
                return null;
            }
            CheckOutputApkNotDebuggableIfDebuggableMustBeRejected();
            SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<SigningServer.Android.Com.Android.Apksig.Util.DataSource, int> paddingPair = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.GenerateApkSigningBlockPadding(zipEntries, apkSigningBlockPaddingSupported);
            SigningServer.Android.Com.Android.Apksig.Util.DataSource beforeCentralDir = paddingPair.GetFirst();
            int padSizeBeforeApkSigningBlock = paddingPair.GetSecond();
            SigningServer.Android.Com.Android.Apksig.Util.DataSource eocd = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.CopyWithModifiedCDOffset(beforeCentralDir, zipEocd);
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<byte[], int>> signingSchemeBlocks = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<byte[], int>>();
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SigningSchemeBlockAndDigests v2SigningSchemeBlockAndDigests = null;
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SigningSchemeBlockAndDigests v3SigningSchemeBlockAndDigests = null;
            if (mOtherSignersSignaturesPreserved && mPreservedSignatureBlocks != null && !mPreservedSignatureBlocks.IsEmpty())
            {
                signingSchemeBlocks.AddAll(mPreservedSignatureBlocks);
            }
            if (mV2SigningEnabled)
            {
                InvalidateV2Signature();
                SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignerConfig> v2SignerConfigs = CreateV2SignerConfigs(apkSigningBlockPaddingSupported);
                v2SigningSchemeBlockAndDigests = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V2.V2SchemeSigner.GenerateApkSignatureSchemeV2Block(
                    mExecutor
                    , 
                    beforeCentralDir
                    , 
                    zipCentralDirectory
                    , 
                    eocd
                    , 
                    v2SignerConfigs
                    , 
                    mV3SigningEnabled
                    , 
                    mOtherSignersSignaturesPreserved ? mPreservedV2Signers : null
                
                );
                signingSchemeBlocks.Add(v2SigningSchemeBlockAndDigests.signingSchemeBlock);
            }
            if (mV3SigningEnabled)
            {
                InvalidateV3Signature();
                SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignerConfig> v3SignerConfigs = CreateV3SignerConfigs(apkSigningBlockPaddingSupported);
                v3SigningSchemeBlockAndDigests = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SchemeSigner.GenerateApkSignatureSchemeV3Block(mExecutor, beforeCentralDir, zipCentralDirectory, eocd, v3SignerConfigs);
                signingSchemeBlocks.Add(v3SigningSchemeBlockAndDigests.signingSchemeBlock);
            }
            if (IsEligibleForSourceStamp())
            {
                SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignerConfig sourceStampSignerConfig = CreateSourceStampSignerConfig();
                SigningServer.Android.Collections.Map<int, SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, byte[]>> signatureSchemeDigestInfos = new SigningServer.Android.Collections.HashMap<int, SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, byte[]>>();
                if (mV3SigningEnabled)
                {
                    signatureSchemeDigestInfos.Put(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V3, v3SigningSchemeBlockAndDigests.digestInfo);
                }
                if (mV2SigningEnabled)
                {
                    signatureSchemeDigestInfos.Put(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V2, v2SigningSchemeBlockAndDigests.digestInfo);
                }
                if (mV1SigningEnabled)
                {
                    SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, byte[]> v1SigningSchemeDigests = new SigningServer.Android.Collections.HashMap<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, byte[]>();
                    try
                    {
                        byte[] inputJarManifest = (mInputJarManifestEntryDataRequest != null) ? mInputJarManifestEntryDataRequest.GetData() : null;
                        byte[] jarManifest = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeSigner.GenerateManifestFile(mV1ContentDigestAlgorithm, mOutputJarEntryDigests, inputJarManifest).contents;
                        v1SigningSchemeDigests.Put(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm.SHA256, SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.ComputeSha256DigestBytes(jarManifest));
                    }
                    catch (SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException e)
                    {
                        throw new SigningServer.Android.Core.RuntimeException("Failed to generate manifest file", e);
                    }
                    signatureSchemeDigestInfos.Put(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_JAR_SIGNATURE_SCHEME, v1SigningSchemeDigests);
                }
                signingSchemeBlocks.Add(SigningServer.Android.Com.Android.Apksig.Internal.Apk.Stamp.V2SourceStampSigner.GenerateSourceStampBlock(sourceStampSignerConfig, signatureSchemeDigestInfos));
            }
            byte[] apkSigningBlock = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.GenerateApkSigningBlock(signingSchemeBlocks);
            mAddSigningBlockRequest = new SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.OutputApkSigningBlockRequestImpl(apkSigningBlock, padSizeBeforeApkSigningBlock);
            return mAddSigningBlockRequest;
        }
        
        public void OutputDone()
        {
            CheckNotClosed();
            CheckV1SigningDoneIfEnabled();
            CheckSigningBlockDoneIfEnabled();
        }
        
        public void SignV4(SigningServer.Android.Com.Android.Apksig.Util.DataSource dataSource, System.IO.FileInfo outputFile, bool ignoreFailures)
        {
            if (outputFile == null)
            {
                if (ignoreFailures)
                {
                    return;
                }
                throw new SigningServer.Android.Security.SignatureException("Missing V4 output file.");
            }
            try
            {
                SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignerConfig v4SignerConfig = CreateV4SignerConfig();
                SigningServer.Android.Com.Android.Apksig.Internal.Apk.V4.V4SchemeSigner.GenerateV4Signature(dataSource, v4SignerConfig, outputFile);
            }
            catch (System.Exception e) when ( e is SigningServer.Android.Security.InvalidKeyException || e is global::System.IO.IOException || e is SigningServer.Android.Security.NoSuchAlgorithmException)
            {
                if (ignoreFailures)
                {
                    return;
                }
                throw new SigningServer.Android.Security.SignatureException("V4 signing failed", e);
            }
        }
        
        /// <summary>
        /// For external use only to generate V4 &amp; tree separately.
        /// </summary>
        public virtual byte[] ProduceV4Signature(SigningServer.Android.Com.Android.Apksig.Util.DataSource dataSource, SigningServer.Android.IO.OutputStream sigOutput)
        {
            if (sigOutput == null)
            {
                throw new SigningServer.Android.Security.SignatureException("Missing V4 output streams.");
            }
            try
            {
                SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignerConfig v4SignerConfig = CreateV4SignerConfig();
                SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V4.V4Signature, byte[]> pair = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V4.V4SchemeSigner.GenerateV4Signature(dataSource, v4SignerConfig);
                pair.GetFirst().WriteTo(sigOutput);
                return pair.GetSecond();
            }
            catch (System.Exception e) when ( e is SigningServer.Android.Security.InvalidKeyException || e is global::System.IO.IOException || e is SigningServer.Android.Security.NoSuchAlgorithmException)
            {
                throw new SigningServer.Android.Security.SignatureException("V4 signing failed", e);
            }
        }
        
        public bool IsEligibleForSourceStamp()
        {
            return mSourceStampSignerConfig != null && (mV2SigningEnabled || mV3SigningEnabled || mV1SigningEnabled);
        }
        
        public byte[] GenerateSourceStampCertificateDigest()
        {
            if (mSourceStampSignerConfig.GetCertificates().IsEmpty())
            {
                throw new SigningServer.Android.Security.SignatureException("No certificates configured for stamp");
            }
            try
            {
                return SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.ComputeSha256DigestBytes(mSourceStampSignerConfig.GetCertificates().Get(0).GetEncoded());
            }
            catch (SigningServer.Android.Security.Cert.CertificateEncodingException e)
            {
                throw new SigningServer.Android.Security.SignatureException("Failed to encode source stamp certificate", e);
            }
        }
        
        public void Dispose()
        {
            mClosed = true;
            mAddV1SignatureRequest = null;
            mInputJarManifestEntryDataRequest = null;
            mOutputAndroidManifestEntryDataRequest = null;
            mDebuggable = null;
            mOutputJarEntryDigestRequests.Clear();
            mOutputJarEntryDigests.Clear();
            mEmittedSignatureJarEntryData.Clear();
            mOutputSignatureJarEntryDataRequests.Clear();
            mAddSigningBlockRequest = null;
        }
        
        internal void InvalidateV1Signature()
        {
            if (mV1SigningEnabled)
            {
                mV1SignaturePending = true;
            }
            InvalidateV2Signature();
        }
        
        internal void InvalidateV2Signature()
        {
            if (mV2SigningEnabled)
            {
                mV2SignaturePending = true;
                mAddSigningBlockRequest = null;
            }
        }
        
        internal void InvalidateV3Signature()
        {
            if (mV3SigningEnabled)
            {
                mV3SignaturePending = true;
                mAddSigningBlockRequest = null;
            }
        }
        
        internal void CheckNotClosed()
        {
            if (mClosed)
            {
                throw new System.InvalidOperationException("Engine closed");
            }
        }
        
        internal void CheckV1SigningDoneIfEnabled()
        {
            if (!mV1SignaturePending)
            {
                return;
            }
            if (mAddV1SignatureRequest == null)
            {
                throw new System.InvalidOperationException("v1 signature (JAR signature) not yet generated. Skipped outputJarEntries()?");
            }
            if (!mAddV1SignatureRequest.IsDone())
            {
                throw new System.InvalidOperationException("v1 signature (JAR signature) addition requested by outputJarEntries() hasn't" + " been fulfilled");
            }
            foreach (SigningServer.Android.Collections.MapEntry<string, byte[]> expectedOutputEntry in mEmittedSignatureJarEntryData.EntrySet())
            {
                string entryName = expectedOutputEntry.GetKey();
                byte[] expectedData = expectedOutputEntry.GetValue();
                SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.GetJarEntryDataRequest actualDataRequest = mOutputSignatureJarEntryDataRequests.Get(entryName);
                if (actualDataRequest == null)
                {
                    throw new System.InvalidOperationException("APK entry " + entryName + " not yet output despite this having been" + " requested");
                }
                else if (!actualDataRequest.IsDone())
                {
                    throw new System.InvalidOperationException("Still waiting to inspect output APK's " + entryName);
                }
                byte[] actualData = actualDataRequest.GetData();
                if (!SigningServer.Android.Collections.Arrays.Equals(expectedData, actualData))
                {
                    throw new System.InvalidOperationException("Output APK entry " + entryName + " data differs from what was requested");
                }
            }
            mV1SignaturePending = false;
        }
        
        internal void CheckSigningBlockDoneIfEnabled()
        {
            if (!mV2SignaturePending && !mV3SignaturePending)
            {
                return;
            }
            if (mAddSigningBlockRequest == null)
            {
                throw new System.InvalidOperationException("Signed APK Signing BLock not yet generated. Skipped outputZipSections()?");
            }
            if (!mAddSigningBlockRequest.IsDone())
            {
                throw new System.InvalidOperationException("APK Signing Block addition of signature(s) requested by" + " outputZipSections() hasn't been fulfilled yet");
            }
            mAddSigningBlockRequest = null;
            mV2SignaturePending = false;
            mV3SignaturePending = false;
        }
        
        internal void CheckOutputApkNotDebuggableIfDebuggableMustBeRejected()
        {
            if (mDebuggableApkPermitted)
            {
                return;
            }
            try
            {
                if (IsOutputApkDebuggable())
                {
                    throw new SigningServer.Android.Security.SignatureException("APK is debuggable (see android:debuggable attribute) and this engine is" + " configured to refuse to sign debuggable APKs");
                }
            }
            catch (SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException e)
            {
                throw new SigningServer.Android.Security.SignatureException("Failed to determine whether the APK is debuggable", e);
            }
        }
        
        /// <summary>
        /// Returns whether the output APK is debuggable according to its {@code android:debuggable}
        /// declaration.
        /// </summary>
        internal bool IsOutputApkDebuggable()
        {
            if (mDebuggable != null)
            {
                return mDebuggable.Value;
            }
            if (mOutputAndroidManifestEntryDataRequest == null)
            {
                throw new System.InvalidOperationException("Cannot determine debuggable status of output APK because " + SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.ANDROID_MANIFEST_ZIP_ENTRY_NAME + " entry contents have not yet been requested");
            }
            if (!mOutputAndroidManifestEntryDataRequest.IsDone())
            {
                throw new System.InvalidOperationException("Still waiting to inspect output APK's " + mOutputAndroidManifestEntryDataRequest.GetEntryName());
            }
            mDebuggable = SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.GetDebuggableFromBinaryAndroidManifest(SigningServer.Android.IO.ByteBuffer.Wrap(mOutputAndroidManifestEntryDataRequest.GetData()));
            return mDebuggable.Value;
        }
        
        internal void ForgetOutputApkDebuggableStatus()
        {
            mDebuggable = null;
        }
        
        /// <summary>
        /// Returns the output policy for the provided input JAR entry.
        /// </summary>
        internal SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.InputJarEntryInstructions.OutputPolicy GetInputJarEntryOutputPolicy(string entryName)
        {
            if (mSignatureExpectedOutputJarEntryNames.Contains(entryName))
            {
                return SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.InputJarEntryInstructions.OutputPolicy.OUTPUT_BY_ENGINE;
            }
            if ((mOtherSignersSignaturesPreserved) || (SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeSigner.IsJarEntryDigestNeededInManifest(entryName)))
            {
                return SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.InputJarEntryInstructions.OutputPolicy.OUTPUT;
            }
            return SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.InputJarEntryInstructions.OutputPolicy.SKIP;
        }
        
        internal class OutputJarSignatureRequestImpl: SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.OutputJarSignatureRequest
        {
            internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.OutputJarSignatureRequest.JarEntry> mAdditionalJarEntries;
            
            internal bool mDone;
            
            internal OutputJarSignatureRequestImpl(SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.OutputJarSignatureRequest.JarEntry> additionalZipEntries)
            {
                mAdditionalJarEntries = SigningServer.Android.Util.Collections.UnmodifiableList(new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.OutputJarSignatureRequest.JarEntry>(additionalZipEntries));
            }
            
            public SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.OutputJarSignatureRequest.JarEntry> GetAdditionalJarEntries()
            {
                return mAdditionalJarEntries;
            }
            
            public void Done()
            {
                mDone = true;
            }
            
            internal bool IsDone()
            {
                return mDone;
            }
            
        }
        
        internal class OutputApkSigningBlockRequestImpl: SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.OutputApkSigningBlockRequest, SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.OutputApkSigningBlockRequest2
        {
            internal readonly byte[] mApkSigningBlock;
            
            internal readonly int mPaddingBeforeApkSigningBlock;
            
            internal bool mDone;
            
            internal OutputApkSigningBlockRequestImpl(byte[] apkSigingBlock, int paddingBefore)
            {
                mApkSigningBlock = (byte[])apkSigingBlock.Clone();
                mPaddingBeforeApkSigningBlock = paddingBefore;
            }
            
            public byte[] GetApkSigningBlock()
            {
                return (byte[])mApkSigningBlock.Clone();
            }
            
            public void Done()
            {
                mDone = true;
            }
            
            internal bool IsDone()
            {
                return mDone;
            }
            
            public int GetPaddingSizeBeforeApkSigningBlock()
            {
                return mPaddingBeforeApkSigningBlock;
            }
            
        }
        
        /// <summary>
        /// JAR entry inspection request which obtain the entry's uncompressed data.
        /// </summary>
        internal class GetJarEntryDataRequest: SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.InspectJarEntryRequest
        {
            internal readonly string mEntryName;
            
            internal readonly object mLock = new object();
            
            internal bool mDone;
            
            internal SigningServer.Android.Com.Android.Apksig.Util.DataSink mDataSink;
            
            internal SigningServer.Android.IO.ByteArrayOutputStream mDataSinkBuf;
            
            internal GetJarEntryDataRequest(string entryName)
            {
                mEntryName = entryName;
            }
            
            public string GetEntryName()
            {
                return mEntryName;
            }
            
            public SigningServer.Android.Com.Android.Apksig.Util.DataSink GetDataSink()
            {
                lock(mLock)
                {
                    CheckNotDone();
                    if (mDataSinkBuf == null)
                    {
                        mDataSinkBuf = new SigningServer.Android.IO.ByteArrayOutputStream();
                    }
                    if (mDataSink == null)
                    {
                        mDataSink = SigningServer.Android.Com.Android.Apksig.Util.DataSinks.AsDataSink(mDataSinkBuf);
                    }
                    return mDataSink;
                }
            }
            
            public void Done()
            {
                lock(mLock)
                {
                    if (mDone)
                    {
                        return;
                    }
                    mDone = true;
                }
            }
            
            internal bool IsDone()
            {
                lock(mLock)
                {
                    return mDone;
                }
            }
            
            internal void CheckNotDone()
            {
                lock(mLock)
                {
                    if (mDone)
                    {
                        throw new System.InvalidOperationException("Already done");
                    }
                }
            }
            
            internal byte[] GetData()
            {
                lock(mLock)
                {
                    if (!mDone)
                    {
                        throw new System.InvalidOperationException("Not yet done");
                    }
                    return (mDataSinkBuf != null) ? mDataSinkBuf.ToByteArray() : new byte[0];
                }
            }
            
        }
        
        /// <summary>
        /// JAR entry inspection request which obtains the digest of the entry's uncompressed data.
        /// </summary>
        internal class GetJarEntryDataDigestRequest: SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.InspectJarEntryRequest
        {
            internal readonly string mEntryName;
            
            internal readonly string mJcaDigestAlgorithm;
            
            internal readonly object mLock = new object();
            
            internal bool mDone;
            
            internal SigningServer.Android.Com.Android.Apksig.Util.DataSink mDataSink;
            
            internal SigningServer.Android.Security.MessageDigest mMessageDigest;
            
            internal byte[] mDigest;
            
            internal GetJarEntryDataDigestRequest(string entryName, string jcaDigestAlgorithm)
            {
                mEntryName = entryName;
                mJcaDigestAlgorithm = jcaDigestAlgorithm;
            }
            
            public string GetEntryName()
            {
                return mEntryName;
            }
            
            public SigningServer.Android.Com.Android.Apksig.Util.DataSink GetDataSink()
            {
                lock(mLock)
                {
                    CheckNotDone();
                    if (mDataSink == null)
                    {
                        mDataSink = SigningServer.Android.Com.Android.Apksig.Util.DataSinks.AsDataSink(GetMessageDigest());
                    }
                    return mDataSink;
                }
            }
            
            internal SigningServer.Android.Security.MessageDigest GetMessageDigest()
            {
                lock(mLock)
                {
                    if (mMessageDigest == null)
                    {
                        try
                        {
                            mMessageDigest = SigningServer.Android.Security.MessageDigest.GetInstance(mJcaDigestAlgorithm);
                        }
                        catch (SigningServer.Android.Security.NoSuchAlgorithmException e)
                        {
                            throw new SigningServer.Android.Core.RuntimeException(mJcaDigestAlgorithm + " MessageDigest not available", e);
                        }
                    }
                    return mMessageDigest;
                }
            }
            
            public void Done()
            {
                lock(mLock)
                {
                    if (mDone)
                    {
                        return;
                    }
                    mDone = true;
                    mDigest = GetMessageDigest().Digest();
                    mMessageDigest = null;
                    mDataSink = null;
                }
            }
            
            internal bool IsDone()
            {
                lock(mLock)
                {
                    return mDone;
                }
            }
            
            internal void CheckNotDone()
            {
                lock(mLock)
                {
                    if (mDone)
                    {
                        throw new System.InvalidOperationException("Already done");
                    }
                }
            }
            
            internal byte[] GetDigest()
            {
                lock(mLock)
                {
                    if (!mDone)
                    {
                        throw new System.InvalidOperationException("Not yet done");
                    }
                    return (byte[])mDigest.Clone();
                }
            }
            
        }
        
        /// <summary>
        /// JAR entry inspection request which transparently satisfies multiple such requests.
        /// </summary>
        internal class CompoundInspectJarEntryRequest: SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.InspectJarEntryRequest
        {
            internal readonly string mEntryName;
            
            internal readonly SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.InspectJarEntryRequest[] mRequests;
            
            internal readonly object mLock = new object();
            
            internal SigningServer.Android.Com.Android.Apksig.Util.DataSink mSink;
            
            internal CompoundInspectJarEntryRequest(string entryName, params SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.InspectJarEntryRequest[] requests)
            {
                mEntryName = entryName;
                mRequests = requests;
            }
            
            public string GetEntryName()
            {
                return mEntryName;
            }
            
            public SigningServer.Android.Com.Android.Apksig.Util.DataSink GetDataSink()
            {
                lock(mLock)
                {
                    if (mSink == null)
                    {
                        SigningServer.Android.Com.Android.Apksig.Util.DataSink[] sinks = new SigningServer.Android.Com.Android.Apksig.Util.DataSink[mRequests.Length];
                        for (int i = 0;i < sinks.Length;i++)
                        {
                            sinks[i] = mRequests[i].GetDataSink();
                        }
                        mSink = new SigningServer.Android.Com.Android.Apksig.Internal.Util.TeeDataSink(sinks);
                    }
                    return mSink;
                }
            }
            
            public void Done()
            {
                foreach (SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.InspectJarEntryRequest request in mRequests)
                {
                    request.Done();
                }
            }
            
        }
        
        /// <summary>
        /// Configuration of a signer.
        /// 
        /// &lt;p&gt;Use {@link Builder} to obtain configuration instances.
        /// </summary>
        public class SignerConfig
        {
            internal readonly string mName;
            
            internal readonly SigningServer.Android.Security.PrivateKey mPrivateKey;
            
            internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> mCertificates;
            
            internal readonly bool mDeterministicDsaSigning;
            
            internal SignerConfig(string name, SigningServer.Android.Security.PrivateKey privateKey, SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> certificates, bool deterministicDsaSigning)
            {
                mName = name;
                mPrivateKey = privateKey;
                mCertificates = SigningServer.Android.Util.Collections.UnmodifiableList(new SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate>(certificates));
                mDeterministicDsaSigning = deterministicDsaSigning;
            }
            
            /// <summary>
            /// Returns the name of this signer.
            /// </summary>
            public virtual string GetName()
            {
                return mName;
            }
            
            /// <summary>
            /// Returns the signing key of this signer.
            /// </summary>
            public virtual SigningServer.Android.Security.PrivateKey GetPrivateKey()
            {
                return mPrivateKey;
            }
            
            /// <summary>
            /// Returns the certificate(s) of this signer. The first certificate's public key corresponds
            /// to this signer's private key.
            /// </summary>
            public virtual SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> GetCertificates()
            {
                return mCertificates;
            }
            
            /// <summary>
            /// If this signer is a DSA signer, whether or not the signing is done deterministically.
            /// </summary>
            public virtual bool GetDeterministicDsaSigning()
            {
                return mDeterministicDsaSigning;
            }
            
            /// <summary>
            /// Builder of {@link SignerConfig} instances.
            /// </summary>
            public class Builder
            {
                internal readonly string mName;
                
                internal readonly SigningServer.Android.Security.PrivateKey mPrivateKey;
                
                internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> mCertificates;
                
                internal readonly bool mDeterministicDsaSigning;
                
                /// <summary>
                /// Constructs a new {@code Builder}.
                /// 
                /// @param name signer's name. The name is reflected in the name of files comprising the
                ///     JAR signature of the APK.
                /// @param privateKey signing key
                /// @param certificates list of one or more X.509 certificates. The subject public key of
                ///     the first certificate must correspond to the {@code privateKey}.
                /// </summary>
                public Builder(string name, SigningServer.Android.Security.PrivateKey privateKey, SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> certificates)
                    : this (name, privateKey, certificates, false)
                {
                }
                
                /// <summary>
                /// Constructs a new {@code Builder}.
                /// 
                /// @param name signer's name. The name is reflected in the name of files comprising the
                ///     JAR signature of the APK.
                /// @param privateKey signing key
                /// @param certificates list of one or more X.509 certificates. The subject public key of
                ///     the first certificate must correspond to the {@code privateKey}.
                /// @param deterministicDsaSigning When signing using DSA, whether or not the
                /// deterministic signing algorithm variant (RFC6979) should be used.
                /// </summary>
                public Builder(string name, SigningServer.Android.Security.PrivateKey privateKey, SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> certificates, bool deterministicDsaSigning)
                {
                    if (name.IsEmpty())
                    {
                        throw new System.ArgumentException("Empty name");
                    }
                    mName = name;
                    mPrivateKey = privateKey;
                    mCertificates = new SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate>(certificates);
                    mDeterministicDsaSigning = deterministicDsaSigning;
                }
                
                /// <summary>
                /// Returns a new {@code SignerConfig} instance configured based on the configuration of
                /// this builder.
                /// </summary>
                public virtual SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.SignerConfig Build()
                {
                    return new SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.SignerConfig(mName, mPrivateKey, mCertificates, mDeterministicDsaSigning);
                }
                
            }
            
        }
        
        /// <summary>
        /// Builder of {@link DefaultApkSignerEngine} instances.
        /// </summary>
        public class Builder
        {
            internal SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.SignerConfig> mSignerConfigs;
            
            internal SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.SignerConfig mStampSignerConfig;
            
            internal SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage mSourceStampSigningCertificateLineage;
            
            internal readonly int mMinSdkVersion;
            
            internal bool mV1SigningEnabled = true;
            
            internal bool mV2SigningEnabled = true;
            
            internal bool mV3SigningEnabled = true;
            
            internal bool mVerityEnabled = false;
            
            internal bool mDebuggableApkPermitted = true;
            
            internal bool mOtherSignersSignaturesPreserved;
            
            internal string mCreatedBy = "1.0 (Android)";
            
            internal SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage mSigningCertificateLineage;
            
            internal bool mV3SigningExplicitlyDisabled = false;
            
            internal bool mV3SigningExplicitlyEnabled = false;
            
            /// <summary>
            /// Constructs a new {@code Builder}.
            /// 
            /// @param signerConfigs information about signers with which the APK will be signed. At
            ///     least one signer configuration must be provided.
            /// @param minSdkVersion API Level of the oldest Android platform on which the APK is
            ///     supposed to be installed. See {@code minSdkVersion} attribute in the APK's {@code
            ///     AndroidManifest.xml}. The higher the version, the stronger signing features will be
            ///     enabled.
            /// </summary>
            public Builder(SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.SignerConfig> signerConfigs, int minSdkVersion)
            {
                if (signerConfigs.IsEmpty())
                {
                    throw new System.ArgumentException("At least one signer config must be provided");
                }
                if (signerConfigs.Size() > 1)
                {
                    mV3SigningEnabled = false;
                }
                mSignerConfigs = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.SignerConfig>(signerConfigs);
                mMinSdkVersion = minSdkVersion;
            }
            
            /// <summary>
            /// Returns a new {@code DefaultApkSignerEngine} instance configured based on the
            /// configuration of this builder.
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine Build()
            {
                if (mV3SigningExplicitlyDisabled && mV3SigningExplicitlyEnabled)
                {
                    throw new System.InvalidOperationException("Builder configured to both enable and disable APK " + "Signature Scheme v3 signing");
                }
                if (mV3SigningExplicitlyDisabled)
                {
                    mV3SigningEnabled = false;
                }
                else if (mV3SigningExplicitlyEnabled)
                {
                    mV3SigningEnabled = true;
                }
                if (mSigningCertificateLineage != null)
                {
                    try
                    {
                        mSignerConfigs = mSigningCertificateLineage.SortSignerConfigs(mSignerConfigs);
                        if (!mV3SigningEnabled && mSignerConfigs.Size() > 1)
                        {
                            throw new System.InvalidOperationException("Provided multiple signers which are part of the" + " SigningCertificateLineage, but not signing with APK" + " Signature Scheme v3");
                        }
                    }
                    catch (System.ArgumentException e)
                    {
                        throw new System.InvalidOperationException("Provided signer configs do not match the " + "provided SigningCertificateLineage", e);
                    }
                }
                else if (mV3SigningEnabled && mSignerConfigs.Size() > 1)
                {
                    throw new System.InvalidOperationException("Multiple signing certificates provided for use with APK Signature Scheme" + " v3 without an accompanying SigningCertificateLineage");
                }
                return new SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine(mSignerConfigs, mStampSignerConfig, mSourceStampSigningCertificateLineage, mMinSdkVersion, mV1SigningEnabled, mV2SigningEnabled, mV3SigningEnabled, mVerityEnabled, mDebuggableApkPermitted, mOtherSignersSignaturesPreserved, mCreatedBy, mSigningCertificateLineage);
            }
            
            /// <summary>
            /// Sets the signer configuration for the SourceStamp to be embedded in the APK.
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.Builder SetStampSignerConfig(SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.SignerConfig stampSignerConfig)
            {
                mStampSignerConfig = stampSignerConfig;
                return this;
            }
            
            /// <summary>
            /// Sets the source stamp {@link SigningCertificateLineage}. This structure provides proof of
            /// signing certificate rotation for certificates previously used to sign source stamps.
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.Builder SetSourceStampSigningCertificateLineage(SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage sourceStampSigningCertificateLineage)
            {
                mSourceStampSigningCertificateLineage = sourceStampSigningCertificateLineage;
                return this;
            }
            
            /// <summary>
            /// Sets whether the APK should be signed using JAR signing (aka v1 signature scheme).
            /// 
            /// &lt;p&gt;By default, the APK will be signed using this scheme.
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.Builder SetV1SigningEnabled(bool enabled)
            {
                mV1SigningEnabled = enabled;
                return this;
            }
            
            /// <summary>
            /// Sets whether the APK should be signed using APK Signature Scheme v2 (aka v2 signature
            /// scheme).
            /// 
            /// &lt;p&gt;By default, the APK will be signed using this scheme.
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.Builder SetV2SigningEnabled(bool enabled)
            {
                mV2SigningEnabled = enabled;
                return this;
            }
            
            /// <summary>
            /// Sets whether the APK should be signed using APK Signature Scheme v3 (aka v3 signature
            /// scheme).
            /// 
            /// &lt;p&gt;By default, the APK will be signed using this scheme.
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.Builder SetV3SigningEnabled(bool enabled)
            {
                mV3SigningEnabled = enabled;
                if (enabled)
                {
                    mV3SigningExplicitlyEnabled = true;
                }
                else 
                {
                    mV3SigningExplicitlyDisabled = true;
                }
                return this;
            }
            
            /// <summary>
            /// Sets whether the APK should be signed using the verity signature algorithm in the v2 and
            /// v3 signature blocks.
            /// 
            /// &lt;p&gt;By default, the APK will be signed using the verity signature algorithm for the v2 and
            /// v3 signature schemes.
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.Builder SetVerityEnabled(bool enabled)
            {
                mVerityEnabled = enabled;
                return this;
            }
            
            /// <summary>
            /// Sets whether the APK should be signed even if it is marked as debuggable ({@code
            /// android:debuggable="true"} in its {@code AndroidManifest.xml}). For backward
            /// compatibility reasons, the default value of this setting is {@code true}.
            /// 
            /// &lt;p&gt;It is dangerous to sign debuggable APKs with production/release keys because Android
            /// platform loosens security checks for such APKs. For example, arbitrary unauthorized code
            /// may be executed in the context of such an app by anybody with ADB shell access.
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.Builder SetDebuggableApkPermitted(bool permitted)
            {
                mDebuggableApkPermitted = permitted;
                return this;
            }
            
            /// <summary>
            /// Sets whether signatures produced by signers other than the ones configured in this engine
            /// should be copied from the input APK to the output APK.
            /// 
            /// &lt;p&gt;By default, signatures of other signers are omitted from the output APK.
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.Builder SetOtherSignersSignaturesPreserved(bool preserved)
            {
                mOtherSignersSignaturesPreserved = preserved;
                return this;
            }
            
            /// <summary>
            /// Sets the value of the {@code Created-By} field in JAR signature files.
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.Builder SetCreatedBy(string createdBy)
            {
                if (createdBy == null)
                {
                    throw new System.NullReferenceException();
                }
                mCreatedBy = createdBy;
                return this;
            }
            
            /// <summary>
            /// Sets the {@link SigningCertificateLineage} to use with the v3 signature scheme. This
            /// structure provides proof of signing certificate rotation linking {@link SignerConfig}
            /// objects to previous ones.
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.Builder SetSigningCertificateLineage(SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage signingCertificateLineage)
            {
                if (signingCertificateLineage != null)
                {
                    mV3SigningEnabled = true;
                    mSigningCertificateLineage = signingCertificateLineage;
                }
                return this;
            }
            
        }
        
    }
    
}
