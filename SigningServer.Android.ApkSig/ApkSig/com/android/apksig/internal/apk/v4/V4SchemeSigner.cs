// <auto-generated>
// This code was auto-generated.
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
// </auto-generated>

/*
 * Copyright (C) 2022 Daniel Kuschny (C# port)
 * Copyright (C) 2020 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

using System;

namespace SigningServer.Android.Com.Android.Apksig.Internal.Apk.V4
{
    /// <summary>
    /// APK Signature Scheme V4 signer. V4 scheme file contains 2 mandatory fields - used during
    /// installation. And optional verity tree - has to be present during session commit.
    /// &lt;p&gt;
    /// The fields:
    /// &lt;p&gt;
    /// 1. hashingInfo - verity root hash and hashing info,
    /// 2. signingInfo - certificate, public key and signature,
    /// For more details see V4Signature.
    /// &lt;/p&gt;
    /// (optional) verityTree: integer size prepended bytes of the verity hash tree.
    /// &lt;p&gt;
    /// TODO(schfan): Add v4 unit tests
    /// </summary>
    public abstract class V4SchemeSigner
    {
        /// <summary>
        /// Hidden constructor to prevent instantiation.
        /// </summary>
        internal V4SchemeSigner()
        {
        }
        
        /// <summary>
        /// Based on a public key, return a signing algorithm that supports verity.
        /// </summary>
        public static SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm> GetSuggestedSignatureAlgorithms(SigningServer.Android.Security.PublicKey signingKey, int minSdkVersion, bool apkSigningBlockPaddingSupported, bool deterministicDsaSigning)
        {
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm> algorithms = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SchemeSigner.GetSuggestedSignatureAlgorithms(signingKey, minSdkVersion, apkSigningBlockPaddingSupported, deterministicDsaSigning);
            for (SigningServer.Android.Collections.Iterator<SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm> iter = algorithms.ListIterator();iter.HasNext();)
            {
                SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm algorithm = iter.Next();
                if (!SigningServer.Android.Com.Android.Apksig.Internal.Apk.V4.V4SchemeSigner.IsSupported(algorithm.GetContentDigestAlgorithm(), false))
                {
                    iter.Remove();
                }
            }
            return algorithms;
        }
        
        /// <summary>
        /// Compute hash tree and generate v4 signature for a given APK. Write the serialized data to
        /// output file.
        /// </summary>
        public static void GenerateV4Signature(SigningServer.Android.Com.Android.Apksig.Util.DataSource apkContent, SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignerConfig signerConfig, System.IO.FileInfo outputFile)
        {
            SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V4.V4Signature, byte[]> pair = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V4.V4SchemeSigner.GenerateV4Signature(apkContent, signerConfig);
            try
            {
                using(SigningServer.Android.IO.OutputStream output = new SigningServer.Android.IO.FileOutputStream(outputFile))
                {
                    pair.GetFirst().WriteTo(output);
                    SigningServer.Android.Com.Android.Apksig.Internal.Apk.V4.V4Signature.WriteBytes(output, pair.GetSecond());
                }
            }
            catch (global::System.IO.IOException e)
            {
                outputFile.Delete();
                throw e;
            }
        }
        
        /// <summary>
        /// Generate v4 signature and hash tree for a given APK.
        /// </summary>
        public static SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V4.V4Signature, byte[]> GenerateV4Signature(SigningServer.Android.Com.Android.Apksig.Util.DataSource apkContent, SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignerConfig signerConfig)
        {
            byte[] salt = null;
            byte[] additionalData = null;
            long fileSize = apkContent.Size();
            byte[] apkDigest = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V4.V4SchemeSigner.GetApkDigest(apkContent);
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VerityTreeAndDigest verityContentDigestInfo = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ComputeChunkVerityTreeAndDigest(apkContent);
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm verityContentDigestAlgorithm = verityContentDigestInfo.contentDigestAlgorithm;
            byte[] rootHash = verityContentDigestInfo.rootHash;
            byte[] tree = verityContentDigestInfo.tree;
            SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<int, byte> hashingAlgorithmBlockSizePair = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V4.V4SchemeSigner.ConvertToV4HashingInfo(verityContentDigestAlgorithm);
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.V4.V4Signature.HashingInfo hashingInfo = new SigningServer.Android.Com.Android.Apksig.Internal.Apk.V4.V4Signature.HashingInfo(hashingAlgorithmBlockSizePair.GetFirst(), hashingAlgorithmBlockSizePair.GetSecond(), salt, rootHash);
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.V4.V4Signature signature;
            try
            {
                signature = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V4.V4SchemeSigner.GenerateSignature(signerConfig, hashingInfo, apkDigest, additionalData, fileSize);
            }
            catch (System.Exception e) when ( e is SigningServer.Android.Security.InvalidKeyException || e is SigningServer.Android.Security.SignatureException || e is SigningServer.Android.Security.Cert.CertificateEncodingException)
            {
                throw new SigningServer.Android.Security.InvalidKeyException("Signer failed", e);
            }
            return SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair.Of<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V4.V4Signature, byte[]>(signature, tree);
        }
        
        internal static SigningServer.Android.Com.Android.Apksig.Internal.Apk.V4.V4Signature GenerateSignature(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignerConfig signerConfig, SigningServer.Android.Com.Android.Apksig.Internal.Apk.V4.V4Signature.HashingInfo hashingInfo, byte[] apkDigest, byte[] additionaData, long fileSize)
        {
            if (signerConfig.certificates.IsEmpty())
            {
                throw new SigningServer.Android.Security.SignatureException("No certificates configured for signer");
            }
            if (signerConfig.certificates.Size() != 1)
            {
                throw new SigningServer.Android.Security.Cert.CertificateEncodingException("Should only have one certificate");
            }
            SigningServer.Android.Security.PublicKey publicKey = signerConfig.certificates.Get(0).GetPublicKey();
            SigningServer.Android.Collections.List<byte[]> encodedCertificates = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.EncodeCertificates(signerConfig.certificates);
            byte[] encodedCertificate = encodedCertificates.Get(0);
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.V4.V4Signature.SigningInfo signingInfoNoSignature = new SigningServer.Android.Com.Android.Apksig.Internal.Apk.V4.V4Signature.SigningInfo(apkDigest, encodedCertificate, additionaData, publicKey.GetEncoded(), -1, null);
            byte[] data = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V4.V4Signature.GetSignedData(fileSize, hashingInfo, signingInfoNoSignature);
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<int, byte[]>> signatures = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.GenerateSignaturesOverData(signerConfig, data);
            if (signatures.Size() != 1)
            {
                throw new SigningServer.Android.Security.SignatureException("Should only be one signature generated");
            }
            int signatureAlgorithmId = signatures.Get(0).GetFirst();
            byte[] signature = signatures.Get(0).GetSecond();
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.V4.V4Signature.SigningInfo signingInfo = new SigningServer.Android.Com.Android.Apksig.Internal.Apk.V4.V4Signature.SigningInfo(apkDigest, encodedCertificate, additionaData, publicKey.GetEncoded(), signatureAlgorithmId, signature);
            return new SigningServer.Android.Com.Android.Apksig.Internal.Apk.V4.V4Signature(SigningServer.Android.Com.Android.Apksig.Internal.Apk.V4.V4Signature.CURRENT_VERSION, hashingInfo.ToByteArray(), signingInfo.ToByteArray());
        }
        
        internal static byte[] GetApkDigest(SigningServer.Android.Com.Android.Apksig.Util.DataSource apk)
        {
            SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.ZipSections zipSections;
            try
            {
                zipSections = SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.FindZipSections(apk);
            }
            catch (SigningServer.Android.Com.Android.Apksig.Zip.ZipFormatException e)
            {
                throw new global::System.IO.IOException("Malformed APK: not a ZIP archive", e);
            }
            SigningServer.Android.Security.SignatureException v3Exception;
            try
            {
                return SigningServer.Android.Com.Android.Apksig.Internal.Apk.V4.V4SchemeSigner.GetBestV3Digest(apk, zipSections);
            }
            catch (SigningServer.Android.Security.SignatureException e)
            {
                v3Exception = e;
            }
            SigningServer.Android.Security.SignatureException v2Exception;
            try
            {
                return SigningServer.Android.Com.Android.Apksig.Internal.Apk.V4.V4SchemeSigner.GetBestV2Digest(apk, zipSections);
            }
            catch (SigningServer.Android.Security.SignatureException e)
            {
                v2Exception = e;
            }
            throw new global::System.IO.IOException("Failed to obtain v2/v3 digest, v3 exception: " + v3Exception + ", v2 exception: " + v2Exception);
        }
        
        internal static byte[] GetBestV3Digest(SigningServer.Android.Com.Android.Apksig.Util.DataSource apk, SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.ZipSections zipSections)
        {
            SigningServer.Android.Collections.Set<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm> contentDigestsToVerify = new SigningServer.Android.Collections.HashSet<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm>(1);
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result result = new SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V3);
            try
            {
                SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureInfo signatureInfo = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.FindSignature(apk, zipSections, SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SchemeConstants.APK_SIGNATURE_SCHEME_V3_BLOCK_ID, result);
                SigningServer.Android.IO.ByteBuffer apkSignatureSchemeV3Block = signatureInfo.signatureBlock;
                SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SchemeVerifier.ParseSigners(apkSignatureSchemeV3Block, contentDigestsToVerify, result);
            }
            catch (System.Exception e)
            {
                throw new SigningServer.Android.Security.SignatureException("Failed to extract and parse v3 block", e);
            }
            if (result.signers.Size() != 1)
            {
                throw new SigningServer.Android.Security.SignatureException("Should only have one signer, errors: " + result.GetErrors());
            }
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo signer = result.signers.Get(0);
            if (signer.ContainsErrors())
            {
                throw new SigningServer.Android.Security.SignatureException("Parsing failed: " + signer.GetErrors());
            }
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo.ContentDigest> contentDigests = result.signers.Get(0).contentDigests;
            return SigningServer.Android.Com.Android.Apksig.Internal.Apk.V4.V4SchemeSigner.PickBestDigest(contentDigests);
        }
        
        internal static byte[] GetBestV2Digest(SigningServer.Android.Com.Android.Apksig.Util.DataSource apk, SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.ZipSections zipSections)
        {
            SigningServer.Android.Collections.Set<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm> contentDigestsToVerify = new SigningServer.Android.Collections.HashSet<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm>(1);
            SigningServer.Android.Collections.Set<int> foundApkSigSchemeIds = new SigningServer.Android.Collections.HashSet<int>(1);
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result result = new SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V2);
            try
            {
                SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureInfo signatureInfo = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.FindSignature(apk, zipSections, SigningServer.Android.Com.Android.Apksig.Internal.Apk.V2.V2SchemeConstants.APK_SIGNATURE_SCHEME_V2_BLOCK_ID, result);
                SigningServer.Android.IO.ByteBuffer apkSignatureSchemeV2Block = signatureInfo.signatureBlock;
                var maxValue = int.MaxValue;
                SigningServer.Android.Com.Android.Apksig.Internal.Apk.V2.V2SchemeVerifier.ParseSigners(
                    apkSignatureSchemeV2Block
                    , 
                    contentDigestsToVerify
                    , 
                    SigningServer.Android.Util.Collections.EmptyMap<int, string>()
                    , 
                    foundApkSigSchemeIds
                    , 
                    maxValue
                    , 
                    maxValue
                    , 
                    result
                
                );
            }
            catch (System.Exception e)
            {
                throw new SigningServer.Android.Security.SignatureException("Failed to extract and parse v2 block", e);
            }
            if (result.signers.Size() != 1)
            {
                throw new SigningServer.Android.Security.SignatureException("Should only have one signer, errors: " + result.GetErrors());
            }
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo signer = result.signers.Get(0);
            if (signer.ContainsErrors())
            {
                throw new SigningServer.Android.Security.SignatureException("Parsing failed: " + signer.GetErrors());
            }
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo.ContentDigest> contentDigests = signer.contentDigests;
            return SigningServer.Android.Com.Android.Apksig.Internal.Apk.V4.V4SchemeSigner.PickBestDigest(contentDigests);
        }
        
        internal static byte[] PickBestDigest(SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo.ContentDigest> contentDigests)
        {
            if (contentDigests == null || contentDigests.IsEmpty())
            {
                throw new SigningServer.Android.Security.SignatureException("Should have at least one digest");
            }
            int bestAlgorithmOrder = -1;
            byte[] bestDigest = null;
            foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo.ContentDigest contentDigest in contentDigests)
            {
                SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm signatureAlgorithm = SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm.FindById(contentDigest.GetSignatureAlgorithmId());
                SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm contentDigestAlgorithm = signatureAlgorithm.GetContentDigestAlgorithm();
                if (!SigningServer.Android.Com.Android.Apksig.Internal.Apk.V4.V4SchemeSigner.IsSupported(contentDigestAlgorithm, true))
                {
                    continue;
                }
                int algorithmOrder = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V4.V4SchemeSigner.DigestAlgorithmSortingOrder(contentDigestAlgorithm);
                if (bestAlgorithmOrder < algorithmOrder)
                {
                    bestAlgorithmOrder = algorithmOrder;
                    bestDigest = contentDigest.GetValue();
                }
            }
            if (bestDigest == null)
            {
                throw new SigningServer.Android.Security.SignatureException("Failed to find a supported digest in the source APK");
            }
            return bestDigest;
        }
        
        public static int DigestAlgorithmSortingOrder(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm contentDigestAlgorithm)
        {
            switch (contentDigestAlgorithm.Case)
            {
                case SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm.CHUNKED_SHA256_CASE:
                    return 0;
                case SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm.VERITY_CHUNKED_SHA256_CASE:
                    return 1;
                case SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm.CHUNKED_SHA512_CASE:
                    return 2;
                default:
                    return -1;
            }
        }
        
        internal static bool IsSupported(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm contentDigestAlgorithm, bool forV3Digest)
        {
            if (contentDigestAlgorithm == null)
            {
                return false;
            }
            if (contentDigestAlgorithm == SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm.CHUNKED_SHA256 || contentDigestAlgorithm == SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm.CHUNKED_SHA512 || (forV3Digest && contentDigestAlgorithm == SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm.VERITY_CHUNKED_SHA256))
            {
                return true;
            }
            return false;
        }
        
        internal static SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<int, byte> ConvertToV4HashingInfo(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm algorithm)
        {
            switch (algorithm.Case)
            {
                case SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm.VERITY_CHUNKED_SHA256_CASE:
                    return SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair.Of<int, byte>(SigningServer.Android.Com.Android.Apksig.Internal.Apk.V4.V4Signature.HASHING_ALGORITHM_SHA256, SigningServer.Android.Com.Android.Apksig.Internal.Apk.V4.V4Signature.LOG2_BLOCK_SIZE_4096_BYTES);
                default:
                    throw new SigningServer.Android.Security.NoSuchAlgorithmException("Invalid hash algorithm, only SHA2-256 over 4 KB chunks supported.");
            }
        }
        
    }
    
}
