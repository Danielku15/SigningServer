// <auto-generated>
// This code was auto-generated.
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
// </auto-generated>

using System;

namespace SigningServer.Android.Com.Android.Apksig
{
    /// <summary>
    /// APK signer.
    /// 
    /// &lt;p&gt;The signer preserves as much of the input APK as possible. For example, it preserves the order
    /// of APK entries and preserves their contents, including compressed form and alignment of data.
    /// 
    /// &lt;p&gt;Use {@link Builder} to obtain instances of this signer.
    /// 
    /// @see &lt;a href="https://source.android.com/security/apksigning/index.html"&gt;Application Signing&lt;/a&gt;
    /// </summary>
    public class ApkSigner
    {
        /// <summary>
        /// Extensible data block/field header ID used for storing information about alignment of
        /// uncompressed entries as well as for aligning the entries's data. See ZIP appnote.txt section
        /// 4.5 Extensible data fields.
        /// </summary>
        internal static readonly short ALIGNMENT_ZIP_EXTRA_DATA_FIELD_HEADER_ID = unchecked((short)0xd935);
        
        /// <summary>
        /// Minimum size (in bytes) of the extensible data block/field used for alignment of uncompressed
        /// entries.
        /// </summary>
        internal static readonly short ALIGNMENT_ZIP_EXTRA_DATA_FIELD_MIN_SIZE_BYTES = 6;
        
        internal static readonly short ANDROID_COMMON_PAGE_ALIGNMENT_BYTES = 4096;
        
        /// <summary>
        /// Name of the Android manifest ZIP entry in APKs.
        /// </summary>
        internal static readonly string ANDROID_MANIFEST_ZIP_ENTRY_NAME = "AndroidManifest.xml";
        
        internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkSigner.SignerConfig> mSignerConfigs;
        
        internal readonly SigningServer.Android.Com.Android.Apksig.ApkSigner.SignerConfig mSourceStampSignerConfig;
        
        internal readonly SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage mSourceStampSigningCertificateLineage;
        
        internal readonly bool mForceSourceStampOverwrite;
        
        internal readonly int? mMinSdkVersion;
        
        internal readonly bool mV1SigningEnabled;
        
        internal readonly bool mV2SigningEnabled;
        
        internal readonly bool mV3SigningEnabled;
        
        internal readonly bool mV4SigningEnabled;
        
        internal readonly bool mVerityEnabled;
        
        internal readonly bool mV4ErrorReportingEnabled;
        
        internal readonly bool mDebuggableApkPermitted;
        
        internal readonly bool mOtherSignersSignaturesPreserved;
        
        internal readonly string mCreatedBy;
        
        internal readonly SigningServer.Android.Com.Android.Apksig.ApkSignerEngine mSignerEngine;
        
        internal readonly System.IO.FileInfo mInputApkFile;
        
        internal readonly SigningServer.Android.Com.Android.Apksig.Util.DataSource mInputApkDataSource;
        
        internal readonly System.IO.FileInfo mOutputApkFile;
        
        internal readonly SigningServer.Android.Com.Android.Apksig.Util.DataSink mOutputApkDataSink;
        
        internal readonly SigningServer.Android.Com.Android.Apksig.Util.DataSource mOutputApkDataSource;
        
        internal readonly System.IO.FileInfo mOutputV4File;
        
        internal readonly SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage mSigningCertificateLineage;
        
        internal ApkSigner(SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkSigner.SignerConfig> signerConfigs, SigningServer.Android.Com.Android.Apksig.ApkSigner.SignerConfig sourceStampSignerConfig, SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage sourceStampSigningCertificateLineage, bool forceSourceStampOverwrite, int? minSdkVersion, bool v1SigningEnabled, bool v2SigningEnabled, bool v3SigningEnabled, bool v4SigningEnabled, bool verityEnabled, bool v4ErrorReportingEnabled, bool debuggableApkPermitted, bool otherSignersSignaturesPreserved, string createdBy, SigningServer.Android.Com.Android.Apksig.ApkSignerEngine signerEngine, System.IO.FileInfo inputApkFile, SigningServer.Android.Com.Android.Apksig.Util.DataSource inputApkDataSource, System.IO.FileInfo outputApkFile, SigningServer.Android.Com.Android.Apksig.Util.DataSink outputApkDataSink, SigningServer.Android.Com.Android.Apksig.Util.DataSource outputApkDataSource, System.IO.FileInfo outputV4File, SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage signingCertificateLineage)
        {
            mSignerConfigs = signerConfigs;
            mSourceStampSignerConfig = sourceStampSignerConfig;
            mSourceStampSigningCertificateLineage = sourceStampSigningCertificateLineage;
            mForceSourceStampOverwrite = forceSourceStampOverwrite;
            mMinSdkVersion = minSdkVersion;
            mV1SigningEnabled = v1SigningEnabled;
            mV2SigningEnabled = v2SigningEnabled;
            mV3SigningEnabled = v3SigningEnabled;
            mV4SigningEnabled = v4SigningEnabled;
            mVerityEnabled = verityEnabled;
            mV4ErrorReportingEnabled = v4ErrorReportingEnabled;
            mDebuggableApkPermitted = debuggableApkPermitted;
            mOtherSignersSignaturesPreserved = otherSignersSignaturesPreserved;
            mCreatedBy = createdBy;
            mSignerEngine = signerEngine;
            mInputApkFile = inputApkFile;
            mInputApkDataSource = inputApkDataSource;
            mOutputApkFile = outputApkFile;
            mOutputApkDataSink = outputApkDataSink;
            mOutputApkDataSource = outputApkDataSource;
            mOutputV4File = outputV4File;
            mSigningCertificateLineage = signingCertificateLineage;
        }
        
        /// <summary>
        /// Signs the input APK and outputs the resulting signed APK. The input APK is not modified.
        /// 
        /// @throws IOException if an I/O error is encountered while reading or writing the APKs
        /// @throws ApkFormatException if the input APK is malformed
        /// @throws NoSuchAlgorithmException if the APK signatures cannot be produced or verified because
        ///     a required cryptographic algorithm implementation is missing
        /// @throws InvalidKeyException if a signature could not be generated because a signing key is
        ///     not suitable for generating the signature
        /// @throws SignatureException if an error occurred while generating or verifying a signature
        /// @throws IllegalStateException if this signer's configuration is missing required information
        ///     or if the signing engine is in an invalid state.
        /// </summary>
        public virtual void Sign()
        {
            System.IDisposable input = null;
            SigningServer.Android.Com.Android.Apksig.Util.DataSource inputApk;
            try
            {
                if (mInputApkDataSource != null)
                {
                    inputApk = mInputApkDataSource;
                }
                else if (mInputApkFile != null)
                {
                    SigningServer.Android.IO.RandomAccessFile inputFile = new SigningServer.Android.IO.RandomAccessFile(mInputApkFile, "r");
                    input = inputFile;
                    inputApk = SigningServer.Android.Com.Android.Apksig.Util.DataSources.AsDataSource(inputFile);
                }
                else 
                {
                    throw new System.InvalidOperationException("Input APK not specified");
                }
                System.IDisposable output = null;
                try
                {
                    SigningServer.Android.Com.Android.Apksig.Util.DataSink outputApkOut;
                    SigningServer.Android.Com.Android.Apksig.Util.DataSource outputApkIn;
                    if (mOutputApkDataSink != null)
                    {
                        outputApkOut = mOutputApkDataSink;
                        outputApkIn = mOutputApkDataSource;
                    }
                    else if (mOutputApkFile != null)
                    {
                        SigningServer.Android.IO.RandomAccessFile outputFile = new SigningServer.Android.IO.RandomAccessFile(mOutputApkFile, "rw");
                        output = outputFile;
                        outputFile.SetLength(0);
                        outputApkOut = SigningServer.Android.Com.Android.Apksig.Util.DataSinks.AsDataSink(outputFile);
                        outputApkIn = SigningServer.Android.Com.Android.Apksig.Util.DataSources.AsDataSource(outputFile);
                    }
                    else 
                    {
                        throw new System.InvalidOperationException("Output APK not specified");
                    }
                    Sign(inputApk, outputApkOut, outputApkIn);
                }
                finally
                {
                    if (output != null)
                    {
                        output.Dispose();
                    }
                }
            }
            finally
            {
                if (input != null)
                {
                    input.Dispose();
                }
            }
        }
        
        internal void Sign(SigningServer.Android.Com.Android.Apksig.Util.DataSource inputApk, SigningServer.Android.Com.Android.Apksig.Util.DataSink outputApkOut, SigningServer.Android.Com.Android.Apksig.Util.DataSource outputApkIn)
        {
            SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.ZipSections inputZipSections;
            try
            {
                inputZipSections = SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.FindZipSections(inputApk);
            }
            catch (SigningServer.Android.Com.Android.Apksig.Zip.ZipFormatException e)
            {
                throw new SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException("Malformed APK: not a ZIP archive", e);
            }
            long inputApkSigningBlockOffset = -1;
            SigningServer.Android.Com.Android.Apksig.Util.DataSource inputApkSigningBlock = null;
            try
            {
                SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.ApkSigningBlock apkSigningBlockInfo = SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.FindApkSigningBlock(inputApk, inputZipSections);
                inputApkSigningBlockOffset = apkSigningBlockInfo.GetStartOffset();
                inputApkSigningBlock = apkSigningBlockInfo.GetContents();
            }
            catch (SigningServer.Android.Com.Android.Apksig.Apk.ApkSigningBlockNotFoundException e)
            {
            }
            SigningServer.Android.Com.Android.Apksig.Util.DataSource inputApkLfhSection = inputApk.Slice(0, (inputApkSigningBlockOffset != -1) ? inputApkSigningBlockOffset : inputZipSections.GetZipCentralDirectoryOffset());
            SigningServer.Android.IO.ByteBuffer inputCd = SigningServer.Android.Com.Android.Apksig.ApkSigner.GetZipCentralDirectory(inputApk, inputZipSections);
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord> inputCdRecords = SigningServer.Android.Com.Android.Apksig.ApkSigner.ParseZipCentralDirectory(inputCd, inputZipSections);
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Hints.PatternWithRange> pinPatterns = SigningServer.Android.Com.Android.Apksig.ApkSigner.ExtractPinPatterns(inputCdRecords, inputApkLfhSection);
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Hints.ByteRange> pinByteRanges = pinPatterns == null ? null : new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Hints.ByteRange>();
            SigningServer.Android.Com.Android.Apksig.ApkSignerEngine signerEngine;
            if (mSignerEngine != null)
            {
                signerEngine = mSignerEngine;
            }
            else 
            {
                int minSdkVersion;
                if (mMinSdkVersion != null)
                {
                    minSdkVersion = mMinSdkVersion.Value;
                }
                else 
                {
                    minSdkVersion = SigningServer.Android.Com.Android.Apksig.ApkSigner.GetMinSdkVersionFromApk(inputCdRecords, inputApkLfhSection);
                }
                SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.SignerConfig> engineSignerConfigs = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.SignerConfig>(mSignerConfigs.Size());
                foreach (SigningServer.Android.Com.Android.Apksig.ApkSigner.SignerConfig signerConfig in mSignerConfigs)
                {
                    engineSignerConfigs.Add(new SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.SignerConfig.Builder(signerConfig.GetName(), signerConfig.GetPrivateKey(), signerConfig.GetCertificates(), signerConfig.GetDeterministicDsaSigning()).Build());
                }
                SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.Builder signerEngineBuilder = new SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.Builder(engineSignerConfigs, minSdkVersion).SetV1SigningEnabled(mV1SigningEnabled).SetV2SigningEnabled(mV2SigningEnabled).SetV3SigningEnabled(mV3SigningEnabled).SetVerityEnabled(mVerityEnabled).SetDebuggableApkPermitted(mDebuggableApkPermitted).SetOtherSignersSignaturesPreserved(mOtherSignersSignaturesPreserved).SetSigningCertificateLineage(mSigningCertificateLineage);
                if (mCreatedBy != null)
                {
                    signerEngineBuilder.SetCreatedBy(mCreatedBy);
                }
                if (mSourceStampSignerConfig != null)
                {
                    signerEngineBuilder.SetStampSignerConfig(new SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.SignerConfig.Builder(mSourceStampSignerConfig.GetName(), mSourceStampSignerConfig.GetPrivateKey(), mSourceStampSignerConfig.GetCertificates(), mSourceStampSignerConfig.GetDeterministicDsaSigning()).Build());
                }
                if (mSourceStampSigningCertificateLineage != null)
                {
                    signerEngineBuilder.SetSourceStampSigningCertificateLineage(mSourceStampSigningCertificateLineage);
                }
                signerEngine = signerEngineBuilder.Build();
            }
            if (inputApkSigningBlock != null)
            {
                signerEngine.InputApkSigningBlock(inputApkSigningBlock);
            }
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord> inputCdRecordsSortedByLfhOffset = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord>(inputCdRecords);
            SigningServer.Android.Util.Collections.Sort(inputCdRecordsSortedByLfhOffset, SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord.BY_LOCAL_FILE_HEADER_OFFSET_COMPARATOR);
            int lastModifiedDateForNewEntries = -1;
            int lastModifiedTimeForNewEntries = -1;
            long inputOffset = 0;
            long outputOffset = 0;
            byte[] sourceStampCertificateDigest = null;
            SigningServer.Android.Collections.Map<string, SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord> outputCdRecordsByName = new SigningServer.Android.Collections.HashMap<string, SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord>(inputCdRecords.Size());
            foreach (SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord inputCdRecord in inputCdRecordsSortedByLfhOffset)
            {
                string entryName = inputCdRecord.GetName();
                if (SigningServer.Android.Com.Android.Apksig.Hints.PIN_BYTE_RANGE_ZIP_ENTRY_NAME.Equals(entryName))
                {
                    continue;
                }
                if (SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.SOURCE_STAMP_CERTIFICATE_HASH_ZIP_ENTRY_NAME.Equals(entryName))
                {
                    try
                    {
                        sourceStampCertificateDigest = SigningServer.Android.Com.Android.Apksig.Internal.Zip.LocalFileRecord.GetUncompressedData(inputApkLfhSection, inputCdRecord, inputApkLfhSection.Size());
                    }
                    catch (SigningServer.Android.Com.Android.Apksig.Zip.ZipFormatException ex)
                    {
                        throw new SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException("Bad source stamp entry");
                    }
                    continue;
                }
                SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.InputJarEntryInstructions entryInstructions = signerEngine.InputJarEntry(entryName);
                bool shouldOutput;
                switch (entryInstructions.GetOutputPolicy())
                {
                    case SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.InputJarEntryInstructions.OutputPolicy.OUTPUT:
                        shouldOutput = true;
                        break;
                    case SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.InputJarEntryInstructions.OutputPolicy.OUTPUT_BY_ENGINE:
                    case SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.InputJarEntryInstructions.OutputPolicy.SKIP:
                        shouldOutput = false;
                        break;
                    default:
                        throw new SigningServer.Android.Core.RuntimeException("Unknown output policy: " + entryInstructions.GetOutputPolicy());
                }
                long inputLocalFileHeaderStartOffset = inputCdRecord.GetLocalFileHeaderOffset();
                if (inputLocalFileHeaderStartOffset > inputOffset)
                {
                    long chunkSize = inputLocalFileHeaderStartOffset - inputOffset;
                    inputApkLfhSection.Feed(inputOffset, chunkSize, outputApkOut);
                    outputOffset += chunkSize;
                    inputOffset = inputLocalFileHeaderStartOffset;
                }
                SigningServer.Android.Com.Android.Apksig.Internal.Zip.LocalFileRecord inputLocalFileRecord;
                try
                {
                    inputLocalFileRecord = SigningServer.Android.Com.Android.Apksig.Internal.Zip.LocalFileRecord.GetRecord(inputApkLfhSection, inputCdRecord, inputApkLfhSection.Size());
                }
                catch (SigningServer.Android.Com.Android.Apksig.Zip.ZipFormatException e)
                {
                    throw new SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException("Malformed ZIP entry: " + inputCdRecord.GetName(), e);
                }
                inputOffset += inputLocalFileRecord.GetSize();
                SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.InspectJarEntryRequest inspectEntryRequest = entryInstructions.GetInspectJarEntryRequest();
                if (inspectEntryRequest != null)
                {
                    SigningServer.Android.Com.Android.Apksig.ApkSigner.FulfillInspectInputJarEntryRequest(inputApkLfhSection, inputLocalFileRecord, inspectEntryRequest);
                }
                if (shouldOutput)
                {
                    int lastModifiedDate = inputCdRecord.GetLastModificationDate();
                    int lastModifiedTime = inputCdRecord.GetLastModificationTime();
                    if ((lastModifiedDateForNewEntries == -1) || (lastModifiedDate > lastModifiedDateForNewEntries) || ((lastModifiedDate == lastModifiedDateForNewEntries) && (lastModifiedTime > lastModifiedTimeForNewEntries)))
                    {
                        lastModifiedDateForNewEntries = lastModifiedDate;
                        lastModifiedTimeForNewEntries = lastModifiedTime;
                    }
                    inspectEntryRequest = signerEngine.OutputJarEntry(entryName);
                    if (inspectEntryRequest != null)
                    {
                        SigningServer.Android.Com.Android.Apksig.ApkSigner.FulfillInspectInputJarEntryRequest(inputApkLfhSection, inputLocalFileRecord, inspectEntryRequest);
                    }
                    long outputLocalFileHeaderOffset = outputOffset;
                    SigningServer.Android.Com.Android.Apksig.ApkSigner.OutputSizeAndDataOffset outputLfrResult = SigningServer.Android.Com.Android.Apksig.ApkSigner.OutputInputJarEntryLfhRecordPreservingDataAlignment(inputApkLfhSection, inputLocalFileRecord, outputApkOut, outputLocalFileHeaderOffset);
                    outputOffset += outputLfrResult.outputBytes;
                    long outputDataOffset = outputLocalFileHeaderOffset + outputLfrResult.dataOffsetBytes;
                    if (pinPatterns != null)
                    {
                        bool pinFileHeader = false;
                        foreach (SigningServer.Android.Com.Android.Apksig.Hints.PatternWithRange pinPattern in pinPatterns)
                        {
                            if (pinPattern.Matcher(inputCdRecord.GetName()).Matches())
                            {
                                SigningServer.Android.Com.Android.Apksig.Hints.ByteRange dataRange = new SigningServer.Android.Com.Android.Apksig.Hints.ByteRange(outputDataOffset, outputOffset);
                                SigningServer.Android.Com.Android.Apksig.Hints.ByteRange pinRange = pinPattern.ClampToAbsoluteByteRange(dataRange);
                                if (pinRange != null)
                                {
                                    pinFileHeader = true;
                                    pinByteRanges.Add(pinRange);
                                }
                            }
                        }
                        if (pinFileHeader)
                        {
                            pinByteRanges.Add(new SigningServer.Android.Com.Android.Apksig.Hints.ByteRange(outputLocalFileHeaderOffset, outputDataOffset));
                        }
                    }
                    SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord outputCdRecord;
                    if (outputLocalFileHeaderOffset == inputLocalFileRecord.GetStartOffsetInArchive())
                    {
                        outputCdRecord = inputCdRecord;
                    }
                    else 
                    {
                        outputCdRecord = inputCdRecord.CreateWithModifiedLocalFileHeaderOffset(outputLocalFileHeaderOffset);
                    }
                    outputCdRecordsByName.Put(entryName, outputCdRecord);
                }
            }
            long inputLfhSectionSize = inputApkLfhSection.Size();
            if (inputOffset < inputLfhSectionSize)
            {
                long chunkSize = inputLfhSectionSize - inputOffset;
                inputApkLfhSection.Feed(inputOffset, chunkSize, outputApkOut);
                outputOffset += chunkSize;
                inputOffset = inputLfhSectionSize;
            }
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord> outputCdRecords = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord>(inputCdRecords.Size() + 10);
            foreach (SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord inputCdRecord in inputCdRecords)
            {
                string entryName = inputCdRecord.GetName();
                SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord outputCdRecord = outputCdRecordsByName.Get(entryName);
                if (outputCdRecord != null)
                {
                    outputCdRecords.Add(outputCdRecord);
                }
            }
            if (lastModifiedDateForNewEntries == -1)
            {
                lastModifiedDateForNewEntries = 0x3a21;
                lastModifiedTimeForNewEntries = 0;
            }
            if (signerEngine.IsEligibleForSourceStamp())
            {
                byte[] uncompressedData = signerEngine.GenerateSourceStampCertificateDigest();
                if (mForceSourceStampOverwrite || sourceStampCertificateDigest == null || SigningServer.Android.Collections.Arrays.Equals(uncompressedData, sourceStampCertificateDigest))
                {
                    outputOffset += SigningServer.Android.Com.Android.Apksig.ApkSigner.OutputDataToOutputApk(
                        SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.SOURCE_STAMP_CERTIFICATE_HASH_ZIP_ENTRY_NAME
                        , 
                        uncompressedData
                        , 
                        outputOffset
                        , 
                        outputCdRecords
                        , 
                        lastModifiedTimeForNewEntries
                        , 
                        lastModifiedDateForNewEntries
                        , 
                        outputApkOut
                    
                    );
                }
                else 
                {
                    throw new SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException(SigningServer.Android.Core.StringExtensions.Format("Cannot generate SourceStamp. APK contains an existing entry with" + " the name: %s, and it is different than the provided source" + " stamp certificate", SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.SOURCE_STAMP_CERTIFICATE_HASH_ZIP_ENTRY_NAME));
                }
            }
            if (pinByteRanges != null)
            {
                pinByteRanges.Add(new SigningServer.Android.Com.Android.Apksig.Hints.ByteRange(outputOffset, SigningServer.Android.Core.LongExtensions.MAX_VALUE));
                string entryName = SigningServer.Android.Com.Android.Apksig.Hints.PIN_BYTE_RANGE_ZIP_ENTRY_NAME;
                byte[] uncompressedData = SigningServer.Android.Com.Android.Apksig.Hints.EncodeByteRangeList(pinByteRanges);
                SigningServer.Android.Com.Android.Apksig.ApkSigner.RequestOutputEntryInspection(signerEngine, entryName, uncompressedData);
                outputOffset += SigningServer.Android.Com.Android.Apksig.ApkSigner.OutputDataToOutputApk(
                    entryName
                    , 
                    uncompressedData
                    , 
                    outputOffset
                    , 
                    outputCdRecords
                    , 
                    lastModifiedTimeForNewEntries
                    , 
                    lastModifiedDateForNewEntries
                    , 
                    outputApkOut
                
                );
            }
            SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.OutputJarSignatureRequest outputJarSignatureRequest = signerEngine.OutputJarEntries();
            if (outputJarSignatureRequest != null)
            {
                foreach (SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.OutputJarSignatureRequest.JarEntry entry in outputJarSignatureRequest.GetAdditionalJarEntries())
                {
                    string entryName = entry.GetName();
                    byte[] uncompressedData = entry.GetData();
                    SigningServer.Android.Com.Android.Apksig.ApkSigner.RequestOutputEntryInspection(signerEngine, entryName, uncompressedData);
                    outputOffset += SigningServer.Android.Com.Android.Apksig.ApkSigner.OutputDataToOutputApk(
                        entryName
                        , 
                        uncompressedData
                        , 
                        outputOffset
                        , 
                        outputCdRecords
                        , 
                        lastModifiedTimeForNewEntries
                        , 
                        lastModifiedDateForNewEntries
                        , 
                        outputApkOut
                    
                    );
                }
                outputJarSignatureRequest.Done();
            }
            long outputCentralDirSizeBytes = 0;
            foreach (SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord record in outputCdRecords)
            {
                outputCentralDirSizeBytes += record.GetSize();
            }
            if (outputCentralDirSizeBytes > SigningServer.Android.Core.IntExtensions.MAX_VALUE)
            {
                throw new global::System.IO.IOException("Output ZIP Central Directory too large: " + outputCentralDirSizeBytes + " bytes");
            }
            SigningServer.Android.IO.ByteBuffer outputCentralDir = SigningServer.Android.IO.ByteBuffer.Allocate((int)outputCentralDirSizeBytes);
            foreach (SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord record in outputCdRecords)
            {
                record.CopyTo(outputCentralDir);
            }
            outputCentralDir.Flip();
            SigningServer.Android.Com.Android.Apksig.Util.DataSource outputCentralDirDataSource = new SigningServer.Android.Com.Android.Apksig.Internal.Util.ByteBufferDataSource(outputCentralDir);
            long outputCentralDirStartOffset = outputOffset;
            int outputCentralDirRecordCount = outputCdRecords.Size();
            SigningServer.Android.IO.ByteBuffer outputEocd = SigningServer.Android.Com.Android.Apksig.Internal.Zip.EocdRecord.CreateWithModifiedCentralDirectoryInfo(inputZipSections.GetZipEndOfCentralDirectory(), outputCentralDirRecordCount, outputCentralDirDataSource.Size(), outputCentralDirStartOffset);
            SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.OutputApkSigningBlockRequest2 outputApkSigningBlockRequest = signerEngine.OutputZipSections2(outputApkIn, outputCentralDirDataSource, SigningServer.Android.Com.Android.Apksig.Util.DataSources.AsDataSource(outputEocd));
            if (outputApkSigningBlockRequest != null)
            {
                int padding = outputApkSigningBlockRequest.GetPaddingSizeBeforeApkSigningBlock();
                outputApkOut.Consume(SigningServer.Android.IO.ByteBuffer.Allocate(padding));
                byte[] outputApkSigningBlock = outputApkSigningBlockRequest.GetApkSigningBlock();
                outputApkOut.Consume(outputApkSigningBlock, 0, outputApkSigningBlock.Length);
                SigningServer.Android.Com.Android.Apksig.Internal.Zip.ZipUtils.SetZipEocdCentralDirectoryOffset(outputEocd, outputCentralDirStartOffset + padding + outputApkSigningBlock.Length);
                outputApkSigningBlockRequest.Done();
            }
            outputCentralDirDataSource.Feed(0, outputCentralDirDataSource.Size(), outputApkOut);
            outputApkOut.Consume(outputEocd);
            signerEngine.OutputDone();
            if (mV4SigningEnabled)
            {
                signerEngine.SignV4(outputApkIn, mOutputV4File, !mV4ErrorReportingEnabled);
            }
        }
        
        internal static void RequestOutputEntryInspection(SigningServer.Android.Com.Android.Apksig.ApkSignerEngine signerEngine, string entryName, byte[] uncompressedData)
        {
            SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.InspectJarEntryRequest inspectEntryRequest = signerEngine.OutputJarEntry(entryName);
            if (inspectEntryRequest != null)
            {
                inspectEntryRequest.GetDataSink().Consume(uncompressedData, 0, uncompressedData.Length);
                inspectEntryRequest.Done();
            }
        }
        
        internal static long OutputDataToOutputApk(string entryName, byte[] uncompressedData, long localFileHeaderOffset, SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord> outputCdRecords, int lastModifiedTimeForNewEntries, int lastModifiedDateForNewEntries, SigningServer.Android.Com.Android.Apksig.Util.DataSink outputApkOut)
        {
            SigningServer.Android.Com.Android.Apksig.Internal.Zip.ZipUtils.DeflateResult deflateResult = SigningServer.Android.Com.Android.Apksig.Internal.Zip.ZipUtils.Deflate(SigningServer.Android.IO.ByteBuffer.Wrap(uncompressedData));
            byte[] compressedData = deflateResult.output;
            long uncompressedDataCrc32 = deflateResult.inputCrc32;
            long numOfDataBytes = SigningServer.Android.Com.Android.Apksig.Internal.Zip.LocalFileRecord.OutputRecordWithDeflateCompressedData(
                entryName
                , 
                lastModifiedTimeForNewEntries
                , 
                lastModifiedDateForNewEntries
                , 
                compressedData
                , 
                uncompressedDataCrc32
                , 
                uncompressedData.Length
                , 
                outputApkOut
            
            );
            outputCdRecords.Add(SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord.CreateWithDeflateCompressedData(
                entryName
                , 
                lastModifiedTimeForNewEntries
                , 
                lastModifiedDateForNewEntries
                , 
                uncompressedDataCrc32
                , 
                compressedData.Length
                , 
                uncompressedData.Length
                , 
                localFileHeaderOffset
            
            ));
            return numOfDataBytes;
        }
        
        internal static void FulfillInspectInputJarEntryRequest(SigningServer.Android.Com.Android.Apksig.Util.DataSource lfhSection, SigningServer.Android.Com.Android.Apksig.Internal.Zip.LocalFileRecord localFileRecord, SigningServer.Android.Com.Android.Apksig.ApkSignerEngine.InspectJarEntryRequest inspectEntryRequest)
        {
            try
            {
                localFileRecord.OutputUncompressedData(lfhSection, inspectEntryRequest.GetDataSink());
            }
            catch (SigningServer.Android.Com.Android.Apksig.Zip.ZipFormatException e)
            {
                throw new SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException("Malformed ZIP entry: " + localFileRecord.GetName(), e);
            }
            inspectEntryRequest.Done();
        }
        
        internal class OutputSizeAndDataOffset
        {
            public long outputBytes;
            
            public long dataOffsetBytes;
            
            public OutputSizeAndDataOffset(long outputBytes, long dataOffsetBytes)
            {
                this.outputBytes = outputBytes;
                this.dataOffsetBytes = dataOffsetBytes;
            }
            
        }
        
        internal static SigningServer.Android.Com.Android.Apksig.ApkSigner.OutputSizeAndDataOffset OutputInputJarEntryLfhRecordPreservingDataAlignment(SigningServer.Android.Com.Android.Apksig.Util.DataSource inputLfhSection, SigningServer.Android.Com.Android.Apksig.Internal.Zip.LocalFileRecord inputRecord, SigningServer.Android.Com.Android.Apksig.Util.DataSink outputLfhSection, long outputOffset)
        {
            long inputOffset = inputRecord.GetStartOffsetInArchive();
            if (inputOffset == outputOffset)
            {
                return new SigningServer.Android.Com.Android.Apksig.ApkSigner.OutputSizeAndDataOffset(inputRecord.OutputRecord(inputLfhSection, outputLfhSection), inputRecord.GetDataStartOffsetInRecord());
            }
            int dataAlignmentMultiple = SigningServer.Android.Com.Android.Apksig.ApkSigner.GetInputJarEntryDataAlignmentMultiple(inputRecord);
            if ((dataAlignmentMultiple <= 1) || ((inputOffset % dataAlignmentMultiple) == (outputOffset % dataAlignmentMultiple)))
            {
                return new SigningServer.Android.Com.Android.Apksig.ApkSigner.OutputSizeAndDataOffset(inputRecord.OutputRecord(inputLfhSection, outputLfhSection), inputRecord.GetDataStartOffsetInRecord());
            }
            long inputDataStartOffset = inputOffset + inputRecord.GetDataStartOffsetInRecord();
            if ((inputDataStartOffset % dataAlignmentMultiple) != 0)
            {
                return new SigningServer.Android.Com.Android.Apksig.ApkSigner.OutputSizeAndDataOffset(inputRecord.OutputRecord(inputLfhSection, outputLfhSection), inputRecord.GetDataStartOffsetInRecord());
            }
            SigningServer.Android.IO.ByteBuffer aligningExtra = SigningServer.Android.Com.Android.Apksig.ApkSigner.CreateExtraFieldToAlignData(inputRecord.GetExtra(), outputOffset + inputRecord.GetExtraFieldStartOffsetInsideRecord(), dataAlignmentMultiple);
            long dataOffset = (long)inputRecord.GetDataStartOffsetInRecord() + aligningExtra.Remaining() - inputRecord.GetExtra().Remaining();
            return new SigningServer.Android.Com.Android.Apksig.ApkSigner.OutputSizeAndDataOffset(inputRecord.OutputRecordWithModifiedExtra(inputLfhSection, aligningExtra, outputLfhSection), dataOffset);
        }
        
        internal static int GetInputJarEntryDataAlignmentMultiple(SigningServer.Android.Com.Android.Apksig.Internal.Zip.LocalFileRecord entry)
        {
            if (entry.IsDataCompressed())
            {
                return 1;
            }
            SigningServer.Android.IO.ByteBuffer extra = entry.GetExtra();
            if (extra.HasRemaining())
            {
                extra.Order(SigningServer.Android.IO.ByteOrder.LITTLE_ENDIAN);
                while (extra.Remaining() >= 4)
                {
                    short headerId = extra.GetShort();
                    int dataSize = SigningServer.Android.Com.Android.Apksig.Internal.Zip.ZipUtils.GetUnsignedInt16(extra);
                    if (dataSize > extra.Remaining())
                    {
                        break;
                    }
                    if (headerId != SigningServer.Android.Com.Android.Apksig.ApkSigner.ALIGNMENT_ZIP_EXTRA_DATA_FIELD_HEADER_ID)
                    {
                        extra.Position(extra.Position() + dataSize);
                        continue;
                    }
                    if (dataSize < 2)
                    {
                        break;
                    }
                    return SigningServer.Android.Com.Android.Apksig.Internal.Zip.ZipUtils.GetUnsignedInt16(extra);
                }
            }
            return (entry.GetName().EndsWith(".so")) ? SigningServer.Android.Com.Android.Apksig.ApkSigner.ANDROID_COMMON_PAGE_ALIGNMENT_BYTES : 4;
        }
        
        internal static SigningServer.Android.IO.ByteBuffer CreateExtraFieldToAlignData(SigningServer.Android.IO.ByteBuffer original, long extraStartOffset, int dataAlignmentMultiple)
        {
            if (dataAlignmentMultiple <= 1)
            {
                return original;
            }
            SigningServer.Android.IO.ByteBuffer result = SigningServer.Android.IO.ByteBuffer.Allocate(original.Remaining() + 5 + dataAlignmentMultiple);
            result.Order(SigningServer.Android.IO.ByteOrder.LITTLE_ENDIAN);
            while (original.Remaining() >= 4)
            {
                short headerId = original.GetShort();
                int dataSize = SigningServer.Android.Com.Android.Apksig.Internal.Zip.ZipUtils.GetUnsignedInt16(original);
                if (dataSize > original.Remaining())
                {
                    break;
                }
                if (((headerId == 0) && (dataSize == 0)) || (headerId == SigningServer.Android.Com.Android.Apksig.ApkSigner.ALIGNMENT_ZIP_EXTRA_DATA_FIELD_HEADER_ID))
                {
                    original.Position(original.Position() + dataSize);
                    continue;
                }
                original.Position(original.Position() - 4);
                int originalLimit = original.Limit();
                original.Limit(original.Position() + 4 + dataSize);
                result.Put(original);
                original.Limit(originalLimit);
            }
            long dataMinStartOffset = extraStartOffset + result.Position() + SigningServer.Android.Com.Android.Apksig.ApkSigner.ALIGNMENT_ZIP_EXTRA_DATA_FIELD_MIN_SIZE_BYTES;
            int paddingSizeBytes = (dataAlignmentMultiple - ((int)(dataMinStartOffset % dataAlignmentMultiple))) % dataAlignmentMultiple;
            result.PutShort(SigningServer.Android.Com.Android.Apksig.ApkSigner.ALIGNMENT_ZIP_EXTRA_DATA_FIELD_HEADER_ID);
            SigningServer.Android.Com.Android.Apksig.Internal.Zip.ZipUtils.PutUnsignedInt16(result, 2 + paddingSizeBytes);
            SigningServer.Android.Com.Android.Apksig.Internal.Zip.ZipUtils.PutUnsignedInt16(result, dataAlignmentMultiple);
            result.Position(result.Position() + paddingSizeBytes);
            result.Flip();
            return result;
        }
        
        internal static SigningServer.Android.IO.ByteBuffer GetZipCentralDirectory(SigningServer.Android.Com.Android.Apksig.Util.DataSource apk, SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.ZipSections apkSections)
        {
            long cdSizeBytes = apkSections.GetZipCentralDirectorySizeBytes();
            if (cdSizeBytes > SigningServer.Android.Core.IntExtensions.MAX_VALUE)
            {
                throw new SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException("ZIP Central Directory too large: " + cdSizeBytes);
            }
            long cdOffset = apkSections.GetZipCentralDirectoryOffset();
            SigningServer.Android.IO.ByteBuffer cd = apk.GetByteBuffer(cdOffset, (int)cdSizeBytes);
            cd.Order(SigningServer.Android.IO.ByteOrder.LITTLE_ENDIAN);
            return cd;
        }
        
        internal static SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord> ParseZipCentralDirectory(SigningServer.Android.IO.ByteBuffer cd, SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.ZipSections apkSections)
        {
            long cdOffset = apkSections.GetZipCentralDirectoryOffset();
            int expectedCdRecordCount = apkSections.GetZipCentralDirectoryRecordCount();
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord> cdRecords = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord>(expectedCdRecordCount);
            SigningServer.Android.Collections.Set<string> entryNames = new SigningServer.Android.Collections.HashSet<string>(expectedCdRecordCount);
            for (int i = 0;i < expectedCdRecordCount;i++)
            {
                SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord cdRecord;
                int offsetInsideCd = cd.Position();
                try
                {
                    cdRecord = SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord.GetRecord(cd);
                }
                catch (SigningServer.Android.Com.Android.Apksig.Zip.ZipFormatException e)
                {
                    throw new SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException("Malformed ZIP Central Directory record #" + (i + 1) + " at file offset " + (cdOffset + offsetInsideCd), e);
                }
                string entryName = cdRecord.GetName();
                if (!entryNames.Add(entryName))
                {
                    throw new SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException("Multiple ZIP entries with the same name: " + entryName);
                }
                cdRecords.Add(cdRecord);
            }
            if (cd.HasRemaining())
            {
                throw new SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException("Unused space at the end of ZIP Central Directory: " + cd.Remaining() + " bytes starting at file offset " + (cdOffset + cd.Position()));
            }
            return cdRecords;
        }
        
        internal static SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord FindCdRecord(SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord> cdRecords, string name)
        {
            foreach (SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord cdRecord in cdRecords)
            {
                if (name.Equals(cdRecord.GetName()))
                {
                    return cdRecord;
                }
            }
            return null;
        }
        
        /// <summary>
        /// Returns the contents of the APK's {@code AndroidManifest.xml} or {@code null} if this entry
        /// is not present in the APK.
        /// </summary>
        public static SigningServer.Android.IO.ByteBuffer GetAndroidManifestFromApk(SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord> cdRecords, SigningServer.Android.Com.Android.Apksig.Util.DataSource lhfSection)
        {
            SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord androidManifestCdRecord = SigningServer.Android.Com.Android.Apksig.ApkSigner.FindCdRecord(cdRecords, SigningServer.Android.Com.Android.Apksig.ApkSigner.ANDROID_MANIFEST_ZIP_ENTRY_NAME);
            if (androidManifestCdRecord == null)
            {
                throw new SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException("Missing " + SigningServer.Android.Com.Android.Apksig.ApkSigner.ANDROID_MANIFEST_ZIP_ENTRY_NAME);
            }
            return SigningServer.Android.IO.ByteBuffer.Wrap(SigningServer.Android.Com.Android.Apksig.Internal.Zip.LocalFileRecord.GetUncompressedData(lhfSection, androidManifestCdRecord, lhfSection.Size()));
        }
        
        /// <summary>
        /// Return list of pin patterns embedded in the pin pattern asset file. If no such file, return
        /// {@code null}.
        /// </summary>
        internal static SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Hints.PatternWithRange> ExtractPinPatterns(SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord> cdRecords, SigningServer.Android.Com.Android.Apksig.Util.DataSource lhfSection)
        {
            SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord pinListCdRecord = SigningServer.Android.Com.Android.Apksig.ApkSigner.FindCdRecord(cdRecords, SigningServer.Android.Com.Android.Apksig.Hints.PIN_HINT_ASSET_ZIP_ENTRY_NAME);
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Hints.PatternWithRange> pinPatterns = null;
            if (pinListCdRecord != null)
            {
                pinPatterns = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Hints.PatternWithRange>();
                byte[] patternBlob;
                try
                {
                    patternBlob = SigningServer.Android.Com.Android.Apksig.Internal.Zip.LocalFileRecord.GetUncompressedData(lhfSection, pinListCdRecord, lhfSection.Size());
                }
                catch (SigningServer.Android.Com.Android.Apksig.Zip.ZipFormatException ex)
                {
                    throw new SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException("Bad " + pinListCdRecord);
                }
                pinPatterns = SigningServer.Android.Com.Android.Apksig.Hints.ParsePinPatterns(patternBlob);
            }
            return pinPatterns;
        }
        
        /// <summary>
        /// Returns the minimum Android version (API Level) supported by the provided APK. This is based
        /// on the {@code android:minSdkVersion} attributes of the APK's {@code AndroidManifest.xml}.
        /// </summary>
        internal static int GetMinSdkVersionFromApk(SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord> cdRecords, SigningServer.Android.Com.Android.Apksig.Util.DataSource lhfSection)
        {
            SigningServer.Android.IO.ByteBuffer androidManifest;
            try
            {
                androidManifest = SigningServer.Android.Com.Android.Apksig.ApkSigner.GetAndroidManifestFromApk(cdRecords, lhfSection);
            }
            catch (System.Exception e) when ( e is SigningServer.Android.Com.Android.Apksig.Zip.ZipFormatException || e is SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException)
            {
                throw new SigningServer.Android.Com.Android.Apksig.Apk.MinSdkVersionException("Failed to determine APK's minimum supported Android platform version", e);
            }
            return SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.GetMinSdkVersionFromBinaryAndroidManifest(androidManifest);
        }
        
        /// <summary>
        /// Configuration of a signer.
        /// 
        /// &lt;p&gt;Use {@link Builder} to obtain configuration instances.
        /// </summary>
        public class SignerConfig
        {
            internal readonly string mName;
            
            internal readonly SigningServer.Android.Security.PrivateKey mPrivateKey;
            
            internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> mCertificates;
            
            internal bool mDeterministicDsaSigning;
            
            internal SignerConfig(string name, SigningServer.Android.Security.PrivateKey privateKey, SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> certificates, bool deterministicDsaSigning)
            {
                mName = name;
                mPrivateKey = privateKey;
                mCertificates = SigningServer.Android.Util.Collections.UnmodifiableList(new SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate>(certificates));
                mDeterministicDsaSigning = deterministicDsaSigning;
            }
            
            /// <summary>
            /// Returns the name of this signer.
            /// </summary>
            public virtual string GetName()
            {
                return mName;
            }
            
            /// <summary>
            /// Returns the signing key of this signer.
            /// </summary>
            public virtual SigningServer.Android.Security.PrivateKey GetPrivateKey()
            {
                return mPrivateKey;
            }
            
            /// <summary>
            /// Returns the certificate(s) of this signer. The first certificate's public key corresponds
            /// to this signer's private key.
            /// </summary>
            public virtual SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> GetCertificates()
            {
                return mCertificates;
            }
            
            /// <summary>
            /// If this signer is a DSA signer, whether or not the signing is done deterministically.
            /// </summary>
            public virtual bool GetDeterministicDsaSigning()
            {
                return mDeterministicDsaSigning;
            }
            
            /// <summary>
            /// Builder of {@link SignerConfig} instances.
            /// </summary>
            public class Builder
            {
                internal readonly string mName;
                
                internal readonly SigningServer.Android.Security.PrivateKey mPrivateKey;
                
                internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> mCertificates;
                
                internal readonly bool mDeterministicDsaSigning;
                
                /// <summary>
                /// Constructs a new {@code Builder}.
                /// 
                /// @param name signer's name. The name is reflected in the name of files comprising the
                ///     JAR signature of the APK.
                /// @param privateKey signing key
                /// @param certificates list of one or more X.509 certificates. The subject public key of
                ///     the first certificate must correspond to the {@code privateKey}.
                /// </summary>
                public Builder(string name, SigningServer.Android.Security.PrivateKey privateKey, SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> certificates)
                    : this (name, privateKey, certificates, false)
                {
                    ;
                }
                
                /// <summary>
                /// Constructs a new {@code Builder}.
                /// 
                /// @param name signer's name. The name is reflected in the name of files comprising the
                ///     JAR signature of the APK.
                /// @param privateKey signing key
                /// @param certificates list of one or more X.509 certificates. The subject public key of
                ///     the first certificate must correspond to the {@code privateKey}.
                /// @param deterministicDsaSigning When signing using DSA, whether or not the
                ///     deterministic variant (RFC6979) should be used.
                /// </summary>
                public Builder(string name, SigningServer.Android.Security.PrivateKey privateKey, SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> certificates, bool deterministicDsaSigning)
                {
                    if (name.IsEmpty())
                    {
                        throw new System.ArgumentException("Empty name");
                    }
                    mName = name;
                    mPrivateKey = privateKey;
                    mCertificates = new SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate>(certificates);
                    mDeterministicDsaSigning = deterministicDsaSigning;
                }
                
                /// <summary>
                /// Returns a new {@code SignerConfig} instance configured based on the configuration of
                /// this builder.
                /// </summary>
                public virtual SigningServer.Android.Com.Android.Apksig.ApkSigner.SignerConfig Build()
                {
                    return new SigningServer.Android.Com.Android.Apksig.ApkSigner.SignerConfig(mName, mPrivateKey, mCertificates, mDeterministicDsaSigning);
                }
                
            }
            
        }
        
        /// <summary>
        /// Builder of {@link ApkSigner} instances.
        /// 
        /// &lt;p&gt;The builder requires the following information to construct a working {@code ApkSigner}:
        /// 
        /// &lt;ul&gt;
        ///   &lt;li&gt;Signer configs or {@link ApkSignerEngine} -- provided in the constructor,
        ///   &lt;li&gt;APK to be signed -- see {@link #setInputApk(File) setInputApk} variants,
        ///   &lt;li&gt;where to store the output signed APK -- see {@link #setOutputApk(File) setOutputApk}
        ///       variants.
        /// &lt;/ul&gt;
        /// </summary>
        public class Builder
        {
            internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkSigner.SignerConfig> mSignerConfigs;
            
            internal SigningServer.Android.Com.Android.Apksig.ApkSigner.SignerConfig mSourceStampSignerConfig;
            
            internal SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage mSourceStampSigningCertificateLineage;
            
            internal bool mForceSourceStampOverwrite = false;
            
            internal bool mV1SigningEnabled = true;
            
            internal bool mV2SigningEnabled = true;
            
            internal bool mV3SigningEnabled = true;
            
            internal bool mV4SigningEnabled = true;
            
            internal bool mVerityEnabled = false;
            
            internal bool mV4ErrorReportingEnabled = false;
            
            internal bool mDebuggableApkPermitted = true;
            
            internal bool mOtherSignersSignaturesPreserved;
            
            internal string mCreatedBy;
            
            internal int? mMinSdkVersion;
            
            internal readonly SigningServer.Android.Com.Android.Apksig.ApkSignerEngine mSignerEngine;
            
            internal System.IO.FileInfo mInputApkFile;
            
            internal SigningServer.Android.Com.Android.Apksig.Util.DataSource mInputApkDataSource;
            
            internal System.IO.FileInfo mOutputApkFile;
            
            internal SigningServer.Android.Com.Android.Apksig.Util.DataSink mOutputApkDataSink;
            
            internal SigningServer.Android.Com.Android.Apksig.Util.DataSource mOutputApkDataSource;
            
            internal System.IO.FileInfo mOutputV4File;
            
            internal SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage mSigningCertificateLineage;
            
            internal bool mV3SigningExplicitlyDisabled = false;
            
            internal bool mV3SigningExplicitlyEnabled = false;
            
            /// <summary>
            /// Constructs a new {@code Builder} for an {@code ApkSigner} which signs using the provided
            /// signer configurations. The resulting signer may be further customized through this
            /// builder's setters, such as {@link #setMinSdkVersion(int)}, {@link
            /// #setV1SigningEnabled(boolean)}, {@link #setV2SigningEnabled(boolean)}, {@link
            /// #setOtherSignersSignaturesPreserved(boolean)}, {@link #setCreatedBy(String)}.
            /// 
            /// &lt;p&gt;{@link #Builder(ApkSignerEngine)} is an alternative for advanced use cases where more
            /// control over low-level details of signing is desired.
            /// </summary>
            public Builder(SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkSigner.SignerConfig> signerConfigs)
            {
                if (signerConfigs.IsEmpty())
                {
                    throw new System.ArgumentException("At least one signer config must be provided");
                }
                if (signerConfigs.Size() > 1)
                {
                    mV3SigningEnabled = false;
                }
                mSignerConfigs = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkSigner.SignerConfig>(signerConfigs);
                mSignerEngine = null;
            }
            
            /// <summary>
            /// Constructs a new {@code Builder} for an {@code ApkSigner} which signs using the provided
            /// signing engine. This is meant for advanced use cases where more control is needed over
            /// the lower-level details of signing. For typical use cases, {@link #Builder(List)} is more
            /// appropriate.
            /// </summary>
            public Builder(SigningServer.Android.Com.Android.Apksig.ApkSignerEngine signerEngine)
            {
                if (signerEngine == null)
                {
                    throw new System.NullReferenceException("signerEngine == null");
                }
                mSignerEngine = signerEngine;
                mSignerConfigs = null;
            }
            
            /// <summary>
            /// Sets the signing configuration of the source stamp to be embedded in the APK.
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.ApkSigner.Builder SetSourceStampSignerConfig(SigningServer.Android.Com.Android.Apksig.ApkSigner.SignerConfig sourceStampSignerConfig)
            {
                mSourceStampSignerConfig = sourceStampSignerConfig;
                return this;
            }
            
            /// <summary>
            /// Sets the source stamp {@link SigningCertificateLineage}. This structure provides proof of
            /// signing certificate rotation for certificates previously used to sign source stamps.
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.ApkSigner.Builder SetSourceStampSigningCertificateLineage(SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage sourceStampSigningCertificateLineage)
            {
                mSourceStampSigningCertificateLineage = sourceStampSigningCertificateLineage;
                return this;
            }
            
            /// <summary>
            /// Sets whether the APK should overwrite existing source stamp, if found.
            /// 
            /// @param force {@code true} to require the APK to be overwrite existing source stamp
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.ApkSigner.Builder SetForceSourceStampOverwrite(bool force)
            {
                mForceSourceStampOverwrite = force;
                return this;
            }
            
            /// <summary>
            /// Sets the APK to be signed.
            /// 
            /// @see #setInputApk(DataSource)
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.ApkSigner.Builder SetInputApk(System.IO.FileInfo inputApk)
            {
                if (inputApk == null)
                {
                    throw new System.NullReferenceException("inputApk == null");
                }
                mInputApkFile = inputApk;
                mInputApkDataSource = null;
                return this;
            }
            
            /// <summary>
            /// Sets the APK to be signed.
            /// 
            /// @see #setInputApk(File)
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.ApkSigner.Builder SetInputApk(SigningServer.Android.Com.Android.Apksig.Util.DataSource inputApk)
            {
                if (inputApk == null)
                {
                    throw new System.NullReferenceException("inputApk == null");
                }
                mInputApkDataSource = inputApk;
                mInputApkFile = null;
                return this;
            }
            
            /// <summary>
            /// Sets the location of the output (signed) APK. {@code ApkSigner} will create this file if
            /// it doesn't exist.
            /// 
            /// @see #setOutputApk(ReadableDataSink)
            /// @see #setOutputApk(DataSink, DataSource)
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.ApkSigner.Builder SetOutputApk(System.IO.FileInfo outputApk)
            {
                if (outputApk == null)
                {
                    throw new System.NullReferenceException("outputApk == null");
                }
                mOutputApkFile = outputApk;
                mOutputApkDataSink = null;
                mOutputApkDataSource = null;
                return this;
            }
            
            /// <summary>
            /// Sets the readable data sink which will receive the output (signed) APK. After signing,
            /// the contents of the output APK will be available via the {@link DataSource} interface of
            /// the sink.
            /// 
            /// &lt;p&gt;This variant of {@code setOutputApk} is useful for avoiding writing the output APK to
            /// a file. For example, an in-memory data sink, such as {@link
            /// DataSinks#newInMemoryDataSink()}, could be used instead of a file.
            /// 
            /// @see #setOutputApk(File)
            /// @see #setOutputApk(DataSink, DataSource)
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.ApkSigner.Builder SetOutputApk(SigningServer.Android.Com.Android.Apksig.Util.ReadableDataSink outputApk)
            {
                if (outputApk == null)
                {
                    throw new System.NullReferenceException("outputApk == null");
                }
                return SetOutputApk(outputApk, outputApk);
            }
            
            /// <summary>
            /// Sets the sink which will receive the output (signed) APK. Data received by the {@code
            /// outputApkOut} sink must be visible through the {@code outputApkIn} data source.
            /// 
            /// &lt;p&gt;This is an advanced variant of {@link #setOutputApk(ReadableDataSink)}, enabling the
            /// sink and the source to be different objects.
            /// 
            /// @see #setOutputApk(ReadableDataSink)
            /// @see #setOutputApk(File)
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.ApkSigner.Builder SetOutputApk(SigningServer.Android.Com.Android.Apksig.Util.DataSink outputApkOut, SigningServer.Android.Com.Android.Apksig.Util.DataSource outputApkIn)
            {
                if (outputApkOut == null)
                {
                    throw new System.NullReferenceException("outputApkOut == null");
                }
                if (outputApkIn == null)
                {
                    throw new System.NullReferenceException("outputApkIn == null");
                }
                mOutputApkFile = null;
                mOutputApkDataSink = outputApkOut;
                mOutputApkDataSource = outputApkIn;
                return this;
            }
            
            /// <summary>
            /// Sets the location of the V4 output file. {@code ApkSigner} will create this file if it
            /// doesn't exist.
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.ApkSigner.Builder SetV4SignatureOutputFile(System.IO.FileInfo v4SignatureOutputFile)
            {
                if (v4SignatureOutputFile == null)
                {
                    throw new System.NullReferenceException("v4HashRootOutputFile == null");
                }
                mOutputV4File = v4SignatureOutputFile;
                return this;
            }
            
            /// <summary>
            /// Sets the minimum Android platform version (API Level) on which APK signatures produced by
            /// the signer being built must verify. This method is useful for overriding the default
            /// behavior where the minimum API Level is obtained from the {@code android:minSdkVersion}
            /// attribute of the APK's {@code AndroidManifest.xml}.
            /// 
            /// &lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; This method may result in APK signatures which don't verify on some
            /// Android platform versions supported by the APK.
            /// 
            /// &lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; This method may only be invoked when this builder is not initialized
            /// with an {@link ApkSignerEngine}.
            /// 
            /// @throws IllegalStateException if this builder was initialized with an {@link
            ///     ApkSignerEngine}
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.ApkSigner.Builder SetMinSdkVersion(int minSdkVersion)
            {
                CheckInitializedWithoutEngine();
                mMinSdkVersion = minSdkVersion;
                return this;
            }
            
            /// <summary>
            /// Sets whether the APK should be signed using JAR signing (aka v1 signature scheme).
            /// 
            /// &lt;p&gt;By default, whether APK is signed using JAR signing is determined by {@code
            /// ApkSigner}, based on the platform versions supported by the APK or specified using {@link
            /// #setMinSdkVersion(int)}. Disabling JAR signing will result in APK signatures which don't
            /// verify on Android Marshmallow (Android 6.0, API Level 23) and lower.
            /// 
            /// &lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; This method may only be invoked when this builder is not initialized
            /// with an {@link ApkSignerEngine}.
            /// 
            /// @param enabled {@code true} to require the APK to be signed using JAR signing, {@code
            ///     false} to require the APK to not be signed using JAR signing.
            /// @throws IllegalStateException if this builder was initialized with an {@link
            ///     ApkSignerEngine}
            /// @see &lt;a
            ///     href="https://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html#Signed_JAR_File"&gt;JAR
            ///     signing&lt;/a&gt;
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.ApkSigner.Builder SetV1SigningEnabled(bool enabled)
            {
                CheckInitializedWithoutEngine();
                mV1SigningEnabled = enabled;
                return this;
            }
            
            /// <summary>
            /// Sets whether the APK should be signed using APK Signature Scheme v2 (aka v2 signature
            /// scheme).
            /// 
            /// &lt;p&gt;By default, whether APK is signed using APK Signature Scheme v2 is determined by
            /// {@code ApkSigner} based on the platform versions supported by the APK or specified using
            /// {@link #setMinSdkVersion(int)}.
            /// 
            /// &lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; This method may only be invoked when this builder is not initialized
            /// with an {@link ApkSignerEngine}.
            /// 
            /// @param enabled {@code true} to require the APK to be signed using APK Signature Scheme
            ///     v2, {@code false} to require the APK to not be signed using APK Signature Scheme v2.
            /// @throws IllegalStateException if this builder was initialized with an {@link
            ///     ApkSignerEngine}
            /// @see &lt;a href="https://source.android.com/security/apksigning/v2.html"&gt;APK Signature
            ///     Scheme v2&lt;/a&gt;
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.ApkSigner.Builder SetV2SigningEnabled(bool enabled)
            {
                CheckInitializedWithoutEngine();
                mV2SigningEnabled = enabled;
                return this;
            }
            
            /// <summary>
            /// Sets whether the APK should be signed using APK Signature Scheme v3 (aka v3 signature
            /// scheme).
            /// 
            /// &lt;p&gt;By default, whether APK is signed using APK Signature Scheme v3 is determined by
            /// {@code ApkSigner} based on the platform versions supported by the APK or specified using
            /// {@link #setMinSdkVersion(int)}.
            /// 
            /// &lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; This method may only be invoked when this builder is not initialized
            /// with an {@link ApkSignerEngine}.
            /// 
            /// &lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; APK Signature Scheme v3 only supports a single signing certificate, but
            /// may take multiple signers mapping to different targeted platform versions.
            /// 
            /// @param enabled {@code true} to require the APK to be signed using APK Signature Scheme
            ///     v3, {@code false} to require the APK to not be signed using APK Signature Scheme v3.
            /// @throws IllegalStateException if this builder was initialized with an {@link
            ///     ApkSignerEngine}
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.ApkSigner.Builder SetV3SigningEnabled(bool enabled)
            {
                CheckInitializedWithoutEngine();
                mV3SigningEnabled = enabled;
                if (enabled)
                {
                    mV3SigningExplicitlyEnabled = true;
                }
                else 
                {
                    mV3SigningExplicitlyDisabled = true;
                }
                return this;
            }
            
            /// <summary>
            /// Sets whether the APK should be signed using APK Signature Scheme v4.
            /// 
            /// &lt;p&gt;V4 signing requires that the APK be v2 or v3 signed.
            /// 
            /// @param enabled {@code true} to require the APK to be signed using APK Signature Scheme v2
            ///     or v3 and generate an v4 signature file
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.ApkSigner.Builder SetV4SigningEnabled(bool enabled)
            {
                CheckInitializedWithoutEngine();
                mV4SigningEnabled = enabled;
                mV4ErrorReportingEnabled = enabled;
                return this;
            }
            
            /// <summary>
            /// Sets whether errors during v4 signing should be reported and halt the signing process.
            /// 
            /// &lt;p&gt;Error reporting for v4 signing is disabled by default, but will be enabled if the
            /// caller invokes {@link #setV4SigningEnabled} with a value of true. This method is useful
            /// for tools that enable v4 signing by default but don't want to fail the signing process if
            /// the user did not explicitly request the v4 signing.
            /// 
            /// @param enabled {@code false} to prevent errors encountered during the V4 signing from
            ///     halting the signing process
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.ApkSigner.Builder SetV4ErrorReportingEnabled(bool enabled)
            {
                CheckInitializedWithoutEngine();
                mV4ErrorReportingEnabled = enabled;
                return this;
            }
            
            /// <summary>
            /// Sets whether to enable the verity signature algorithm for the v2 and v3 signature
            /// schemes.
            /// 
            /// @param enabled {@code true} to enable the verity signature algorithm for inclusion in the
            ///     v2 and v3 signature blocks.
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.ApkSigner.Builder SetVerityEnabled(bool enabled)
            {
                CheckInitializedWithoutEngine();
                mVerityEnabled = enabled;
                return this;
            }
            
            /// <summary>
            /// Sets whether the APK should be signed even if it is marked as debuggable ({@code
            /// android:debuggable="true"} in its {@code AndroidManifest.xml}). For backward
            /// compatibility reasons, the default value of this setting is {@code true}.
            /// 
            /// &lt;p&gt;It is dangerous to sign debuggable APKs with production/release keys because Android
            /// platform loosens security checks for such APKs. For example, arbitrary unauthorized code
            /// may be executed in the context of such an app by anybody with ADB shell access.
            /// 
            /// &lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; This method may only be invoked when this builder is not initialized
            /// with an {@link ApkSignerEngine}.
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.ApkSigner.Builder SetDebuggableApkPermitted(bool permitted)
            {
                CheckInitializedWithoutEngine();
                mDebuggableApkPermitted = permitted;
                return this;
            }
            
            /// <summary>
            /// Sets whether signatures produced by signers other than the ones configured in this engine
            /// should be copied from the input APK to the output APK.
            /// 
            /// &lt;p&gt;By default, signatures of other signers are omitted from the output APK.
            /// 
            /// &lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; This method may only be invoked when this builder is not initialized
            /// with an {@link ApkSignerEngine}.
            /// 
            /// @throws IllegalStateException if this builder was initialized with an {@link
            ///     ApkSignerEngine}
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.ApkSigner.Builder SetOtherSignersSignaturesPreserved(bool preserved)
            {
                CheckInitializedWithoutEngine();
                mOtherSignersSignaturesPreserved = preserved;
                return this;
            }
            
            /// <summary>
            /// Sets the value of the {@code Created-By} field in JAR signature files.
            /// 
            /// &lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; This method may only be invoked when this builder is not initialized
            /// with an {@link ApkSignerEngine}.
            /// 
            /// @throws IllegalStateException if this builder was initialized with an {@link
            ///     ApkSignerEngine}
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.ApkSigner.Builder SetCreatedBy(string createdBy)
            {
                CheckInitializedWithoutEngine();
                if (createdBy == null)
                {
                    throw new System.NullReferenceException();
                }
                mCreatedBy = createdBy;
                return this;
            }
            
            internal void CheckInitializedWithoutEngine()
            {
                if (mSignerEngine != null)
                {
                    throw new System.InvalidOperationException("Operation is not available when builder initialized with an engine");
                }
            }
            
            /// <summary>
            /// Sets the {@link SigningCertificateLineage} to use with the v3 signature scheme. This
            /// structure provides proof of signing certificate rotation linking {@link SignerConfig}
            /// objects to previous ones.
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.ApkSigner.Builder SetSigningCertificateLineage(SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage signingCertificateLineage)
            {
                if (signingCertificateLineage != null)
                {
                    mV3SigningEnabled = true;
                    mSigningCertificateLineage = signingCertificateLineage;
                }
                return this;
            }
            
            /// <summary>
            /// Returns a new {@code ApkSigner} instance initialized according to the configuration of
            /// this builder.
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.ApkSigner Build()
            {
                if (mV3SigningExplicitlyDisabled && mV3SigningExplicitlyEnabled)
                {
                    throw new System.InvalidOperationException("Builder configured to both enable and disable APK " + "Signature Scheme v3 signing");
                }
                if (mV3SigningExplicitlyDisabled)
                {
                    mV3SigningEnabled = false;
                }
                if (mV3SigningExplicitlyEnabled)
                {
                    mV3SigningEnabled = true;
                }
                if (mV4SigningEnabled && !mV2SigningEnabled && !mV3SigningEnabled)
                {
                    if (!mV4ErrorReportingEnabled)
                    {
                        mV4SigningEnabled = false;
                    }
                    else 
                    {
                        throw new System.InvalidOperationException("APK Signature Scheme v4 signing requires at least " + "v2 or v3 signing to be enabled");
                    }
                }
                return new SigningServer.Android.Com.Android.Apksig.ApkSigner(mSignerConfigs, mSourceStampSignerConfig, mSourceStampSigningCertificateLineage, mForceSourceStampOverwrite, mMinSdkVersion, mV1SigningEnabled, mV2SigningEnabled, mV3SigningEnabled, mV4SigningEnabled, mVerityEnabled, mV4ErrorReportingEnabled, mDebuggableApkPermitted, mOtherSignersSignaturesPreserved, mCreatedBy, mSignerEngine, mInputApkFile, mInputApkDataSource, mOutputApkFile, mOutputApkDataSink, mOutputApkDataSource, mOutputV4File, mSigningCertificateLineage);
            }
            
        }
        
    }
    
}
