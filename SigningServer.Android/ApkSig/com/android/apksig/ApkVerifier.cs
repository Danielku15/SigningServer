// <auto-generated>
// This code was auto-generated.
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
// </auto-generated>

using System;
using SigningServer.Android.Security.Cert;

namespace SigningServer.Android.Com.Android.Apksig
{
    /// <summary>
    /// APK signature verifier which mimics the behavior of the Android platform.
    /// 
    /// &lt;p&gt;The verifier is designed to closely mimic the behavior of Android platforms. This is to enable
    /// the verifier to be used for checking whether an APK's signatures are expected to verify on
    /// Android.
    /// 
    /// &lt;p&gt;Use {@link Builder} to obtain instances of this verifier.
    /// 
    /// @see &lt;a href="https://source.android.com/security/apksigning/index.html"&gt;Application Signing&lt;/a&gt;
    /// </summary>
    public class ApkVerifier
    {
        internal static readonly SigningServer.Android.Collections.Map<int, string> SUPPORTED_APK_SIG_SCHEME_NAMES = SigningServer.Android.Com.Android.Apksig.ApkVerifier.LoadSupportedApkSigSchemeNames();
        
        internal static SigningServer.Android.Collections.Map<int, string> LoadSupportedApkSigSchemeNames()
        {
            SigningServer.Android.Collections.Map<int, string> supportedMap = new SigningServer.Android.Collections.HashMap<int, string>(2);
            supportedMap.Put(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V2, "APK Signature Scheme v2");
            supportedMap.Put(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V3, "APK Signature Scheme v3");
            return supportedMap;
        }
        
        internal readonly System.IO.FileInfo mApkFile;
        
        internal readonly SigningServer.Android.Com.Android.Apksig.Util.DataSource mApkDataSource;
        
        internal readonly System.IO.FileInfo mV4SignatureFile;
        
        internal readonly int? mMinSdkVersion;
        
        internal readonly int mMaxSdkVersion;
        
        internal ApkVerifier(System.IO.FileInfo apkFile, SigningServer.Android.Com.Android.Apksig.Util.DataSource apkDataSource, System.IO.FileInfo v4SignatureFile, int? minSdkVersion, int maxSdkVersion)
        {
            mApkFile = apkFile;
            mApkDataSource = apkDataSource;
            mV4SignatureFile = v4SignatureFile;
            mMinSdkVersion = minSdkVersion;
            mMaxSdkVersion = maxSdkVersion;
        }
        
        /// <summary>
        /// Verifies the APK's signatures and returns the result of verification. The APK can be
        /// considered verified iff the result's {@link Result#isVerified()} returns {@code true}.
        /// The verification result also includes errors, warnings, and information about signers such
        /// as their signing certificates.
        /// 
        /// &lt;p&gt;Verification succeeds iff the APK's signature is expected to verify on all Android
        /// platform versions specified via the {@link Builder}. If the APK's signature is expected to
        /// not verify on any of the specified platform versions, this method returns a result with one
        /// or more errors and whose {@link Result#isVerified()} returns {@code false}, or this method
        /// throws an exception.
        /// 
        /// @throws IOException if an I/O error is encountered while reading the APK
        /// @throws ApkFormatException if the APK is malformed
        /// @throws NoSuchAlgorithmException if the APK's signatures cannot be verified because a
        ///                                  required cryptographic algorithm implementation is missing
        /// @throws IllegalStateException if this verifier's configuration is missing required
        ///                                  information.
        /// </summary>
        public virtual SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result Verify()
        {
            System.IDisposable input = null;
            try
            {
                SigningServer.Android.Com.Android.Apksig.Util.DataSource apk;
                if (mApkDataSource != null)
                {
                    apk = mApkDataSource;
                }
                else if (mApkFile != null)
                {
                    SigningServer.Android.IO.RandomAccessFile f = new SigningServer.Android.IO.RandomAccessFile(mApkFile, "r");
                    input = f;
                    apk = SigningServer.Android.Com.Android.Apksig.Util.DataSources.AsDataSource(f, 0, f.Length());
                }
                else 
                {
                    throw new System.InvalidOperationException("APK not provided");
                }
                return Verify(apk);
            }
            finally
            {
                if (input != null)
                {
                    input.Dispose();
                }
            }
        }
        
        /// <summary>
        /// Verifies the APK's signatures and returns the result of verification. The APK can be
        /// considered verified iff the result's {@link Result#isVerified()} returns {@code true}.
        /// The verification result also includes errors, warnings, and information about signers.
        /// 
        /// @param apk APK file contents
        /// @throws IOException if an I/O error is encountered while reading the APK
        /// @throws ApkFormatException if the APK is malformed
        /// @throws NoSuchAlgorithmException if the APK's signatures cannot be verified because a
        ///                                  required cryptographic algorithm implementation is missing
        /// </summary>
        internal SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result Verify(SigningServer.Android.Com.Android.Apksig.Util.DataSource apk)
        {
            int maxSdkVersion = mMaxSdkVersion;
            SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.ZipSections zipSections;
            try
            {
                zipSections = SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.FindZipSections(apk);
            }
            catch (SigningServer.Android.Com.Android.Apksig.Zip.ZipFormatException e)
            {
                throw new SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException("Malformed APK: not a ZIP archive", e);
            }
            SigningServer.Android.IO.ByteBuffer androidManifest = null;
            int minSdkVersion = VerifyAndGetMinSdkVersion(apk, zipSections);
            SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result result = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result();
            SigningServer.Android.Collections.Map<int, SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]>> signatureSchemeApkContentDigests = new SigningServer.Android.Collections.HashMap<int, SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]>>();
            SigningServer.Android.Collections.Map<int, string> supportedSchemeNames = SigningServer.Android.Com.Android.Apksig.ApkVerifier.GetSupportedSchemeNames(maxSdkVersion);
            SigningServer.Android.Collections.Set<int> foundApkSigSchemeIds = new SigningServer.Android.Collections.HashSet<int>(2);
            if (maxSdkVersion >= SigningServer.Android.Com.Android.Apksig.Internal.Util.AndroidSdkVersion.N)
            {
                SigningServer.Android.Com.Android.Apksig.Util.RunnablesExecutor executor = SigningServer.Android.Com.Android.Apksig.Util.RunnablesExecutors.SINGLE_THREADED;
                if (maxSdkVersion >= SigningServer.Android.Com.Android.Apksig.Internal.Util.AndroidSdkVersion.P)
                {
                    try
                    {
                        SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result v3Result = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SchemeVerifier.Verify(executor, apk, zipSections, SigningServer.Android.Core.Math.Max(minSdkVersion, SigningServer.Android.Com.Android.Apksig.Internal.Util.AndroidSdkVersion.P), maxSdkVersion);
                        foundApkSigSchemeIds.Add(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V3);
                        result.MergeFrom(v3Result);
                        signatureSchemeApkContentDigests.Put(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V3, SigningServer.Android.Com.Android.Apksig.ApkVerifier.GetApkContentDigestsFromSigningSchemeResult(v3Result));
                    }
                    catch (SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignatureNotFoundException ignored)
                    {
                    }
                    if (result.ContainsErrors())
                    {
                        return result;
                    }
                }
                if (minSdkVersion < SigningServer.Android.Com.Android.Apksig.Internal.Util.AndroidSdkVersion.P || foundApkSigSchemeIds.IsEmpty())
                {
                    try
                    {
                        SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result v2Result = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V2.V2SchemeVerifier.Verify(
                            executor
                            , 
                            apk
                            , 
                            zipSections
                            , 
                            supportedSchemeNames
                            , 
                            foundApkSigSchemeIds
                            , 
                            SigningServer.Android.Core.Math.Max(minSdkVersion, SigningServer.Android.Com.Android.Apksig.Internal.Util.AndroidSdkVersion.N)
                            , 
                            maxSdkVersion
                        
                        );
                        foundApkSigSchemeIds.Add(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V2);
                        result.MergeFrom(v2Result);
                        signatureSchemeApkContentDigests.Put(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V2, SigningServer.Android.Com.Android.Apksig.ApkVerifier.GetApkContentDigestsFromSigningSchemeResult(v2Result));
                    }
                    catch (SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignatureNotFoundException ignored)
                    {
                    }
                    if (result.ContainsErrors())
                    {
                        return result;
                    }
                }
                if (mV4SignatureFile != null)
                {
                    SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result v4Result = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V4.V4SchemeVerifier.Verify(apk, mV4SignatureFile);
                    foundApkSigSchemeIds.Add(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V4);
                    result.MergeFrom(v4Result);
                    if (result.ContainsErrors())
                    {
                        return result;
                    }
                }
            }
            if (maxSdkVersion >= SigningServer.Android.Com.Android.Apksig.Internal.Util.AndroidSdkVersion.O)
            {
                if (androidManifest == null)
                {
                    androidManifest = SigningServer.Android.Com.Android.Apksig.ApkVerifier.GetAndroidManifestFromApk(apk, zipSections);
                }
                int targetSandboxVersion = SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.GetTargetSandboxVersionFromBinaryAndroidManifest(androidManifest.Slice());
                if (targetSandboxVersion > 1)
                {
                    if (foundApkSigSchemeIds.IsEmpty())
                    {
                        result.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.NO_SIG_FOR_TARGET_SANDBOX_VERSION, targetSandboxVersion);
                    }
                }
            }
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord> cdRecords = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.ParseZipCentralDirectory(apk, zipSections);
            if ((minSdkVersion < SigningServer.Android.Com.Android.Apksig.Internal.Util.AndroidSdkVersion.N) || (foundApkSigSchemeIds.IsEmpty()))
            {
                SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Result v1Result = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Verify(
                    apk
                    , 
                    zipSections
                    , 
                    supportedSchemeNames
                    , 
                    foundApkSigSchemeIds
                    , 
                    minSdkVersion
                    , 
                    maxSdkVersion
                
                );
                result.MergeFrom(v1Result);
                signatureSchemeApkContentDigests.Put(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_JAR_SIGNATURE_SCHEME, SigningServer.Android.Com.Android.Apksig.ApkVerifier.GetApkContentDigestFromV1SigningScheme(cdRecords, apk, zipSections));
            }
            if (result.ContainsErrors())
            {
                return result;
            }
            try
            {
                SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord sourceStampCdRecord = null;
                foreach (SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord cdRecord in cdRecords)
                {
                    if (SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.SOURCE_STAMP_CERTIFICATE_HASH_ZIP_ENTRY_NAME.Equals(cdRecord.GetName()))
                    {
                        sourceStampCdRecord = cdRecord;
                        break;
                    }
                }
                if (sourceStampCdRecord != null)
                {
                    sbyte[] sourceStampCertificateDigest = SigningServer.Android.Com.Android.Apksig.Internal.Zip.LocalFileRecord.GetUncompressedData(apk, sourceStampCdRecord, zipSections.GetZipCentralDirectoryOffset());
                    SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigResult sourceStampResult = SigningServer.Android.Com.Android.Apksig.Internal.Apk.Stamp.V2SourceStampVerifier.Verify(
                        apk
                        , 
                        zipSections
                        , 
                        sourceStampCertificateDigest
                        , 
                        signatureSchemeApkContentDigests
                        , 
                        SigningServer.Android.Core.Math.Max(minSdkVersion, SigningServer.Android.Com.Android.Apksig.Internal.Util.AndroidSdkVersion.R)
                        , 
                        maxSdkVersion
                    
                    );
                    result.MergeFrom(sourceStampResult);
                }
            }
            catch (SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureNotFoundException ignored)
            {
                result.AddWarning(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.SOURCE_STAMP_SIG_MISSING);
            }
            catch (SigningServer.Android.Com.Android.Apksig.Zip.ZipFormatException e)
            {
                throw new SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException("Failed to read APK", e);
            }
            if (result.ContainsErrors())
            {
                return result;
            }
            if ((result.IsVerifiedUsingV1Scheme()) && (result.IsVerifiedUsingV2Scheme()))
            {
                SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V1SchemeSignerInfo> v1Signers = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V1SchemeSignerInfo>(result.GetV1SchemeSigners());
                SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V2SchemeSignerInfo> v2Signers = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V2SchemeSignerInfo>(result.GetV2SchemeSigners());
                SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.ByteArray> v1SignerCerts = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.ByteArray>();
                SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.ByteArray> v2SignerCerts = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.ByteArray>();
                foreach (SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V1SchemeSignerInfo signer in v1Signers)
                {
                    try
                    {
                        v1SignerCerts.Add(new SigningServer.Android.Com.Android.Apksig.ApkVerifier.ByteArray(signer.GetCertificate().GetEncoded()));
                    }
                    catch (SigningServer.Android.Security.Cert.CertificateEncodingException e)
                    {
                        throw new System.InvalidOperationException("Failed to encode JAR signer " + signer.GetName() + " certs", e);
                    }
                }
                foreach (SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V2SchemeSignerInfo signer in v2Signers)
                {
                    try
                    {
                        v2SignerCerts.Add(new SigningServer.Android.Com.Android.Apksig.ApkVerifier.ByteArray(signer.GetCertificate().GetEncoded()));
                    }
                    catch (SigningServer.Android.Security.Cert.CertificateEncodingException e)
                    {
                        throw new System.InvalidOperationException("Failed to encode APK Signature Scheme v2 signer (index: " + signer.GetIndex() + ") certs", e);
                    }
                }
                for (int i = 0;i < v1SignerCerts.Size();i++)
                {
                    SigningServer.Android.Com.Android.Apksig.ApkVerifier.ByteArray v1Cert = v1SignerCerts.Get(i);
                    if (!v2SignerCerts.Contains(v1Cert))
                    {
                        SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V1SchemeSignerInfo v1Signer = v1Signers.Get(i);
                        v1Signer.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.V2_SIG_MISSING);
                        break;
                    }
                }
                for (int i = 0;i < v2SignerCerts.Size();i++)
                {
                    SigningServer.Android.Com.Android.Apksig.ApkVerifier.ByteArray v2Cert = v2SignerCerts.Get(i);
                    if (!v1SignerCerts.Contains(v2Cert))
                    {
                        SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V2SchemeSignerInfo v2Signer = v2Signers.Get(i);
                        v2Signer.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.JAR_SIG_MISSING);
                        break;
                    }
                }
            }
            if (result.IsVerifiedUsingV3Scheme() && (result.IsVerifiedUsingV1Scheme() || result.IsVerifiedUsingV2Scheme()))
            {
                SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage lineage = result.GetSigningCertificateLineage();
                SigningServer.Android.Security.Cert.X509Certificate oldSignerCert;
                if (result.IsVerifiedUsingV1Scheme())
                {
                    SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V1SchemeSignerInfo> v1Signers = result.GetV1SchemeSigners();
                    if (v1Signers.Size() != 1)
                    {
                        result.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.V3_SIG_MULTIPLE_PAST_SIGNERS);
                    }
                    oldSignerCert = v1Signers.Get(0).mCertChain.Get(0);
                }
                else 
                {
                    SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V2SchemeSignerInfo> v2Signers = result.GetV2SchemeSigners();
                    if (v2Signers.Size() != 1)
                    {
                        result.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.V3_SIG_MULTIPLE_PAST_SIGNERS);
                    }
                    oldSignerCert = v2Signers.Get(0).mCerts.Get(0);
                }
                if (lineage == null)
                {
                    SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V3SchemeSignerInfo> v3Signers = result.GetV3SchemeSigners();
                    if (v3Signers.Size() != 1)
                    {
                        result.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.V3_SIG_MULTIPLE_SIGNERS);
                    }
                    try
                    {
                        if (!SigningServer.Android.Collections.Arrays.Equals(oldSignerCert.GetEncoded(), v3Signers.Get(0).mCerts.Get(0).GetEncoded()))
                        {
                            result.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.V3_SIG_PAST_SIGNERS_MISMATCH);
                        }
                    }
                    catch (SigningServer.Android.Security.Cert.CertificateEncodingException e)
                    {
                        throw new SigningServer.Android.Core.RuntimeException("Failed to encode APK Signature Scheme v3 signer cert", e);
                    }
                }
                else 
                {
                    try
                    {
                        lineage = lineage.GetSubLineage(oldSignerCert);
                        if (lineage.Size() != 1)
                        {
                            result.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.V3_SIG_PAST_SIGNERS_MISMATCH);
                        }
                    }
                    catch (System.ArgumentException e)
                    {
                        result.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.V3_SIG_PAST_SIGNERS_MISMATCH);
                    }
                }
            }
            if (result.IsVerifiedUsingV4Scheme())
            {
                SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V4SchemeSignerInfo> v4Signers = result.GetV4SchemeSigners();
                if (v4Signers.Size() != 1)
                {
                    result.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.V4_SIG_MULTIPLE_SIGNERS);
                }
                SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo.ContentDigest> digestsFromV4 = v4Signers.Get(0).GetContentDigests();
                if (digestsFromV4.Size() != 1)
                {
                    result.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.V4_SIG_V2_V3_DIGESTS_MISMATCH);
                }
                sbyte[] digestFromV4 = digestsFromV4.Get(0).GetValue();
                if (result.IsVerifiedUsingV3Scheme())
                {
                    SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V3SchemeSignerInfo> v3Signers = result.GetV3SchemeSigners();
                    if (v3Signers.Size() != 1)
                    {
                        result.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.V4_SIG_MULTIPLE_SIGNERS);
                    }
                    SigningServer.Android.Com.Android.Apksig.ApkVerifier.CheckV4Certificate(v4Signers.Get(0).mCerts, v3Signers.Get(0).mCerts, result);
                    sbyte[] digestFromV3 = SigningServer.Android.Com.Android.Apksig.ApkVerifier.PickBestDigestForV4(v3Signers.Get(0).GetContentDigests());
                    if (!SigningServer.Android.Collections.Arrays.Equals(digestFromV4, digestFromV3))
                    {
                        result.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.V4_SIG_V2_V3_DIGESTS_MISMATCH);
                    }
                }
                else if (result.IsVerifiedUsingV2Scheme())
                {
                    SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V2SchemeSignerInfo> v2Signers = result.GetV2SchemeSigners();
                    if (v2Signers.Size() != 1)
                    {
                        result.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.V4_SIG_MULTIPLE_SIGNERS);
                    }
                    SigningServer.Android.Com.Android.Apksig.ApkVerifier.CheckV4Certificate(v4Signers.Get(0).mCerts, v2Signers.Get(0).mCerts, result);
                    sbyte[] digestFromV2 = SigningServer.Android.Com.Android.Apksig.ApkVerifier.PickBestDigestForV4(v2Signers.Get(0).GetContentDigests());
                    if (!SigningServer.Android.Collections.Arrays.Equals(digestFromV4, digestFromV2))
                    {
                        result.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.V4_SIG_V2_V3_DIGESTS_MISMATCH);
                    }
                }
                else 
                {
                    throw new SigningServer.Android.Core.RuntimeException("V4 signature must be also verified with V2/V3");
                }
            }
            try
            {
                if (androidManifest == null)
                {
                    androidManifest = SigningServer.Android.Com.Android.Apksig.ApkVerifier.GetAndroidManifestFromApk(apk, zipSections);
                }
            }
            catch (SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException e)
            {
            }
            if (androidManifest != null)
            {
                int targetSdkVersion = SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.GetTargetSdkVersionFromBinaryAndroidManifest(androidManifest.Slice());
                int minSchemeVersion = SigningServer.Android.Com.Android.Apksig.ApkVerifier.GetMinimumSignatureSchemeVersionForTargetSdk(targetSdkVersion);
                if (minSchemeVersion > SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_JAR_SIGNATURE_SCHEME && maxSdkVersion >= targetSdkVersion)
                {
                    switch (minSchemeVersion)
                    {
                        case SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V2:
                            if (result.IsVerifiedUsingV2Scheme())
                            {
                                break;
                            }

                            goto case SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils
                                .VERSION_APK_SIGNATURE_SCHEME_V3;
                            
                        case SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V3:
                            if (result.IsVerifiedUsingV3Scheme())
                            {
                                break;
                            }
                            result.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.MIN_SIG_SCHEME_FOR_TARGET_SDK_NOT_MET, targetSdkVersion, minSchemeVersion);
                            break;
                    }
                }
            }
            if (result.ContainsErrors())
            {
                return result;
            }
            result.SetVerified();
            if (result.IsVerifiedUsingV3Scheme())
            {
                SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V3SchemeSignerInfo> v3Signers = result.GetV3SchemeSigners();
                result.AddSignerCertificate(v3Signers.Get(v3Signers.Size() - 1).GetCertificate());
            }
            else if (result.IsVerifiedUsingV2Scheme())
            {
                foreach (SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V2SchemeSignerInfo signerInfo in result.GetV2SchemeSigners())
                {
                    result.AddSignerCertificate(signerInfo.GetCertificate());
                }
            }
            else if (result.IsVerifiedUsingV1Scheme())
            {
                foreach (SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V1SchemeSignerInfo signerInfo in result.GetV1SchemeSigners())
                {
                    result.AddSignerCertificate(signerInfo.GetCertificate());
                }
            }
            else 
            {
                throw new SigningServer.Android.Core.RuntimeException("APK verified, but has not verified using any of v1, v2 or v3 schemes");
            }
            return result;
        }
        
        /// <summary>
        /// Verifies and returns the minimum SDK version, either as provided to the builder or as read
        /// from the {@code apk}'s AndroidManifest.xml.
        /// </summary>
        internal int VerifyAndGetMinSdkVersion(SigningServer.Android.Com.Android.Apksig.Util.DataSource apk, SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.ZipSections zipSections)
        {
            if (mMinSdkVersion != null)
            {
                if (mMinSdkVersion < 0)
                {
                    throw new System.ArgumentException("minSdkVersion must not be negative: " + mMinSdkVersion);
                }
                if ((mMinSdkVersion != null) && (mMinSdkVersion > mMaxSdkVersion))
                {
                    throw new System.ArgumentException("minSdkVersion (" + mMinSdkVersion + ") > maxSdkVersion (" + mMaxSdkVersion + ")");
                }
                return mMinSdkVersion.Value;
            }
            SigningServer.Android.IO.ByteBuffer androidManifest = null;
            if (androidManifest == null)
            {
                androidManifest = SigningServer.Android.Com.Android.Apksig.ApkVerifier.GetAndroidManifestFromApk(apk, zipSections);
            }
            int minSdkVersion = SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.GetMinSdkVersionFromBinaryAndroidManifest(androidManifest.Slice());
            if (minSdkVersion > mMaxSdkVersion)
            {
                throw new System.ArgumentException("minSdkVersion from APK (" + minSdkVersion + ") > maxSdkVersion (" + mMaxSdkVersion + ")");
            }
            return minSdkVersion;
        }
        
        /// <summary>
        /// Returns the mapping of signature scheme version to signature scheme name for all signature
        /// schemes starting from V2 supported by the {@code maxSdkVersion}.
        /// </summary>
        internal static SigningServer.Android.Collections.Map<int, string> GetSupportedSchemeNames(int maxSdkVersion)
        {
            SigningServer.Android.Collections.Map<int, string> supportedSchemeNames;
            if (maxSdkVersion >= SigningServer.Android.Com.Android.Apksig.Internal.Util.AndroidSdkVersion.P)
            {
                supportedSchemeNames = SigningServer.Android.Com.Android.Apksig.ApkVerifier.SUPPORTED_APK_SIG_SCHEME_NAMES;
            }
            else if (maxSdkVersion >= SigningServer.Android.Com.Android.Apksig.Internal.Util.AndroidSdkVersion.N)
            {
                supportedSchemeNames = new SigningServer.Android.Collections.HashMap<int, string>(1);
                supportedSchemeNames.Put(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V2, SigningServer.Android.Com.Android.Apksig.ApkVerifier.SUPPORTED_APK_SIG_SCHEME_NAMES.Get(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V2));
            }
            else 
            {
                supportedSchemeNames = SigningServer.Android.Util.Collections.EmptyMap<int, string>();
            }
            return supportedSchemeNames;
        }
        
        /// <summary>
        /// Verifies the APK's source stamp signature and returns the result of the verification.
        /// 
        /// &lt;p&gt;The APK's source stamp can be considered verified if the result's {@link
        /// Result#isVerified} returns {@code true}. The details of the source stamp verification can
        /// be obtained from the result's {@link Result#getSourceStampInfo()}} including the success or
        /// failure cause from {@link Result.SourceStampInfo#getSourceStampVerificationStatus()}. If the
        /// verification fails additional details regarding the failure can be obtained from {@link
        /// Result#getAllErrors()}}.
        /// </summary>
        public virtual SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result VerifySourceStamp()
        {
            return VerifySourceStamp(null);
        }
        
        /// <summary>
        /// Verifies the APK's source stamp signature, including verification that the SHA-256 digest of
        /// the stamp signing certificate matches the {@code expectedCertDigest}, and returns the result
        /// of the verification.
        /// 
        /// &lt;p&gt;A value of {@code null} for the {@code expectedCertDigest} will verify the source stamp,
        /// if present, without verifying the actual source stamp certificate used to sign the source
        /// stamp. This can be used to verify an APK contains a properly signed source stamp without
        /// verifying a particular signer.
        /// 
        /// @see #verifySourceStamp()
        /// </summary>
        public virtual SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result VerifySourceStamp(string expectedCertDigest)
        {
            System.IDisposable input = null;
            try
            {
                SigningServer.Android.Com.Android.Apksig.Util.DataSource apk;
                if (mApkDataSource != null)
                {
                    apk = mApkDataSource;
                }
                else if (mApkFile != null)
                {
                    SigningServer.Android.IO.RandomAccessFile f = new SigningServer.Android.IO.RandomAccessFile(mApkFile, "r");
                    input = f;
                    apk = SigningServer.Android.Com.Android.Apksig.Util.DataSources.AsDataSource(f, 0, f.Length());
                }
                else 
                {
                    throw new System.InvalidOperationException("APK not provided");
                }
                return VerifySourceStamp(apk, expectedCertDigest);
            }
            catch (global::System.IO.IOException e)
            {
                return SigningServer.Android.Com.Android.Apksig.ApkVerifier.CreateSourceStampResultWithError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.SourceStampInfo.SourceStampVerificationStatus.VERIFICATION_ERROR, SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.UNEXPECTED_EXCEPTION, e);
            }
            finally
            {
                if (input != null)
                {
                    try
                    {
                        input.Dispose();
                    }
                    catch (global::System.IO.IOException ignored)
                    {
                    }
                }
            }
        }
        
        /// <summary>
        /// Verifies the provided {@code apk}'s source stamp signature, including verification of the
        /// SHA-256 digest of the stamp signing certificate matches the {@code expectedCertDigest}, and
        /// returns the result of the verification.
        /// 
        /// @see #verifySourceStamp(String)
        /// </summary>
        internal SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result VerifySourceStamp(SigningServer.Android.Com.Android.Apksig.Util.DataSource apk, string expectedCertDigest)
        {
            try
            {
                SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.ZipSections zipSections = SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.FindZipSections(apk);
                int minSdkVersion = VerifyAndGetMinSdkVersion(apk, zipSections);
                SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord> cdRecords = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.ParseZipCentralDirectory(apk, zipSections);
                SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord sourceStampCdRecord = null;
                foreach (SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord cdRecord in cdRecords)
                {
                    if (SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.SOURCE_STAMP_CERTIFICATE_HASH_ZIP_ENTRY_NAME.Equals(cdRecord.GetName()))
                    {
                        sourceStampCdRecord = cdRecord;
                        break;
                    }
                }
                if (sourceStampCdRecord == null)
                {
                    bool stampSigningBlockFound;
                    try
                    {
                        SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result signingBlockResult = new SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_SOURCE_STAMP);
                        SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.FindSignature(apk, zipSections, SigningServer.Android.Com.Android.Apksig.Internal.Apk.Stamp.SourceStampConstants.V2_SOURCE_STAMP_BLOCK_ID, signingBlockResult);
                        stampSigningBlockFound = true;
                    }
                    catch (SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignatureNotFoundException e)
                    {
                        stampSigningBlockFound = false;
                    }
                    if (stampSigningBlockFound)
                    {
                        return SigningServer.Android.Com.Android.Apksig.ApkVerifier.CreateSourceStampResultWithError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.SourceStampInfo.SourceStampVerificationStatus.STAMP_NOT_VERIFIED, SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.SOURCE_STAMP_SIGNATURE_BLOCK_WITHOUT_CERT_DIGEST);
                    }
                    else 
                    {
                        return SigningServer.Android.Com.Android.Apksig.ApkVerifier.CreateSourceStampResultWithError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.SourceStampInfo.SourceStampVerificationStatus.STAMP_MISSING, SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.SOURCE_STAMP_CERT_DIGEST_AND_SIG_BLOCK_MISSING);
                    }
                }
                sbyte[] sourceStampCertificateDigest = SigningServer.Android.Com.Android.Apksig.Internal.Zip.LocalFileRecord.GetUncompressedData(apk, sourceStampCdRecord, zipSections.GetZipCentralDirectoryOffset());
                if (expectedCertDigest != null)
                {
                    string actualCertDigest = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ToHex(sourceStampCertificateDigest);
                    if (!expectedCertDigest.EqualsIgnoreCase(actualCertDigest))
                    {
                        return SigningServer.Android.Com.Android.Apksig.ApkVerifier.CreateSourceStampResultWithError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.SourceStampInfo.SourceStampVerificationStatus.CERT_DIGEST_MISMATCH, SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.SOURCE_STAMP_EXPECTED_DIGEST_MISMATCH, actualCertDigest, expectedCertDigest);
                    }
                }
                SigningServer.Android.Collections.Map<int, SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]>> signatureSchemeApkContentDigests = new SigningServer.Android.Collections.HashMap<int, SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]>>();
                SigningServer.Android.Collections.Map<int, string> supportedSchemeNames = SigningServer.Android.Com.Android.Apksig.ApkVerifier.GetSupportedSchemeNames(mMaxSdkVersion);
                SigningServer.Android.Collections.Set<int> foundApkSigSchemeIds = new SigningServer.Android.Collections.HashSet<int>(2);
                SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result result = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result();
                SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result v3Result = null;
                if (mMaxSdkVersion >= SigningServer.Android.Com.Android.Apksig.Internal.Util.AndroidSdkVersion.P)
                {
                    v3Result = GetApkContentDigests(
                        apk
                        , 
                        zipSections
                        , 
                        foundApkSigSchemeIds
                        , 
                        supportedSchemeNames
                        , 
                        signatureSchemeApkContentDigests
                        , 
                        SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V3
                        , 
                        SigningServer.Android.Core.Math.Max(minSdkVersion, SigningServer.Android.Com.Android.Apksig.Internal.Util.AndroidSdkVersion.P)
                    
                    );
                    if (v3Result != null && v3Result.ContainsErrors())
                    {
                        result.MergeFrom(v3Result);
                        return SigningServer.Android.Com.Android.Apksig.ApkVerifier.MergeSourceStampResult(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.SourceStampInfo.SourceStampVerificationStatus.VERIFICATION_ERROR, result);
                    }
                }
                SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result v2Result = null;
                if (mMaxSdkVersion >= SigningServer.Android.Com.Android.Apksig.Internal.Util.AndroidSdkVersion.N && (minSdkVersion < SigningServer.Android.Com.Android.Apksig.Internal.Util.AndroidSdkVersion.P || foundApkSigSchemeIds.IsEmpty()))
                {
                    v2Result = GetApkContentDigests(
                        apk
                        , 
                        zipSections
                        , 
                        foundApkSigSchemeIds
                        , 
                        supportedSchemeNames
                        , 
                        signatureSchemeApkContentDigests
                        , 
                        SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V2
                        , 
                        SigningServer.Android.Core.Math.Max(minSdkVersion, SigningServer.Android.Com.Android.Apksig.Internal.Util.AndroidSdkVersion.N)
                    
                    );
                    if (v2Result != null && v2Result.ContainsErrors())
                    {
                        result.MergeFrom(v2Result);
                        return SigningServer.Android.Com.Android.Apksig.ApkVerifier.MergeSourceStampResult(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.SourceStampInfo.SourceStampVerificationStatus.VERIFICATION_ERROR, result);
                    }
                }
                if (minSdkVersion < SigningServer.Android.Com.Android.Apksig.Internal.Util.AndroidSdkVersion.N || foundApkSigSchemeIds.IsEmpty())
                {
                    signatureSchemeApkContentDigests.Put(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_JAR_SIGNATURE_SCHEME, SigningServer.Android.Com.Android.Apksig.ApkVerifier.GetApkContentDigestFromV1SigningScheme(cdRecords, apk, zipSections));
                }
                SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigResult sourceStampResult = SigningServer.Android.Com.Android.Apksig.Internal.Apk.Stamp.V2SourceStampVerifier.Verify(
                    apk
                    , 
                    zipSections
                    , 
                    sourceStampCertificateDigest
                    , 
                    signatureSchemeApkContentDigests
                    , 
                    minSdkVersion
                    , 
                    mMaxSdkVersion
                
                );
                result.MergeFrom(sourceStampResult);
                if (sourceStampResult.verified)
                {
                    result.SetVerified();
                }
                else 
                {
                    result.SetWarningsAsErrors(true);
                }
                return result;
            }
            catch (System.Exception e) when ( e is SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException || e is global::System.IO.IOException || e is SigningServer.Android.Com.Android.Apksig.Zip.ZipFormatException)
            {
                return SigningServer.Android.Com.Android.Apksig.ApkVerifier.CreateSourceStampResultWithError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.SourceStampInfo.SourceStampVerificationStatus.VERIFICATION_ERROR, SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.MALFORMED_APK, e);
            }
            catch (SigningServer.Android.Security.NoSuchAlgorithmException e)
            {
                return SigningServer.Android.Com.Android.Apksig.ApkVerifier.CreateSourceStampResultWithError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.SourceStampInfo.SourceStampVerificationStatus.VERIFICATION_ERROR, SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.UNEXPECTED_EXCEPTION, e);
            }
            catch (SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureNotFoundException e)
            {
                return SigningServer.Android.Com.Android.Apksig.ApkVerifier.CreateSourceStampResultWithError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.SourceStampInfo.SourceStampVerificationStatus.STAMP_NOT_VERIFIED, SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.SOURCE_STAMP_SIG_MISSING);
            }
        }
        
        /// <summary>
        /// Creates and returns a {@code Result} that can be returned for source stamp verification
        /// with the provided source stamp {@code verificationStatus}, and logs an error for the
        /// specified {@code issue} and {@code params}.
        /// </summary>
        internal static SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result CreateSourceStampResultWithError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.SourceStampInfo.SourceStampVerificationStatus verificationStatus, SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue issue, params object[] parameters)
        {
            SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result result = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result();
            result.AddError(issue, parameters);
            return SigningServer.Android.Com.Android.Apksig.ApkVerifier.MergeSourceStampResult(verificationStatus, result);
        }
        
        /// <summary>
        /// Creates a new {@link Result.SourceStampInfo} under the provided {@code result} and sets the
        /// source stamp status to the provided {@code verificationStatus}.
        /// </summary>
        internal static SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result MergeSourceStampResult(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.SourceStampInfo.SourceStampVerificationStatus verificationStatus, SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result result)
        {
            result.mSourceStampInfo = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.SourceStampInfo(verificationStatus);
            return result;
        }
        
        /// <summary>
        /// Obtains the APK content digest(s) and adds them to the provided {@code
        /// sigSchemeApkContentDigests}, returning an {@code ApkSigningBlockUtils.Result} that can be
        /// merged with a {@code Result} to notify the client of any errors.
        /// 
        /// &lt;p&gt;Note, this method currently only supports signature scheme V2 and V3; to obtain the
        /// content digests for V1 signatures use {@link
        /// #getApkContentDigestFromV1SigningScheme(List, DataSource, ApkUtils.ZipSections)}. If a
        /// signature scheme version other than V2 or V3 is provided a {@code null} value will be
        /// returned.
        /// </summary>
        internal SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result GetApkContentDigests(SigningServer.Android.Com.Android.Apksig.Util.DataSource apk, SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.ZipSections zipSections, SigningServer.Android.Collections.Set<int> foundApkSigSchemeIds, SigningServer.Android.Collections.Map<int, string> supportedSchemeNames, SigningServer.Android.Collections.Map<int, SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]>> sigSchemeApkContentDigests, int apkSigSchemeVersion, int minSdkVersion)
        {
            if (!(apkSigSchemeVersion == SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V2 || apkSigSchemeVersion == SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V3))
            {
                return null;
            }
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result result = new SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result(apkSigSchemeVersion);
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureInfo signatureInfo;
            try
            {
                int sigSchemeBlockId = apkSigSchemeVersion == SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V3 ? SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SchemeConstants.APK_SIGNATURE_SCHEME_V3_BLOCK_ID : SigningServer.Android.Com.Android.Apksig.Internal.Apk.V2.V2SchemeConstants.APK_SIGNATURE_SCHEME_V2_BLOCK_ID;
                signatureInfo = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.FindSignature(apk, zipSections, sigSchemeBlockId, result);
            }
            catch (SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignatureNotFoundException e)
            {
                return null;
            }
            foundApkSigSchemeIds.Add(apkSigSchemeVersion);
            SigningServer.Android.Collections.Set<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm> contentDigestsToVerify = new SigningServer.Android.Collections.HashSet<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm>(1);
            if (apkSigSchemeVersion == SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V2)
            {
                SigningServer.Android.Com.Android.Apksig.Internal.Apk.V2.V2SchemeVerifier.ParseSigners(
                    signatureInfo.signatureBlock
                    , 
                    contentDigestsToVerify
                    , 
                    supportedSchemeNames
                    , 
                    foundApkSigSchemeIds
                    , 
                    minSdkVersion
                    , 
                    mMaxSdkVersion
                    , 
                    result
                
                );
            }
            else 
            {
                SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SchemeVerifier.ParseSigners(signatureInfo.signatureBlock, contentDigestsToVerify, result);
            }
            SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]> apkContentDigests = new SigningServer.Android.Collections.EnumMap<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]>(typeof(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm));
            foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo signerInfo in result.signers)
            {
                foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo.ContentDigest contentDigest in signerInfo.contentDigests)
                {
                    SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm signatureAlgorithm = SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm.FindById(contentDigest.GetSignatureAlgorithmId());
                    if (signatureAlgorithm == null)
                    {
                        continue;
                    }
                    apkContentDigests.Put(signatureAlgorithm.GetContentDigestAlgorithm(), contentDigest.GetValue());
                }
            }
            sigSchemeApkContentDigests.Put(apkSigSchemeVersion, apkContentDigests);
            return result;
        }
        
        internal static void CheckV4Certificate(SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> v4Certs, SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> v2v3Certs, SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result result)
        {
            try
            {
                sbyte[] v4Cert = v4Certs.Get(0).GetEncoded();
                sbyte[] cert = v2v3Certs.Get(0).GetEncoded();
                if (!SigningServer.Android.Collections.Arrays.Equals(cert, v4Cert))
                {
                    result.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.V4_SIG_V2_V3_SIGNERS_MISMATCH);
                }
            }
            catch (SigningServer.Android.Security.Cert.CertificateEncodingException e)
            {
                throw new SigningServer.Android.Core.RuntimeException("Failed to encode APK signer cert", e);
            }
        }
        
        internal static sbyte[] PickBestDigestForV4(SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo.ContentDigest> contentDigests)
        {
            SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]> apkContentDigests = new SigningServer.Android.Collections.HashMap<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]>();
            SigningServer.Android.Com.Android.Apksig.ApkVerifier.CollectApkContentDigests(contentDigests, apkContentDigests);
            return SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.PickBestDigestForV4(apkContentDigests);
        }
        
        internal static SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]> GetApkContentDigestsFromSigningSchemeResult(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result apkSigningSchemeResult)
        {
            SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]> apkContentDigests = new SigningServer.Android.Collections.HashMap<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]>();
            foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo signerInfo in apkSigningSchemeResult.signers)
            {
                SigningServer.Android.Com.Android.Apksig.ApkVerifier.CollectApkContentDigests(signerInfo.contentDigests, apkContentDigests);
            }
            return apkContentDigests;
        }
        
        internal static SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]> GetApkContentDigestFromV1SigningScheme(SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord> cdRecords, SigningServer.Android.Com.Android.Apksig.Util.DataSource apk, SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.ZipSections zipSections)
        {
            SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord manifestCdRecord = null;
            SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]> v1ContentDigest = new SigningServer.Android.Collections.EnumMap<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]>(typeof(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm));
            foreach (SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord cdRecord in cdRecords)
            {
                if (SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeConstants.MANIFEST_ENTRY_NAME.Equals(cdRecord.GetName()))
                {
                    manifestCdRecord = cdRecord;
                    break;
                }
            }
            if (manifestCdRecord == null)
            {
                return v1ContentDigest;
            }
            try
            {
                sbyte[] manifestBytes = SigningServer.Android.Com.Android.Apksig.Internal.Zip.LocalFileRecord.GetUncompressedData(apk, manifestCdRecord, zipSections.GetZipCentralDirectoryOffset());
                v1ContentDigest.Put(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm.SHA256, SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.ComputeSha256DigestBytes(manifestBytes));
                return v1ContentDigest;
            }
            catch (SigningServer.Android.Com.Android.Apksig.Zip.ZipFormatException e)
            {
                throw new SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException("Failed to read APK", e);
            }
        }
        
        internal static void CollectApkContentDigests(SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo.ContentDigest> contentDigests, SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]> apkContentDigests)
        {
            foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo.ContentDigest contentDigest in contentDigests)
            {
                SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm signatureAlgorithm = SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm.FindById(contentDigest.GetSignatureAlgorithmId());
                if (signatureAlgorithm == null)
                {
                    continue;
                }
                SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm contentDigestAlgorithm = signatureAlgorithm.GetContentDigestAlgorithm();
                apkContentDigests.Put(contentDigestAlgorithm, contentDigest.GetValue());
            }
        }
        
        internal static SigningServer.Android.IO.ByteBuffer GetAndroidManifestFromApk(SigningServer.Android.Com.Android.Apksig.Util.DataSource apk, SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.ZipSections zipSections)
        {
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord> cdRecords = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.ParseZipCentralDirectory(apk, zipSections);
            try
            {
                return SigningServer.Android.Com.Android.Apksig.ApkSigner.GetAndroidManifestFromApk(cdRecords, apk.Slice(0, zipSections.GetZipCentralDirectoryOffset()));
            }
            catch (SigningServer.Android.Com.Android.Apksig.Zip.ZipFormatException e)
            {
                throw new SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException("Failed to read AndroidManifest.xml", e);
            }
        }
        
        internal static int GetMinimumSignatureSchemeVersionForTargetSdk(int targetSdkVersion)
        {
            if (targetSdkVersion >= SigningServer.Android.Com.Android.Apksig.Internal.Util.AndroidSdkVersion.R)
            {
                return SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V2;
            }
            return SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_JAR_SIGNATURE_SCHEME;
        }
        
        /// <summary>
        /// Result of verifying an APKs signatures. The APK can be considered verified iff
        /// {@link #isVerified()} returns {@code true}.
        /// </summary>
        public class Result
        {
            internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> mErrors = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams>();
            
            internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> mWarnings = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams>();
            
            internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> mSignerCerts = new SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate>();
            
            internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V1SchemeSignerInfo> mV1SchemeSigners = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V1SchemeSignerInfo>();
            
            internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V1SchemeSignerInfo> mV1SchemeIgnoredSigners = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V1SchemeSignerInfo>();
            
            internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V2SchemeSignerInfo> mV2SchemeSigners = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V2SchemeSignerInfo>();
            
            internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V3SchemeSignerInfo> mV3SchemeSigners = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V3SchemeSignerInfo>();
            
            internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V4SchemeSignerInfo> mV4SchemeSigners = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V4SchemeSignerInfo>();
            
            internal SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.SourceStampInfo mSourceStampInfo;
            
            internal bool mVerified;
            
            internal bool mVerifiedUsingV1Scheme;
            
            internal bool mVerifiedUsingV2Scheme;
            
            internal bool mVerifiedUsingV3Scheme;
            
            internal bool mVerifiedUsingV4Scheme;
            
            internal bool mSourceStampVerified;
            
            internal bool mWarningsAsErrors;
            
            internal SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage mSigningCertificateLineage;
            
            /// <summary>
            /// Returns {@code true} if the APK's signatures verified.
            /// </summary>
            public virtual bool IsVerified()
            {
                return mVerified;
            }
            
            internal void SetVerified()
            {
                mVerified = true;
            }
            
            /// <summary>
            /// Returns {@code true} if the APK's JAR signatures verified.
            /// </summary>
            public virtual bool IsVerifiedUsingV1Scheme()
            {
                return mVerifiedUsingV1Scheme;
            }
            
            /// <summary>
            /// Returns {@code true} if the APK's APK Signature Scheme v2 signatures verified.
            /// </summary>
            public virtual bool IsVerifiedUsingV2Scheme()
            {
                return mVerifiedUsingV2Scheme;
            }
            
            /// <summary>
            /// Returns {@code true} if the APK's APK Signature Scheme v3 signature verified.
            /// </summary>
            public virtual bool IsVerifiedUsingV3Scheme()
            {
                return mVerifiedUsingV3Scheme;
            }
            
            /// <summary>
            /// Returns {@code true} if the APK's APK Signature Scheme v4 signature verified.
            /// </summary>
            public virtual bool IsVerifiedUsingV4Scheme()
            {
                return mVerifiedUsingV4Scheme;
            }
            
            /// <summary>
            /// Returns {@code true} if the APK's SourceStamp signature verified.
            /// </summary>
            public virtual bool IsSourceStampVerified()
            {
                return mSourceStampVerified;
            }
            
            /// <summary>
            /// Returns the verified signers' certificates, one per signer.
            /// </summary>
            public virtual SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> GetSignerCertificates()
            {
                return mSignerCerts;
            }
            
            internal void AddSignerCertificate(SigningServer.Android.Security.Cert.X509Certificate cert)
            {
                mSignerCerts.Add(cert);
            }
            
            /// <summary>
            /// Returns information about JAR signers associated with the APK's signature. These are the
            /// signers used by Android.
            /// 
            /// @see #getV1SchemeIgnoredSigners()
            /// </summary>
            public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V1SchemeSignerInfo> GetV1SchemeSigners()
            {
                return mV1SchemeSigners;
            }
            
            /// <summary>
            /// Returns information about JAR signers ignored by the APK's signature verification
            /// process. These signers are ignored by Android. However, each signer's errors or warnings
            /// will contain information about why they are ignored.
            /// 
            /// @see #getV1SchemeSigners()
            /// </summary>
            public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V1SchemeSignerInfo> GetV1SchemeIgnoredSigners()
            {
                return mV1SchemeIgnoredSigners;
            }
            
            /// <summary>
            /// Returns information about APK Signature Scheme v2 signers associated with the APK's
            /// signature.
            /// </summary>
            public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V2SchemeSignerInfo> GetV2SchemeSigners()
            {
                return mV2SchemeSigners;
            }
            
            /// <summary>
            /// Returns information about APK Signature Scheme v3 signers associated with the APK's
            /// signature.
            /// 
            /// &lt;note&gt; Multiple signers represent different targeted platform versions, not
            /// a signing identity of multiple signers.  APK Signature Scheme v3 only supports single
            /// signer identities.&lt;/note&gt;
            /// </summary>
            public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V3SchemeSignerInfo> GetV3SchemeSigners()
            {
                return mV3SchemeSigners;
            }
            
            internal SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V4SchemeSignerInfo> GetV4SchemeSigners()
            {
                return mV4SchemeSigners;
            }
            
            /// <summary>
            /// Returns information about SourceStamp associated with the APK's signature.
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.SourceStampInfo GetSourceStampInfo()
            {
                return mSourceStampInfo;
            }
            
            /// <summary>
            /// Returns the combined SigningCertificateLineage associated with this APK's APK Signature
            /// Scheme v3 signing block.
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage GetSigningCertificateLineage()
            {
                return mSigningCertificateLineage;
            }
            
            public virtual void AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue msg, params object[] parameters)
            {
                mErrors.Add(new SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams(msg, parameters));
            }
            
            public virtual void AddWarning(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue msg, params object[] parameters)
            {
                mWarnings.Add(new SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams(msg, parameters));
            }
            
            /// <summary>
            /// Sets whether warnings should be treated as errors.
            /// </summary>
            public virtual void SetWarningsAsErrors(bool value)
            {
                mWarningsAsErrors = value;
            }
            
            /// <summary>
            /// Returns errors encountered while verifying the APK's signatures.
            /// </summary>
            public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> GetErrors()
            {
                if (!mWarningsAsErrors)
                {
                    return mErrors;
                }
                else 
                {
                    SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> allErrors = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams>();
                    allErrors.AddAll(mErrors);
                    allErrors.AddAll(mWarnings);
                    return allErrors;
                }
            }
            
            /// <summary>
            /// Returns warnings encountered while verifying the APK's signatures.
            /// </summary>
            public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> GetWarnings()
            {
                return mWarnings;
            }
            
            internal void MergeFrom(SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Result source)
            {
                mVerifiedUsingV1Scheme = source.verified;
                mErrors.AddAll(source.GetErrors());
                mWarnings.AddAll(source.GetWarnings());
                foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Result.SignerInfo signer in source.signers)
                {
                    mV1SchemeSigners.Add(new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V1SchemeSignerInfo(signer));
                }
                foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Result.SignerInfo signer in source.ignoredSigners)
                {
                    mV1SchemeIgnoredSigners.Add(new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V1SchemeSignerInfo(signer));
                }
            }
            
            internal void MergeFrom(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigResult source)
            {
                switch (source.signatureSchemeVersion)
                {
                    case SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_SOURCE_STAMP:
                        mSourceStampVerified = source.verified;
                        if (!source.mSigners.IsEmpty())
                        {
                            mSourceStampInfo = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.SourceStampInfo(source.mSigners.Get(0));
                        }
                        break;
                    default:
                        throw new System.ArgumentException("Unknown ApkSigResult Signing Block Scheme Id " + source.signatureSchemeVersion);
                }
            }
            
            internal void MergeFrom(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result source)
            {
                switch (source.signatureSchemeVersion)
                {
                    case SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V2:
                        mVerifiedUsingV2Scheme = source.verified;
                        foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo signer in source.signers)
                        {
                            mV2SchemeSigners.Add(new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V2SchemeSignerInfo(signer));
                        }
                        break;
                    case SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V3:
                        mVerifiedUsingV3Scheme = source.verified;
                        foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo signer in source.signers)
                        {
                            mV3SchemeSigners.Add(new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V3SchemeSignerInfo(signer));
                        }
                        mSigningCertificateLineage = source.signingCertificateLineage;
                        break;
                    case SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V4:
                        mVerifiedUsingV4Scheme = source.verified;
                        foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo signer in source.signers)
                        {
                            mV4SchemeSigners.Add(new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V4SchemeSignerInfo(signer));
                        }
                        break;
                    case SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_SOURCE_STAMP:
                        mSourceStampVerified = source.verified;
                        if (!source.signers.IsEmpty())
                        {
                            mSourceStampInfo = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.SourceStampInfo(source.signers.Get(0));
                        }
                        break;
                    default:
                        throw new System.ArgumentException("Unknown Signing Block Scheme Id");
                }
            }
            
            /// <summary>
            /// Returns {@code true} if an error was encountered while verifying the APK. Any error
            /// prevents the APK from being considered verified.
            /// </summary>
            public virtual bool ContainsErrors()
            {
                if (!mErrors.IsEmpty())
                {
                    return true;
                }
                if (mWarningsAsErrors && !mWarnings.IsEmpty())
                {
                    return true;
                }
                if (!mV1SchemeSigners.IsEmpty())
                {
                    foreach (SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V1SchemeSignerInfo signer in mV1SchemeSigners)
                    {
                        if (signer.ContainsErrors())
                        {
                            return true;
                        }
                        if (mWarningsAsErrors && !signer.GetWarnings().IsEmpty())
                        {
                            return true;
                        }
                    }
                }
                if (!mV2SchemeSigners.IsEmpty())
                {
                    foreach (SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V2SchemeSignerInfo signer in mV2SchemeSigners)
                    {
                        if (signer.ContainsErrors())
                        {
                            return true;
                        }
                        if (mWarningsAsErrors && !signer.GetWarnings().IsEmpty())
                        {
                            return true;
                        }
                    }
                }
                if (!mV3SchemeSigners.IsEmpty())
                {
                    foreach (SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V3SchemeSignerInfo signer in mV3SchemeSigners)
                    {
                        if (signer.ContainsErrors())
                        {
                            return true;
                        }
                        if (mWarningsAsErrors && !signer.GetWarnings().IsEmpty())
                        {
                            return true;
                        }
                    }
                }
                if (mSourceStampInfo != null)
                {
                    if (mSourceStampInfo.ContainsErrors())
                    {
                        return true;
                    }
                    if (mWarningsAsErrors && !mSourceStampInfo.GetWarnings().IsEmpty())
                    {
                        return true;
                    }
                }
                return false;
            }
            
            /// <summary>
            /// Returns all errors for this result, including any errors from signature scheme signers
            /// and the source stamp.
            /// </summary>
            public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> GetAllErrors()
            {
                SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> errors = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams>();
                errors.AddAll(mErrors);
                if (mWarningsAsErrors)
                {
                    errors.AddAll(mWarnings);
                }
                if (!mV1SchemeSigners.IsEmpty())
                {
                    foreach (SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V1SchemeSignerInfo signer in mV1SchemeSigners)
                    {
                        errors.AddAll(signer.mErrors);
                        if (mWarningsAsErrors)
                        {
                            errors.AddAll(signer.GetWarnings());
                        }
                    }
                }
                if (!mV2SchemeSigners.IsEmpty())
                {
                    foreach (SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V2SchemeSignerInfo signer in mV2SchemeSigners)
                    {
                        errors.AddAll(signer.mErrors);
                        if (mWarningsAsErrors)
                        {
                            errors.AddAll(signer.GetWarnings());
                        }
                    }
                }
                if (!mV3SchemeSigners.IsEmpty())
                {
                    foreach (SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.V3SchemeSignerInfo signer in mV3SchemeSigners)
                    {
                        errors.AddAll(signer.mErrors);
                        if (mWarningsAsErrors)
                        {
                            errors.AddAll(signer.GetWarnings());
                        }
                    }
                }
                if (mSourceStampInfo != null)
                {
                    errors.AddAll(mSourceStampInfo.GetErrors());
                    if (mWarningsAsErrors)
                    {
                        errors.AddAll(mSourceStampInfo.GetWarnings());
                    }
                }
                return errors;
            }
            
            /// <summary>
            /// Information about a JAR signer associated with the APK's signature.
            /// </summary>
            public class V1SchemeSignerInfo
            {
                internal readonly string mName;
                
                internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> mCertChain;
                
                internal readonly string mSignatureBlockFileName;
                
                internal readonly string mSignatureFileName;
                
                internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> mErrors;
                
                internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> mWarnings;
                
                internal V1SchemeSignerInfo(SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Result.SignerInfo result)
                {
                    mName = result.name;
                    mCertChain = result.certChain;
                    mSignatureBlockFileName = result.signatureBlockFileName;
                    mSignatureFileName = result.signatureFileName;
                    mErrors = result.GetErrors();
                    mWarnings = result.GetWarnings();
                }
                
                /// <summary>
                /// Returns a user-friendly name of the signer.
                /// </summary>
                public virtual string GetName()
                {
                    return mName;
                }
                
                /// <summary>
                /// Returns the name of the JAR entry containing this signer's JAR signature block file.
                /// </summary>
                public virtual string GetSignatureBlockFileName()
                {
                    return mSignatureBlockFileName;
                }
                
                /// <summary>
                /// Returns the name of the JAR entry containing this signer's JAR signature file.
                /// </summary>
                public virtual string GetSignatureFileName()
                {
                    return mSignatureFileName;
                }
                
                /// <summary>
                /// Returns this signer's signing certificate or {@code null} if not available. The
                /// certificate is guaranteed to be available if no errors were encountered during
                /// verification (see {@link #containsErrors()}.
                /// 
                /// &lt;p&gt;This certificate contains the signer's public key.
                /// </summary>
                public virtual SigningServer.Android.Security.Cert.X509Certificate GetCertificate()
                {
                    return mCertChain.IsEmpty() ? null : mCertChain.Get(0);
                }
                
                /// <summary>
                /// Returns the certificate chain for the signer's public key. The certificate containing
                /// the public key is first, followed by the certificate (if any) which issued the
                /// signing certificate, and so forth. An empty list may be returned if an error was
                /// encountered during verification (see {@link #containsErrors()}).
                /// </summary>
                public virtual SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> GetCertificateChain()
                {
                    return mCertChain;
                }
                
                /// <summary>
                /// Returns {@code true} if an error was encountered while verifying this signer's JAR
                /// signature. Any error prevents the signer's signature from being considered verified.
                /// </summary>
                public virtual bool ContainsErrors()
                {
                    return !mErrors.IsEmpty();
                }
                
                /// <summary>
                /// Returns errors encountered while verifying this signer's JAR signature. Any error
                /// prevents the signer's signature from being considered verified.
                /// </summary>
                public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> GetErrors()
                {
                    return mErrors;
                }
                
                /// <summary>
                /// Returns warnings encountered while verifying this signer's JAR signature. Warnings
                /// do not prevent the signer's signature from being considered verified.
                /// </summary>
                public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> GetWarnings()
                {
                    return mWarnings;
                }
                
                internal void AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue msg, params object[] parameters)
                {
                    mErrors.Add(new SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams(msg, parameters));
                }
                
            }
            
            /// <summary>
            /// Information about an APK Signature Scheme v2 signer associated with the APK's signature.
            /// </summary>
            public class V2SchemeSignerInfo
            {
                internal readonly int mIndex;
                
                internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> mCerts;
                
                internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> mErrors;
                
                internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> mWarnings;
                
                internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo.ContentDigest> mContentDigests;
                
                internal V2SchemeSignerInfo(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo result)
                {
                    mIndex = result.index;
                    mCerts = result.certs;
                    mErrors = result.GetErrors();
                    mWarnings = result.GetWarnings();
                    mContentDigests = result.contentDigests;
                }
                
                /// <summary>
                /// Returns this signer's {@code 0}-based index in the list of signers contained in the
                /// APK's APK Signature Scheme v2 signature.
                /// </summary>
                public virtual int GetIndex()
                {
                    return mIndex;
                }
                
                /// <summary>
                /// Returns this signer's signing certificate or {@code null} if not available. The
                /// certificate is guaranteed to be available if no errors were encountered during
                /// verification (see {@link #containsErrors()}.
                /// 
                /// &lt;p&gt;This certificate contains the signer's public key.
                /// </summary>
                public virtual SigningServer.Android.Security.Cert.X509Certificate GetCertificate()
                {
                    return mCerts.IsEmpty() ? null : mCerts.Get(0);
                }
                
                /// <summary>
                /// Returns this signer's certificates. The first certificate is for the signer's public
                /// key. An empty list may be returned if an error was encountered during verification
                /// (see {@link #containsErrors()}).
                /// </summary>
                public virtual SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> GetCertificates()
                {
                    return mCerts;
                }
                
                internal void AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue msg, params object[] parameters)
                {
                    mErrors.Add(new SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams(msg, parameters));
                }
                
                public virtual bool ContainsErrors()
                {
                    return !mErrors.IsEmpty();
                }
                
                public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> GetErrors()
                {
                    return mErrors;
                }
                
                public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> GetWarnings()
                {
                    return mWarnings;
                }
                
                public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo.ContentDigest> GetContentDigests()
                {
                    return mContentDigests;
                }
                
            }
            
            /// <summary>
            /// Information about an APK Signature Scheme v3 signer associated with the APK's signature.
            /// </summary>
            public class V3SchemeSignerInfo
            {
                internal readonly int mIndex;
                
                internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> mCerts;
                
                internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> mErrors;
                
                internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> mWarnings;
                
                internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo.ContentDigest> mContentDigests;
                
                internal V3SchemeSignerInfo(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo result)
                {
                    mIndex = result.index;
                    mCerts = result.certs;
                    mErrors = result.GetErrors();
                    mWarnings = result.GetWarnings();
                    mContentDigests = result.contentDigests;
                }
                
                /// <summary>
                /// Returns this signer's {@code 0}-based index in the list of signers contained in the
                /// APK's APK Signature Scheme v3 signature.
                /// </summary>
                public virtual int GetIndex()
                {
                    return mIndex;
                }
                
                /// <summary>
                /// Returns this signer's signing certificate or {@code null} if not available. The
                /// certificate is guaranteed to be available if no errors were encountered during
                /// verification (see {@link #containsErrors()}.
                /// 
                /// &lt;p&gt;This certificate contains the signer's public key.
                /// </summary>
                public virtual SigningServer.Android.Security.Cert.X509Certificate GetCertificate()
                {
                    return mCerts.IsEmpty() ? null : mCerts.Get(0);
                }
                
                /// <summary>
                /// Returns this signer's certificates. The first certificate is for the signer's public
                /// key. An empty list may be returned if an error was encountered during verification
                /// (see {@link #containsErrors()}).
                /// </summary>
                public virtual SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> GetCertificates()
                {
                    return mCerts;
                }
                
                public virtual bool ContainsErrors()
                {
                    return !mErrors.IsEmpty();
                }
                
                public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> GetErrors()
                {
                    return mErrors;
                }
                
                public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> GetWarnings()
                {
                    return mWarnings;
                }
                
                public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo.ContentDigest> GetContentDigests()
                {
                    return mContentDigests;
                }
                
            }
            
            /// <summary>
            /// Information about an APK Signature Scheme V4 signer associated with the APK's
            /// signature.
            /// </summary>
            public class V4SchemeSignerInfo
            {
                internal readonly int mIndex;
                
                internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> mCerts;
                
                internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> mErrors;
                
                internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> mWarnings;
                
                internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo.ContentDigest> mContentDigests;
                
                internal V4SchemeSignerInfo(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo result)
                {
                    mIndex = result.index;
                    mCerts = result.certs;
                    mErrors = result.GetErrors();
                    mWarnings = result.GetWarnings();
                    mContentDigests = result.contentDigests;
                }
                
                /// <summary>
                /// Returns this signer's {@code 0}-based index in the list of signers contained in the
                /// APK's APK Signature Scheme v3 signature.
                /// </summary>
                public virtual int GetIndex()
                {
                    return mIndex;
                }
                
                /// <summary>
                /// Returns this signer's signing certificate or {@code null} if not available. The
                /// certificate is guaranteed to be available if no errors were encountered during
                /// verification (see {@link #containsErrors()}.
                /// 
                /// &lt;p&gt;This certificate contains the signer's public key.
                /// </summary>
                public virtual SigningServer.Android.Security.Cert.X509Certificate GetCertificate()
                {
                    return mCerts.IsEmpty() ? null : mCerts.Get(0);
                }
                
                /// <summary>
                /// Returns this signer's certificates. The first certificate is for the signer's public
                /// key. An empty list may be returned if an error was encountered during verification
                /// (see {@link #containsErrors()}).
                /// </summary>
                public virtual SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> GetCertificates()
                {
                    return mCerts;
                }
                
                public virtual bool ContainsErrors()
                {
                    return !mErrors.IsEmpty();
                }
                
                public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> GetErrors()
                {
                    return mErrors;
                }
                
                public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> GetWarnings()
                {
                    return mWarnings;
                }
                
                public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo.ContentDigest> GetContentDigests()
                {
                    return mContentDigests;
                }
                
            }
            
            /// <summary>
            /// Information about SourceStamp associated with the APK's signature.
            /// </summary>
            public class SourceStampInfo
            {
                public enum SourceStampVerificationStatus
                {
                    /// <summary>
                    /// The stamp is present and was successfully verified.
                    /// </summary>
                    STAMP_VERIFIED,
                    /// <summary>
                    /// The stamp is present but failed verification.
                    /// </summary>
                    STAMP_VERIFICATION_FAILED,
                    /// <summary>
                    /// The expected cert digest did not match the digest in the APK.
                    /// </summary>
                    CERT_DIGEST_MISMATCH,
                    /// <summary>
                    /// The stamp is not present at all.
                    /// </summary>
                    STAMP_MISSING,
                    /// <summary>
                    /// The stamp is at least partially present, but was not able to be verified.
                    /// </summary>
                    STAMP_NOT_VERIFIED,
                    /// <summary>
                    /// The stamp was not able to be verified due to an unexpected error.
                    /// </summary>
                    VERIFICATION_ERROR,
                }
                
                internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> mCertificates;
                
                internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> mCertificateLineage;
                
                internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> mErrors;
                
                internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> mWarnings;
                
                internal readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.SourceStampInfo.SourceStampVerificationStatus mSourceStampVerificationStatus;
                
                internal SourceStampInfo(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSignerInfo result)
                {
                    mCertificates = result.certs;
                    mCertificateLineage = result.certificateLineage;
                    mErrors = SigningServer.Android.Com.Android.Apksig.ApkVerifier.ApkVerificationIssueAdapter.GetIssuesFromVerificationIssues(result.GetErrors());
                    mWarnings = SigningServer.Android.Com.Android.Apksig.ApkVerifier.ApkVerificationIssueAdapter.GetIssuesFromVerificationIssues(result.GetWarnings());
                    if (mErrors.IsEmpty() && mWarnings.IsEmpty())
                    {
                        mSourceStampVerificationStatus = SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.SourceStampInfo.SourceStampVerificationStatus.STAMP_VERIFIED;
                    }
                    else 
                    {
                        mSourceStampVerificationStatus = SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.SourceStampInfo.SourceStampVerificationStatus.STAMP_VERIFICATION_FAILED;
                    }
                }
                
                internal SourceStampInfo(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.SourceStampInfo.SourceStampVerificationStatus sourceStampVerificationStatus)
                {
                    mCertificates = SigningServer.Android.Util.Collections.EmptyList<X509Certificate>();
                    mCertificateLineage = SigningServer.Android.Util.Collections.EmptyList<X509Certificate>();
                    mErrors = SigningServer.Android.Util.Collections.EmptyList<IssueWithParams>();
                    mWarnings = SigningServer.Android.Util.Collections.EmptyList<IssueWithParams>();
                    mSourceStampVerificationStatus = sourceStampVerificationStatus;
                }
                
                /// <summary>
                /// Returns the SourceStamp's signing certificate or {@code null} if not available. The
                /// certificate is guaranteed to be available if no errors were encountered during
                /// verification (see {@link #containsErrors()}.
                /// 
                /// &lt;p&gt;This certificate contains the SourceStamp's public key.
                /// </summary>
                public virtual SigningServer.Android.Security.Cert.X509Certificate GetCertificate()
                {
                    return mCertificates.IsEmpty() ? null : mCertificates.Get(0);
                }
                
                /// <summary>
                /// Returns a list containing all of the certificates in the stamp certificate lineage.
                /// </summary>
                public virtual SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> GetCertificatesInLineage()
                {
                    return mCertificateLineage;
                }
                
                public virtual bool ContainsErrors()
                {
                    return !mErrors.IsEmpty();
                }
                
                public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> GetErrors()
                {
                    return mErrors;
                }
                
                public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> GetWarnings()
                {
                    return mWarnings;
                }
                
                /// <summary>
                /// Returns the reason for any source stamp verification failures, or {@code
                /// STAMP_VERIFIED} if the source stamp was successfully verified.
                /// </summary>
                public virtual SigningServer.Android.Com.Android.Apksig.ApkVerifier.Result.SourceStampInfo.SourceStampVerificationStatus GetSourceStampVerificationStatus()
                {
                    return mSourceStampVerificationStatus;
                }
                
            }
            
        }
        
        /// <summary>
        /// Error or warning encountered while verifying an APK's signatures.
        /// </summary>
        public class Issue
        {
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue JAR_SIG_NO_SIGNATURES = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("No JAR signatures", 0);
            
            public const int JAR_SIG_NO_SIGNATURES_CASE = 0;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue JAR_SIG_NO_SIGNED_ZIP_ENTRIES = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("No JAR entries covered by JAR signatures", 1);
            
            public const int JAR_SIG_NO_SIGNED_ZIP_ENTRIES_CASE = 1;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue JAR_SIG_DUPLICATE_ZIP_ENTRY = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Duplicate entry: %1$s", 2);
            
            public const int JAR_SIG_DUPLICATE_ZIP_ENTRY_CASE = 2;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue JAR_SIG_DUPLICATE_MANIFEST_SECTION = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Duplicate section in META-INF/MANIFEST.MF: %1$s", 3);
            
            public const int JAR_SIG_DUPLICATE_MANIFEST_SECTION_CASE = 3;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue JAR_SIG_UNNNAMED_MANIFEST_SECTION = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Malformed META-INF/MANIFEST.MF: invidual section #%1$d does not have a name", 4);
            
            public const int JAR_SIG_UNNNAMED_MANIFEST_SECTION_CASE = 4;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue JAR_SIG_UNNNAMED_SIG_FILE_SECTION = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Malformed %1$s: invidual section #%2$d does not have a name", 5);
            
            public const int JAR_SIG_UNNNAMED_SIG_FILE_SECTION_CASE = 5;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue JAR_SIG_NO_MANIFEST = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Missing META-INF/MANIFEST.MF", 6);
            
            public const int JAR_SIG_NO_MANIFEST_CASE = 6;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue JAR_SIG_MISSING_ZIP_ENTRY_REFERENCED_IN_MANIFEST = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("%1$s entry referenced by META-INF/MANIFEST.MF not found in the APK", 7);
            
            public const int JAR_SIG_MISSING_ZIP_ENTRY_REFERENCED_IN_MANIFEST_CASE = 7;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue JAR_SIG_NO_ZIP_ENTRY_DIGEST_IN_MANIFEST = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("No digest for %1$s in META-INF/MANIFEST.MF", 8);
            
            public const int JAR_SIG_NO_ZIP_ENTRY_DIGEST_IN_MANIFEST_CASE = 8;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue JAR_SIG_NO_ZIP_ENTRY_DIGEST_IN_SIG_FILE = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("No digest for %1$s in %2$s", 9);
            
            public const int JAR_SIG_NO_ZIP_ENTRY_DIGEST_IN_SIG_FILE_CASE = 9;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue JAR_SIG_ZIP_ENTRY_NOT_SIGNED = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("%1$s entry not signed", 10);
            
            public const int JAR_SIG_ZIP_ENTRY_NOT_SIGNED_CASE = 10;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue JAR_SIG_ZIP_ENTRY_SIGNERS_MISMATCH = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Entries %1$s and %3$s are signed with different sets of signers" + " : <%2$s> vs <%4$s>", 11);
            
            public const int JAR_SIG_ZIP_ENTRY_SIGNERS_MISMATCH_CASE = 11;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue JAR_SIG_ZIP_ENTRY_DIGEST_DID_NOT_VERIFY = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("%2$s digest of %1$s does not match the digest specified in %3$s" + ". Expected: <%5$s>, actual: <%4$s>", 12);
            
            public const int JAR_SIG_ZIP_ENTRY_DIGEST_DID_NOT_VERIFY_CASE = 12;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue JAR_SIG_MANIFEST_MAIN_SECTION_DIGEST_DID_NOT_VERIFY = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("%1$s digest of META-INF/MANIFEST.MF main section does not match the digest" + " specified in %2$s. Expected: <%4$s>, actual: <%3$s>", 13);
            
            public const int JAR_SIG_MANIFEST_MAIN_SECTION_DIGEST_DID_NOT_VERIFY_CASE = 13;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue JAR_SIG_MANIFEST_SECTION_DIGEST_DID_NOT_VERIFY = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("%2$s digest of META-INF/MANIFEST.MF section for %1$s does not match the digest" + " specified in %3$s. Expected: <%5$s>, actual: <%4$s>", 14);
            
            public const int JAR_SIG_MANIFEST_SECTION_DIGEST_DID_NOT_VERIFY_CASE = 14;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue JAR_SIG_NO_MANIFEST_DIGEST_IN_SIG_FILE = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("%1$s does not specify digest of META-INF/MANIFEST.MF" + ". This slows down verification.", 15);
            
            public const int JAR_SIG_NO_MANIFEST_DIGEST_IN_SIG_FILE_CASE = 15;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue JAR_SIG_NO_APK_SIG_STRIP_PROTECTION = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("APK is signed using APK Signature Scheme v2 but these signatures may be stripped" + " without being detected because %1$s does not contain anti-stripping" + " protections.", 16);
            
            public const int JAR_SIG_NO_APK_SIG_STRIP_PROTECTION_CASE = 16;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue JAR_SIG_MISSING_FILE = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Partial JAR signature. Found: %1$s, missing: %2$s", 17);
            
            public const int JAR_SIG_MISSING_FILE_CASE = 17;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue JAR_SIG_VERIFY_EXCEPTION = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Failed to verify JAR signature %1$s against %2$s: %3$s", 18);
            
            public const int JAR_SIG_VERIFY_EXCEPTION_CASE = 18;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue JAR_SIG_UNSUPPORTED_SIG_ALG = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("JAR signature %1$s uses digest algorithm %5$s and signature algorithm %6$s which" + " is not supported on API Level(s) %4$s for which this APK is being" + " verified", 19);
            
            public const int JAR_SIG_UNSUPPORTED_SIG_ALG_CASE = 19;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue JAR_SIG_PARSE_EXCEPTION = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Failed to parse JAR signature %1$s: %2$s", 20);
            
            public const int JAR_SIG_PARSE_EXCEPTION_CASE = 20;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue JAR_SIG_MALFORMED_CERTIFICATE = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Malformed certificate in JAR signature %1$s: %2$s", 21);
            
            public const int JAR_SIG_MALFORMED_CERTIFICATE_CASE = 21;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue JAR_SIG_DID_NOT_VERIFY = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("JAR signature %1$s did not verify against %2$s", 22);
            
            public const int JAR_SIG_DID_NOT_VERIFY_CASE = 22;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue JAR_SIG_NO_SIGNERS = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("JAR signature %1$s contains no signers", 23);
            
            public const int JAR_SIG_NO_SIGNERS_CASE = 23;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue JAR_SIG_DUPLICATE_SIG_FILE_SECTION = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Duplicate section in %1$s: %2$s", 24);
            
            public const int JAR_SIG_DUPLICATE_SIG_FILE_SECTION_CASE = 24;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue JAR_SIG_MISSING_VERSION_ATTR_IN_SIG_FILE = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Malformed %1$s: missing Signature-Version attribute", 25);
            
            public const int JAR_SIG_MISSING_VERSION_ATTR_IN_SIG_FILE_CASE = 25;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue JAR_SIG_UNKNOWN_APK_SIG_SCHEME_ID = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("JAR signature %1$s references unknown APK signature scheme ID: %2$d", 26);
            
            public const int JAR_SIG_UNKNOWN_APK_SIG_SCHEME_ID_CASE = 26;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue JAR_SIG_MISSING_APK_SIG_REFERENCED = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("JAR signature %1$s indicates the APK is signed using %3$s but no such signature" + " was found. Signature stripped?", 27);
            
            public const int JAR_SIG_MISSING_APK_SIG_REFERENCED_CASE = 27;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue JAR_SIG_UNPROTECTED_ZIP_ENTRY = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("%1$s not protected by signature. Unauthorized modifications to this JAR entry" + " will not be detected. Delete or move the entry outside of META-INF/.", 28);
            
            public const int JAR_SIG_UNPROTECTED_ZIP_ENTRY_CASE = 28;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue JAR_SIG_MISSING = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("No JAR signature from this signer", 29);
            
            public const int JAR_SIG_MISSING_CASE = 29;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue NO_SIG_FOR_TARGET_SANDBOX_VERSION = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Missing APK Signature Scheme v2 signature required for target sandbox version" + " %1$d", 30);
            
            public const int NO_SIG_FOR_TARGET_SANDBOX_VERSION_CASE = 30;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue MIN_SIG_SCHEME_FOR_TARGET_SDK_NOT_MET = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Target SDK version %1$d requires a minimum of signature scheme v%2$d; the APK is" + " not signed with this or a later signature scheme", 31);
            
            public const int MIN_SIG_SCHEME_FOR_TARGET_SDK_NOT_MET_CASE = 31;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V2_SIG_MISSING = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("No APK Signature Scheme v2 signature from this signer", 32);
            
            public const int V2_SIG_MISSING_CASE = 32;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V2_SIG_MALFORMED_SIGNERS = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Malformed list of signers", 33);
            
            public const int V2_SIG_MALFORMED_SIGNERS_CASE = 33;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V2_SIG_MALFORMED_SIGNER = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Malformed signer block", 34);
            
            public const int V2_SIG_MALFORMED_SIGNER_CASE = 34;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V2_SIG_MALFORMED_PUBLIC_KEY = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Malformed public key: %1$s", 35);
            
            public const int V2_SIG_MALFORMED_PUBLIC_KEY_CASE = 35;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V2_SIG_MALFORMED_CERTIFICATE = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Malformed certificate #%2$d: %3$s", 36);
            
            public const int V2_SIG_MALFORMED_CERTIFICATE_CASE = 36;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V2_SIG_MALFORMED_SIGNATURE = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Malformed APK Signature Scheme v2 signature record #%1$d", 37);
            
            public const int V2_SIG_MALFORMED_SIGNATURE_CASE = 37;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V2_SIG_MALFORMED_DIGEST = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Malformed APK Signature Scheme v2 digest record #%1$d", 38);
            
            public const int V2_SIG_MALFORMED_DIGEST_CASE = 38;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V2_SIG_MALFORMED_ADDITIONAL_ATTRIBUTE = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Malformed additional attribute #%1$d", 39);
            
            public const int V2_SIG_MALFORMED_ADDITIONAL_ATTRIBUTE_CASE = 39;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V2_SIG_UNKNOWN_APK_SIG_SCHEME_ID = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("APK Signature Scheme v2 signer: %1$s references unknown APK signature scheme ID: " + "%2$d", 40);
            
            public const int V2_SIG_UNKNOWN_APK_SIG_SCHEME_ID_CASE = 40;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V2_SIG_MISSING_APK_SIG_REFERENCED = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("APK Signature Scheme v2 signature %1$s indicates the APK is signed using %2$s but " + "no such signature was found. Signature stripped?", 41);
            
            public const int V2_SIG_MISSING_APK_SIG_REFERENCED_CASE = 41;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V2_SIG_NO_SIGNERS = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("No signers in APK Signature Scheme v2 signature", 42);
            
            public const int V2_SIG_NO_SIGNERS_CASE = 42;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V2_SIG_UNKNOWN_SIG_ALGORITHM = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Unknown signature algorithm: %1$#x", 43);
            
            public const int V2_SIG_UNKNOWN_SIG_ALGORITHM_CASE = 43;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V2_SIG_UNKNOWN_ADDITIONAL_ATTRIBUTE = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Unknown additional attribute: ID %1$#x", 44);
            
            public const int V2_SIG_UNKNOWN_ADDITIONAL_ATTRIBUTE_CASE = 44;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V2_SIG_VERIFY_EXCEPTION = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Failed to verify %1$s signature: %2$s", 45);
            
            public const int V2_SIG_VERIFY_EXCEPTION_CASE = 45;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V2_SIG_DID_NOT_VERIFY = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("%1$s signature over signed-data did not verify", 46);
            
            public const int V2_SIG_DID_NOT_VERIFY_CASE = 46;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V2_SIG_NO_SIGNATURES = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("No signatures", 47);
            
            public const int V2_SIG_NO_SIGNATURES_CASE = 47;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V2_SIG_NO_SUPPORTED_SIGNATURES = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("No supported signatures: %1$s", 48);
            
            public const int V2_SIG_NO_SUPPORTED_SIGNATURES_CASE = 48;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V2_SIG_NO_CERTIFICATES = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("No certificates", 49);
            
            public const int V2_SIG_NO_CERTIFICATES_CASE = 49;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V2_SIG_PUBLIC_KEY_MISMATCH_BETWEEN_CERTIFICATE_AND_SIGNATURES_RECORD = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Public key mismatch between certificate and signature record: <%1$s> vs <%2$s>", 50);
            
            public const int V2_SIG_PUBLIC_KEY_MISMATCH_BETWEEN_CERTIFICATE_AND_SIGNATURES_RECORD_CASE = 50;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V2_SIG_SIG_ALG_MISMATCH_BETWEEN_SIGNATURES_AND_DIGESTS_RECORDS = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Signature algorithms mismatch between signatures and digests records" + ": %1$s vs %2$s", 51);
            
            public const int V2_SIG_SIG_ALG_MISMATCH_BETWEEN_SIGNATURES_AND_DIGESTS_RECORDS_CASE = 51;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V2_SIG_APK_DIGEST_DID_NOT_VERIFY = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("APK integrity check failed. %1$s digest mismatch." + " Expected: <%2$s>, actual: <%3$s>", 52);
            
            public const int V2_SIG_APK_DIGEST_DID_NOT_VERIFY_CASE = 52;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V3_SIG_MALFORMED_SIGNERS = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Malformed list of signers", 53);
            
            public const int V3_SIG_MALFORMED_SIGNERS_CASE = 53;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V3_SIG_MALFORMED_SIGNER = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Malformed signer block", 54);
            
            public const int V3_SIG_MALFORMED_SIGNER_CASE = 54;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V3_SIG_MALFORMED_PUBLIC_KEY = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Malformed public key: %1$s", 55);
            
            public const int V3_SIG_MALFORMED_PUBLIC_KEY_CASE = 55;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V3_SIG_MALFORMED_CERTIFICATE = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Malformed certificate #%2$d: %3$s", 56);
            
            public const int V3_SIG_MALFORMED_CERTIFICATE_CASE = 56;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V3_SIG_MALFORMED_SIGNATURE = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Malformed APK Signature Scheme v3 signature record #%1$d", 57);
            
            public const int V3_SIG_MALFORMED_SIGNATURE_CASE = 57;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V3_SIG_MALFORMED_DIGEST = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Malformed APK Signature Scheme v3 digest record #%1$d", 58);
            
            public const int V3_SIG_MALFORMED_DIGEST_CASE = 58;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V3_SIG_MALFORMED_ADDITIONAL_ATTRIBUTE = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Malformed additional attribute #%1$d", 59);
            
            public const int V3_SIG_MALFORMED_ADDITIONAL_ATTRIBUTE_CASE = 59;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V3_SIG_NO_SIGNERS = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("No signers in APK Signature Scheme v3 signature", 60);
            
            public const int V3_SIG_NO_SIGNERS_CASE = 60;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V3_SIG_MULTIPLE_SIGNERS = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Multiple APK Signature Scheme v3 signatures found for a single " + " platform version.", 61);
            
            public const int V3_SIG_MULTIPLE_SIGNERS_CASE = 61;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V3_SIG_MULTIPLE_PAST_SIGNERS = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Multiple signatures found for pre-v3 signing with an APK " + " Signature Scheme v3 signer.  Only one allowed.", 62);
            
            public const int V3_SIG_MULTIPLE_PAST_SIGNERS_CASE = 62;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V3_SIG_PAST_SIGNERS_MISMATCH = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("v3 signer differs from v1/v2 signer without proper signing certificate lineage.", 63);
            
            public const int V3_SIG_PAST_SIGNERS_MISMATCH_CASE = 63;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V3_SIG_UNKNOWN_SIG_ALGORITHM = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Unknown signature algorithm: %1$#x", 64);
            
            public const int V3_SIG_UNKNOWN_SIG_ALGORITHM_CASE = 64;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V3_SIG_UNKNOWN_ADDITIONAL_ATTRIBUTE = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Unknown additional attribute: ID %1$#x", 65);
            
            public const int V3_SIG_UNKNOWN_ADDITIONAL_ATTRIBUTE_CASE = 65;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V3_SIG_VERIFY_EXCEPTION = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Failed to verify %1$s signature: %2$s", 66);
            
            public const int V3_SIG_VERIFY_EXCEPTION_CASE = 66;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V3_SIG_INVALID_SDK_VERSIONS = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Invalid SDK Version parameter(s) encountered in APK Signature " + "scheme v3 signature: minSdkVersion %1$s maxSdkVersion: %2$s", 67);
            
            public const int V3_SIG_INVALID_SDK_VERSIONS_CASE = 67;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V3_SIG_DID_NOT_VERIFY = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("%1$s signature over signed-data did not verify", 68);
            
            public const int V3_SIG_DID_NOT_VERIFY_CASE = 68;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V3_SIG_NO_SIGNATURES = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("No signatures", 69);
            
            public const int V3_SIG_NO_SIGNATURES_CASE = 69;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V3_SIG_NO_SUPPORTED_SIGNATURES = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("No supported signatures", 70);
            
            public const int V3_SIG_NO_SUPPORTED_SIGNATURES_CASE = 70;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V3_SIG_NO_CERTIFICATES = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("No certificates", 71);
            
            public const int V3_SIG_NO_CERTIFICATES_CASE = 71;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V3_MIN_SDK_VERSION_MISMATCH_BETWEEN_SIGNER_AND_SIGNED_DATA_RECORD = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("minSdkVersion mismatch between signed data and signature record:" + " <%1$s> vs <%2$s>", 72);
            
            public const int V3_MIN_SDK_VERSION_MISMATCH_BETWEEN_SIGNER_AND_SIGNED_DATA_RECORD_CASE = 72;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V3_MAX_SDK_VERSION_MISMATCH_BETWEEN_SIGNER_AND_SIGNED_DATA_RECORD = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("maxSdkVersion mismatch between signed data and signature record:" + " <%1$s> vs <%2$s>", 73);
            
            public const int V3_MAX_SDK_VERSION_MISMATCH_BETWEEN_SIGNER_AND_SIGNED_DATA_RECORD_CASE = 73;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V3_SIG_PUBLIC_KEY_MISMATCH_BETWEEN_CERTIFICATE_AND_SIGNATURES_RECORD = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Public key mismatch between certificate and signature record: <%1$s> vs <%2$s>", 74);
            
            public const int V3_SIG_PUBLIC_KEY_MISMATCH_BETWEEN_CERTIFICATE_AND_SIGNATURES_RECORD_CASE = 74;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V3_SIG_SIG_ALG_MISMATCH_BETWEEN_SIGNATURES_AND_DIGESTS_RECORDS = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Signature algorithms mismatch between signatures and digests records" + ": %1$s vs %2$s", 75);
            
            public const int V3_SIG_SIG_ALG_MISMATCH_BETWEEN_SIGNATURES_AND_DIGESTS_RECORDS_CASE = 75;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V3_SIG_APK_DIGEST_DID_NOT_VERIFY = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("APK integrity check failed. %1$s digest mismatch." + " Expected: <%2$s>, actual: <%3$s>", 76);
            
            public const int V3_SIG_APK_DIGEST_DID_NOT_VERIFY_CASE = 76;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V3_SIG_POR_DID_NOT_VERIFY = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("SigningCertificateLineage attribute containd a proof-of-rotation" + " record with signature(s) that did not verify.", 77);
            
            public const int V3_SIG_POR_DID_NOT_VERIFY_CASE = 77;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V3_SIG_MALFORMED_LINEAGE = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Failed to parse the SigningCertificateLineage structure in the " + "APK Signature Scheme v3 signature's additional attributes section.", 78);
            
            public const int V3_SIG_MALFORMED_LINEAGE_CASE = 78;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V3_SIG_POR_CERT_MISMATCH = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("APK signing certificate differs from the associated certificate found in the " + "signer's SigningCertificateLineage.", 79);
            
            public const int V3_SIG_POR_CERT_MISMATCH_CASE = 79;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V3_INCONSISTENT_SDK_VERSIONS = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("APK Signature Scheme v3 signers supported min/max SDK " + "versions are not continuous.", 80);
            
            public const int V3_INCONSISTENT_SDK_VERSIONS_CASE = 80;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V3_MISSING_SDK_VERSIONS = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("APK Signature Scheme v3 signers supported min/max SDK " + "versions do not cover the entire desired range.  Found min:  %1$s max %2$s", 81);
            
            public const int V3_MISSING_SDK_VERSIONS_CASE = 81;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V3_INCONSISTENT_LINEAGES = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("SigningCertificateLineages targeting different platform versions" + " using APK Signature Scheme v3 are not all a part of the same overall lineage.", 82);
            
            public const int V3_INCONSISTENT_LINEAGES_CASE = 82;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue APK_SIG_BLOCK_UNKNOWN_ENTRY_ID = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("APK Signing Block contains unknown entry: ID %1$#x", 83);
            
            public const int APK_SIG_BLOCK_UNKNOWN_ENTRY_ID_CASE = 83;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V4_SIG_MALFORMED_SIGNERS = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("V4 signature has malformed signer block", 84);
            
            public const int V4_SIG_MALFORMED_SIGNERS_CASE = 84;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V4_SIG_UNKNOWN_SIG_ALGORITHM = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("V4 signature has unknown signing algorithm: %1$#x", 85);
            
            public const int V4_SIG_UNKNOWN_SIG_ALGORITHM_CASE = 85;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V4_SIG_NO_SIGNATURES = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("V4 signature has no signature found", 86);
            
            public const int V4_SIG_NO_SIGNATURES_CASE = 86;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V4_SIG_NO_SUPPORTED_SIGNATURES = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("V4 signature has no supported signature", 87);
            
            public const int V4_SIG_NO_SUPPORTED_SIGNATURES_CASE = 87;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V4_SIG_DID_NOT_VERIFY = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("%1$s signature over signed-data did not verify", 88);
            
            public const int V4_SIG_DID_NOT_VERIFY_CASE = 88;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V4_SIG_VERIFY_EXCEPTION = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Failed to verify %1$s signature: %2$s", 89);
            
            public const int V4_SIG_VERIFY_EXCEPTION_CASE = 89;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V4_SIG_MALFORMED_PUBLIC_KEY = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Malformed public key: %1$s", 90);
            
            public const int V4_SIG_MALFORMED_PUBLIC_KEY_CASE = 90;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V4_SIG_MALFORMED_CERTIFICATE = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("V4 signature has malformed certificate", 91);
            
            public const int V4_SIG_MALFORMED_CERTIFICATE_CASE = 91;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V4_SIG_NO_CERTIFICATE = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("V4 signature has no certificate", 92);
            
            public const int V4_SIG_NO_CERTIFICATE_CASE = 92;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V4_SIG_PUBLIC_KEY_MISMATCH_BETWEEN_CERTIFICATE_AND_SIGNATURES_RECORD = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("V4 signature has mismatched certificate and signature: <%1$s> vs <%2$s>", 93);
            
            public const int V4_SIG_PUBLIC_KEY_MISMATCH_BETWEEN_CERTIFICATE_AND_SIGNATURES_RECORD_CASE = 93;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V4_SIG_APK_ROOT_DID_NOT_VERIFY = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("V4 signature's hash tree root (content digest) did not verity", 94);
            
            public const int V4_SIG_APK_ROOT_DID_NOT_VERIFY_CASE = 94;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V4_SIG_APK_TREE_DID_NOT_VERIFY = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("V4 signature's hash tree did not verity", 95);
            
            public const int V4_SIG_APK_TREE_DID_NOT_VERIFY_CASE = 95;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V4_SIG_MULTIPLE_SIGNERS = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("V4 signature only supports one signer", 96);
            
            public const int V4_SIG_MULTIPLE_SIGNERS_CASE = 96;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V4_SIG_V2_V3_SIGNERS_MISMATCH = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("V4 signature and V2/V3 signature have mismatched certificates", 97);
            
            public const int V4_SIG_V2_V3_SIGNERS_MISMATCH_CASE = 97;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V4_SIG_V2_V3_DIGESTS_MISMATCH = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("V4 signature and V2/V3 signature have mismatched digests", 98);
            
            public const int V4_SIG_V2_V3_DIGESTS_MISMATCH_CASE = 98;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue V4_SIG_VERSION_NOT_CURRENT = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("V4 signature format version %1$d is different from the tool's current " + "version %2$d", 99);
            
            public const int V4_SIG_VERSION_NOT_CURRENT_CASE = 99;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue SOURCE_STAMP_CERT_DIGEST_AND_SIG_BLOCK_MISSING = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Neither the source stamp certificate digest file nor the signature block are " + "present in the APK", 100);
            
            public const int SOURCE_STAMP_CERT_DIGEST_AND_SIG_BLOCK_MISSING_CASE = 100;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue SOURCE_STAMP_SIG_MISSING = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("No SourceStamp signature", 101);
            
            public const int SOURCE_STAMP_SIG_MISSING_CASE = 101;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue SOURCE_STAMP_MALFORMED_CERTIFICATE = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Malformed certificate: %1$s", 102);
            
            public const int SOURCE_STAMP_MALFORMED_CERTIFICATE_CASE = 102;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue SOURCE_STAMP_MALFORMED_SIGNATURE = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Malformed SourceStamp signature", 103);
            
            public const int SOURCE_STAMP_MALFORMED_SIGNATURE_CASE = 103;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue SOURCE_STAMP_UNKNOWN_SIG_ALGORITHM = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Unknown signature algorithm: %1$#x", 104);
            
            public const int SOURCE_STAMP_UNKNOWN_SIG_ALGORITHM_CASE = 104;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue SOURCE_STAMP_VERIFY_EXCEPTION = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Failed to verify %1$s signature: %2$s", 105);
            
            public const int SOURCE_STAMP_VERIFY_EXCEPTION_CASE = 105;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue SOURCE_STAMP_DID_NOT_VERIFY = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("%1$s signature over signed-data did not verify", 106);
            
            public const int SOURCE_STAMP_DID_NOT_VERIFY_CASE = 106;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue SOURCE_STAMP_NO_SIGNATURE = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("No signature", 107);
            
            public const int SOURCE_STAMP_NO_SIGNATURE_CASE = 107;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue SOURCE_STAMP_NO_SUPPORTED_SIGNATURE = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Signature(s) {%1$s} not supported: %2$s", 108);
            
            public const int SOURCE_STAMP_NO_SUPPORTED_SIGNATURE_CASE = 108;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue SOURCE_STAMP_CERTIFICATE_MISMATCH_BETWEEN_SIGNATURE_BLOCK_AND_APK = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Certificate mismatch between SourceStamp block in APK signing block and" + " SourceStamp file in APK: <%1$s> vs <%2$s>", 109);
            
            public const int SOURCE_STAMP_CERTIFICATE_MISMATCH_BETWEEN_SIGNATURE_BLOCK_AND_APK_CASE = 109;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue SOURCE_STAMP_SIGNATURE_BLOCK_WITHOUT_CERT_DIGEST = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("A source stamp signature block was found without a corresponding certificate " + "digest in the APK", 110);
            
            public const int SOURCE_STAMP_SIGNATURE_BLOCK_WITHOUT_CERT_DIGEST_CASE = 110;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue SOURCE_STAMP_EXPECTED_DIGEST_MISMATCH = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("The source stamp certificate digest in the APK, %1$s, does not match the " + "expected digest, %2$s", 111);
            
            public const int SOURCE_STAMP_EXPECTED_DIGEST_MISMATCH_CASE = 111;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue SOURCE_STAMP_MALFORMED_ATTRIBUTE = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Malformed stamp attribute #%1$d", 112);
            
            public const int SOURCE_STAMP_MALFORMED_ATTRIBUTE_CASE = 112;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue SOURCE_STAMP_UNKNOWN_ATTRIBUTE = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Unknown stamp attribute: ID %1$#x", 113);
            
            public const int SOURCE_STAMP_UNKNOWN_ATTRIBUTE_CASE = 113;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue SOURCE_STAMP_MALFORMED_LINEAGE = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Failed to parse the SigningCertificateLineage " + "structure in the source stamp attributes section.", 114);
            
            public const int SOURCE_STAMP_MALFORMED_LINEAGE_CASE = 114;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue SOURCE_STAMP_POR_CERT_MISMATCH = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("APK signing certificate differs from the associated certificate found in the " + "signer's SigningCertificateLineage.", 115);
            
            public const int SOURCE_STAMP_POR_CERT_MISMATCH_CASE = 115;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue SOURCE_STAMP_POR_DID_NOT_VERIFY = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Source stamp SigningCertificateLineage attribute " + "contains a proof-of-rotation record with signature(s) that did not verify.", 116);
            
            public const int SOURCE_STAMP_POR_DID_NOT_VERIFY_CASE = 116;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue MALFORMED_APK = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("Malformed APK; the following exception was caught when attempting to parse the " + "APK: %1$s", 117);
            
            public const int MALFORMED_APK_CASE = 117;
            
            public static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue UNEXPECTED_EXCEPTION = new SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue("An unexpected exception was caught when verifying the signature: %1$s", 118);
            
            public const int UNEXPECTED_EXCEPTION_CASE = 118;
            
            internal readonly string mFormat;
            
            internal Issue(string format, int caseValue)
            {
                mFormat = format;
                Case = caseValue;
            }
            
            /// <summary>
            /// Returns the format string suitable for combining the parameters of this issue into a
            /// readable string. See {@link java.util.Formatter} for format.
            /// </summary>
            internal string GetFormat()
            {
                return mFormat;
            }
            
            int Case
            {
                get;
            }
            
            internal static readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue[] _values = {
            JAR_SIG_NO_SIGNATURES, 
            JAR_SIG_NO_SIGNED_ZIP_ENTRIES, 
            JAR_SIG_DUPLICATE_ZIP_ENTRY, 
            JAR_SIG_DUPLICATE_MANIFEST_SECTION, 
            JAR_SIG_UNNNAMED_MANIFEST_SECTION, 
            JAR_SIG_UNNNAMED_SIG_FILE_SECTION, 
            JAR_SIG_NO_MANIFEST, 
            JAR_SIG_MISSING_ZIP_ENTRY_REFERENCED_IN_MANIFEST, 
            JAR_SIG_NO_ZIP_ENTRY_DIGEST_IN_MANIFEST, 
            JAR_SIG_NO_ZIP_ENTRY_DIGEST_IN_SIG_FILE, 
            JAR_SIG_ZIP_ENTRY_NOT_SIGNED, 
            JAR_SIG_ZIP_ENTRY_SIGNERS_MISMATCH, 
            JAR_SIG_ZIP_ENTRY_DIGEST_DID_NOT_VERIFY, 
            JAR_SIG_MANIFEST_MAIN_SECTION_DIGEST_DID_NOT_VERIFY, 
            JAR_SIG_MANIFEST_SECTION_DIGEST_DID_NOT_VERIFY, 
            JAR_SIG_NO_MANIFEST_DIGEST_IN_SIG_FILE, 
            JAR_SIG_NO_APK_SIG_STRIP_PROTECTION, 
            JAR_SIG_MISSING_FILE, 
            JAR_SIG_VERIFY_EXCEPTION, 
            JAR_SIG_UNSUPPORTED_SIG_ALG, 
            JAR_SIG_PARSE_EXCEPTION, 
            JAR_SIG_MALFORMED_CERTIFICATE, 
            JAR_SIG_DID_NOT_VERIFY, 
            JAR_SIG_NO_SIGNERS, 
            JAR_SIG_DUPLICATE_SIG_FILE_SECTION, 
            JAR_SIG_MISSING_VERSION_ATTR_IN_SIG_FILE, 
            JAR_SIG_UNKNOWN_APK_SIG_SCHEME_ID, 
            JAR_SIG_MISSING_APK_SIG_REFERENCED, 
            JAR_SIG_UNPROTECTED_ZIP_ENTRY, 
            JAR_SIG_MISSING, 
            NO_SIG_FOR_TARGET_SANDBOX_VERSION, 
            MIN_SIG_SCHEME_FOR_TARGET_SDK_NOT_MET, 
            V2_SIG_MISSING, 
            V2_SIG_MALFORMED_SIGNERS, 
            V2_SIG_MALFORMED_SIGNER, 
            V2_SIG_MALFORMED_PUBLIC_KEY, 
            V2_SIG_MALFORMED_CERTIFICATE, 
            V2_SIG_MALFORMED_SIGNATURE, 
            V2_SIG_MALFORMED_DIGEST, 
            V2_SIG_MALFORMED_ADDITIONAL_ATTRIBUTE, 
            V2_SIG_UNKNOWN_APK_SIG_SCHEME_ID, 
            V2_SIG_MISSING_APK_SIG_REFERENCED, 
            V2_SIG_NO_SIGNERS, 
            V2_SIG_UNKNOWN_SIG_ALGORITHM, 
            V2_SIG_UNKNOWN_ADDITIONAL_ATTRIBUTE, 
            V2_SIG_VERIFY_EXCEPTION, 
            V2_SIG_DID_NOT_VERIFY, 
            V2_SIG_NO_SIGNATURES, 
            V2_SIG_NO_SUPPORTED_SIGNATURES, 
            V2_SIG_NO_CERTIFICATES, 
            V2_SIG_PUBLIC_KEY_MISMATCH_BETWEEN_CERTIFICATE_AND_SIGNATURES_RECORD, 
            V2_SIG_SIG_ALG_MISMATCH_BETWEEN_SIGNATURES_AND_DIGESTS_RECORDS, 
            V2_SIG_APK_DIGEST_DID_NOT_VERIFY, 
            V3_SIG_MALFORMED_SIGNERS, 
            V3_SIG_MALFORMED_SIGNER, 
            V3_SIG_MALFORMED_PUBLIC_KEY, 
            V3_SIG_MALFORMED_CERTIFICATE, 
            V3_SIG_MALFORMED_SIGNATURE, 
            V3_SIG_MALFORMED_DIGEST, 
            V3_SIG_MALFORMED_ADDITIONAL_ATTRIBUTE, 
            V3_SIG_NO_SIGNERS, 
            V3_SIG_MULTIPLE_SIGNERS, 
            V3_SIG_MULTIPLE_PAST_SIGNERS, 
            V3_SIG_PAST_SIGNERS_MISMATCH, 
            V3_SIG_UNKNOWN_SIG_ALGORITHM, 
            V3_SIG_UNKNOWN_ADDITIONAL_ATTRIBUTE, 
            V3_SIG_VERIFY_EXCEPTION, 
            V3_SIG_INVALID_SDK_VERSIONS, 
            V3_SIG_DID_NOT_VERIFY, 
            V3_SIG_NO_SIGNATURES, 
            V3_SIG_NO_SUPPORTED_SIGNATURES, 
            V3_SIG_NO_CERTIFICATES, 
            V3_MIN_SDK_VERSION_MISMATCH_BETWEEN_SIGNER_AND_SIGNED_DATA_RECORD, 
            V3_MAX_SDK_VERSION_MISMATCH_BETWEEN_SIGNER_AND_SIGNED_DATA_RECORD, 
            V3_SIG_PUBLIC_KEY_MISMATCH_BETWEEN_CERTIFICATE_AND_SIGNATURES_RECORD, 
            V3_SIG_SIG_ALG_MISMATCH_BETWEEN_SIGNATURES_AND_DIGESTS_RECORDS, 
            V3_SIG_APK_DIGEST_DID_NOT_VERIFY, 
            V3_SIG_POR_DID_NOT_VERIFY, 
            V3_SIG_MALFORMED_LINEAGE, 
            V3_SIG_POR_CERT_MISMATCH, 
            V3_INCONSISTENT_SDK_VERSIONS, 
            V3_MISSING_SDK_VERSIONS, 
            V3_INCONSISTENT_LINEAGES, 
            APK_SIG_BLOCK_UNKNOWN_ENTRY_ID, 
            V4_SIG_MALFORMED_SIGNERS, 
            V4_SIG_UNKNOWN_SIG_ALGORITHM, 
            V4_SIG_NO_SIGNATURES, 
            V4_SIG_NO_SUPPORTED_SIGNATURES, 
            V4_SIG_DID_NOT_VERIFY, 
            V4_SIG_VERIFY_EXCEPTION, 
            V4_SIG_MALFORMED_PUBLIC_KEY, 
            V4_SIG_MALFORMED_CERTIFICATE, 
            V4_SIG_NO_CERTIFICATE, 
            V4_SIG_PUBLIC_KEY_MISMATCH_BETWEEN_CERTIFICATE_AND_SIGNATURES_RECORD, 
            V4_SIG_APK_ROOT_DID_NOT_VERIFY, 
            V4_SIG_APK_TREE_DID_NOT_VERIFY, 
            V4_SIG_MULTIPLE_SIGNERS, 
            V4_SIG_V2_V3_SIGNERS_MISMATCH, 
            V4_SIG_V2_V3_DIGESTS_MISMATCH, 
            V4_SIG_VERSION_NOT_CURRENT, 
            SOURCE_STAMP_CERT_DIGEST_AND_SIG_BLOCK_MISSING, 
            SOURCE_STAMP_SIG_MISSING, 
            SOURCE_STAMP_MALFORMED_CERTIFICATE, 
            SOURCE_STAMP_MALFORMED_SIGNATURE, 
            SOURCE_STAMP_UNKNOWN_SIG_ALGORITHM, 
            SOURCE_STAMP_VERIFY_EXCEPTION, 
            SOURCE_STAMP_DID_NOT_VERIFY, 
            SOURCE_STAMP_NO_SIGNATURE, 
            SOURCE_STAMP_NO_SUPPORTED_SIGNATURE, 
            SOURCE_STAMP_CERTIFICATE_MISMATCH_BETWEEN_SIGNATURE_BLOCK_AND_APK, 
            SOURCE_STAMP_SIGNATURE_BLOCK_WITHOUT_CERT_DIGEST, 
            SOURCE_STAMP_EXPECTED_DIGEST_MISMATCH, 
            SOURCE_STAMP_MALFORMED_ATTRIBUTE, 
            SOURCE_STAMP_UNKNOWN_ATTRIBUTE, 
            SOURCE_STAMP_MALFORMED_LINEAGE, 
            SOURCE_STAMP_POR_CERT_MISMATCH, 
            SOURCE_STAMP_POR_DID_NOT_VERIFY, 
            MALFORMED_APK, 
            UNEXPECTED_EXCEPTION};
            
            public static SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue[] Values()
            {
                return _values;
            }
            
        }
        
        /// <summary>
        /// {@link Issue} with associated parameters. {@link #toString()} produces a readable formatted
        /// form.
        /// </summary>
        public class IssueWithParams: SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue
        {
            internal readonly SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue mIssue;
            
            internal readonly object[] mParams;
            
            /// <summary>
            /// Constructs a new {@code IssueWithParams} of the specified type and with provided
            /// parameters.
            /// </summary>
            public IssueWithParams(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue issue, object[] parameters)
                : base (issue.mFormat, parameters)
            {
                ;
                mIssue = issue;
                mParams = parameters;
            }
            
            /// <summary>
            /// Returns the type of this issue.
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue GetIssue()
            {
                return mIssue;
            }
            
            /// <summary>
            /// Returns the parameters of this issue.
            /// </summary>
            public virtual object[] GetParams()
            {
                return (object[])mParams.Clone();
            }
            
            /// <summary>
            /// Returns a readable form of this issue.
            /// </summary>
            public override string ToString()
            {
                return SigningServer.Android.Core.StringExtensions.Format(mIssue.GetFormat(), mParams);
            }
            
        }
        
        /// <summary>
        /// Wrapped around {@code byte[]} which ensures that {@code equals} and {@code hashCode} operate
        /// on the contents of the arrays rather than on references.
        /// </summary>
        internal class ByteArray
        {
            internal readonly sbyte[] mArray;
            
            internal readonly int mHashCode;
            
            internal ByteArray(sbyte[] arr)
            {
                mArray = arr;
                mHashCode = SigningServer.Android.Collections.Arrays.GetHashCode(mArray);
            }
            
            public override int GetHashCode()
            {
                return mHashCode;
            }
            
            public override bool Equals(object obj)
            {
                if (this == obj)
                {
                    return true;
                }
                if (!(obj is SigningServer.Android.Com.Android.Apksig.ApkVerifier.ByteArray))
                {
                    return false;
                }
                SigningServer.Android.Com.Android.Apksig.ApkVerifier.ByteArray other = (SigningServer.Android.Com.Android.Apksig.ApkVerifier.ByteArray)obj;
                if (GetHashCode() != other.GetHashCode())
                {
                    return false;
                }
                if (!SigningServer.Android.Collections.Arrays.Equals(mArray, other.mArray))
                {
                    return false;
                }
                return true;
            }
            
        }
        
        /// <summary>
        /// Builder of {@link ApkVerifier} instances.
        /// 
        /// &lt;p&gt;The resulting verifier by default checks whether the APK will verify on all platform
        /// versions supported by the APK, as specified by {@code android:minSdkVersion} attributes in
        /// the APK's {@code AndroidManifest.xml}. The range of platform versions can be customized using
        /// {@link #setMinCheckedPlatformVersion(int)} and {@link #setMaxCheckedPlatformVersion(int)}.
        /// </summary>
        public class Builder
        {
            internal readonly System.IO.FileInfo mApkFile;
            
            internal readonly SigningServer.Android.Com.Android.Apksig.Util.DataSource mApkDataSource;
            
            internal System.IO.FileInfo mV4SignatureFile;
            
            internal int? mMinSdkVersion;
            
            internal int mMaxSdkVersion = SigningServer.Android.Core.IntExtensions.MAX_VALUE;
            
            /// <summary>
            /// Constructs a new {@code Builder} for verifying the provided APK file.
            /// </summary>
            public Builder(System.IO.FileInfo apk)
            {
                if (apk == null)
                {
                    throw new System.NullReferenceException("apk == null");
                }
                mApkFile = apk;
                mApkDataSource = null;
            }
            
            /// <summary>
            /// Constructs a new {@code Builder} for verifying the provided APK.
            /// </summary>
            public Builder(SigningServer.Android.Com.Android.Apksig.Util.DataSource apk)
            {
                if (apk == null)
                {
                    throw new System.NullReferenceException("apk == null");
                }
                mApkDataSource = apk;
                mApkFile = null;
            }
            
            /// <summary>
            /// Sets the oldest Android platform version for which the APK is verified. APK verification
            /// will confirm that the APK is expected to install successfully on all known Android
            /// platforms starting from the platform version with the provided API Level. The upper end
            /// of the platform versions range can be modified via
            /// {@link #setMaxCheckedPlatformVersion(int)}.
            /// 
            /// &lt;p&gt;This method is useful for overriding the default behavior which checks that the APK
            /// will verify on all platform versions supported by the APK, as specified by
            /// {@code android:minSdkVersion} attributes in the APK's {@code AndroidManifest.xml}.
            /// 
            /// @param minSdkVersion API Level of the oldest platform for which to verify the APK
            /// @see #setMinCheckedPlatformVersion(int)
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.ApkVerifier.Builder SetMinCheckedPlatformVersion(int minSdkVersion)
            {
                mMinSdkVersion = minSdkVersion;
                return this;
            }
            
            /// <summary>
            /// Sets the newest Android platform version for which the APK is verified. APK verification
            /// will confirm that the APK is expected to install successfully on all platform versions
            /// supported by the APK up until and including the provided version. The lower end
            /// of the platform versions range can be modified via
            /// {@link #setMinCheckedPlatformVersion(int)}.
            /// 
            /// @param maxSdkVersion API Level of the newest platform for which to verify the APK
            /// @see #setMinCheckedPlatformVersion(int)
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.ApkVerifier.Builder SetMaxCheckedPlatformVersion(int maxSdkVersion)
            {
                mMaxSdkVersion = maxSdkVersion;
                return this;
            }
            
            public virtual SigningServer.Android.Com.Android.Apksig.ApkVerifier.Builder SetV4SignatureFile(System.IO.FileInfo v4SignatureFile)
            {
                mV4SignatureFile = v4SignatureFile;
                return this;
            }
            
            /// <summary>
            /// Returns an {@link ApkVerifier} initialized according to the configuration of this
            /// builder.
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.ApkVerifier Build()
            {
                return new SigningServer.Android.Com.Android.Apksig.ApkVerifier(mApkFile, mApkDataSource, mV4SignatureFile, mMinSdkVersion, mMaxSdkVersion);
            }
            
        }
        
        /// <summary>
        /// Adapter for converting base {@link ApkVerificationIssue} instances to their {@link
        /// IssueWithParams} equivalent.
        /// </summary>
        public class ApkVerificationIssueAdapter
        {
            internal ApkVerificationIssueAdapter()
            {
            }
            
            public static readonly SigningServer.Android.Collections.Map<int?, SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue> sVerificationIssueIdToIssue = new SigningServer.Android.Collections.HashMap<int?, SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue>();
            
            /// <summary>
            /// Converts the provided {@code verificationIssues} to a {@code List} of corresponding
            /// {@link IssueWithParams} instances.
            /// </summary>
            public static SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> GetIssuesFromVerificationIssues(SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue> verificationIssues)
            {
                SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> result = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams>(verificationIssues.Size());
                foreach (SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue issue in verificationIssues)
                {
                    if (issue is SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams)
                    {
                        result.Add((SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams)issue);
                    }
                    else 
                    {
                        result.Add(new SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams(SigningServer.Android.Com.Android.Apksig.ApkVerifier.ApkVerificationIssueAdapter.sVerificationIssueIdToIssue.Get(issue.GetIssueId()), issue.GetParams()));
                    }
                }
                return result;
            }
            
        }
        
    }
    
}
