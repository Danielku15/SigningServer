// <auto-generated>
// This code was auto-generated.
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
// </auto-generated>

using System;

namespace SigningServer.Android.Com.Android.Apksig
{
    /// <summary>
    /// APK Signer Lineage.
    /// 
    /// &lt;p&gt;The signer lineage contains a history of signing certificates with each ancestor attesting to
    /// the validity of its descendant.  Each additional descendant represents a new identity that can be
    /// used to sign an APK, and each generation has accompanying attributes which represent how the
    /// APK would like to view the older signing certificates, specifically how they should be trusted in
    /// certain situations.
    /// 
    /// &lt;p&gt; Its primary use is to enable APK Signing Certificate Rotation.  The Android platform verifies
    /// the APK Signer Lineage, and if the current signing certificate for the APK is in the Signer
    /// Lineage, and the Lineage contains the certificate the platform associates with the APK, it will
    /// allow upgrades to the new certificate.
    /// 
    /// @see &lt;a href="https://source.android.com/security/apksigning/index.html"&gt;Application Signing&lt;/a&gt;
    /// </summary>
    public class SigningCertificateLineage
    {
        public static readonly int MAGIC = 0x3eff39d1;
        
        internal const int FIRST_VERSION = 1;
        
        internal static readonly int CURRENT_VERSION = SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.FIRST_VERSION;
        
        /// <summary>
        /// accept data from already installed pkg with this cert
        /// </summary>
        internal static readonly int PAST_CERT_INSTALLED_DATA = 1;
        
        /// <summary>
        /// accept sharedUserId with pkg with this cert
        /// </summary>
        internal static readonly int PAST_CERT_SHARED_USER_ID = 2;
        
        /// <summary>
        /// grant SIGNATURE permissions to pkgs with this cert
        /// </summary>
        internal static readonly int PAST_CERT_PERMISSION = 4;
        
        /// <summary>
        /// Enable updates back to this certificate.  WARNING: this effectively removes any benefit of
        /// signing certificate changes, since a compromised key could retake control of an app even
        /// after change, and should only be used if there is a problem encountered when trying to ditch
        /// an older cert.
        /// </summary>
        internal static readonly int PAST_CERT_ROLLBACK = 8;
        
        /// <summary>
        /// Preserve authenticator module-based access in AccountManager gated by signing certificate.
        /// </summary>
        internal static readonly int PAST_CERT_AUTH = 16;
        
        internal readonly int mMinSdkVersion;
        
        /// <summary>
        /// The signing lineage is just a list of nodes, with the first being the original signing
        /// certificate and the most recent being the one with which the APK is to actually be signed.
        /// </summary>
        internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.SigningCertificateNode> mSigningLineage;
        
        internal SigningCertificateLineage(int minSdkVersion, SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.SigningCertificateNode> list)
        {
            mMinSdkVersion = minSdkVersion;
            mSigningLineage = list;
        }
        
        internal static SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage CreateSigningLineage(int minSdkVersion, SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerConfig parent, SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerCapabilities parentCapabilities, SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerConfig child, SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerCapabilities childCapabilities)
        {
            SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage signingCertificateLineage = new SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage(minSdkVersion, new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.SigningCertificateNode>());
            signingCertificateLineage = signingCertificateLineage.SpawnFirstDescendant(parent, parentCapabilities);
            return signingCertificateLineage.SpawnDescendant(parent, child, childCapabilities);
        }
        
        public static SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage ReadFromBytes(byte[] lineageBytes)
        {
            return SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.ReadFromDataSource(SigningServer.Android.Com.Android.Apksig.Util.DataSources.AsDataSource(SigningServer.Android.IO.ByteBuffer.Wrap(lineageBytes)));
        }
        
        public static SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage ReadFromFile(System.IO.FileInfo file)
        {
            if (file == null)
            {
                throw new System.NullReferenceException("file == null");
            }
            SigningServer.Android.IO.RandomAccessFile inputFile = new SigningServer.Android.IO.RandomAccessFile(file, "r");
            return SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.ReadFromDataSource(SigningServer.Android.Com.Android.Apksig.Util.DataSources.AsDataSource(inputFile));
        }
        
        public static SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage ReadFromDataSource(SigningServer.Android.Com.Android.Apksig.Util.DataSource dataSource)
        {
            if (dataSource == null)
            {
                throw new System.NullReferenceException("dataSource == null");
            }
            SigningServer.Android.IO.ByteBuffer inBuff = dataSource.GetByteBuffer(0, (int)dataSource.Size());
            inBuff.Order(SigningServer.Android.IO.ByteOrder.LITTLE_ENDIAN);
            return SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.Read(inBuff);
        }
        
        /// <summary>
        /// Extracts a Signing Certificate Lineage from a v3 signer proof-of-rotation attribute.
        /// 
        /// &lt;note&gt;
        ///     this may not give a complete representation of an APK's signing certificate history,
        ///     since the APK may have multiple signers corresponding to different platform versions.
        ///     Use &lt;code&gt; readFromApkFile&lt;/code&gt; to handle this case.
        /// &lt;/note&gt;
        /// 
        /// @param attrValue
        /// </summary>
        public static SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage ReadFromV3AttributeValue(byte[] attrValue)
        {
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.SigningCertificateNode> parsedLineage = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.ReadSigningCertificateLineage(SigningServer.Android.IO.ByteBuffer.Wrap(attrValue).Order(SigningServer.Android.IO.ByteOrder.LITTLE_ENDIAN));
            int minSdkVersion = SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.CalculateMinSdkVersion(parsedLineage);
            return new SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage(minSdkVersion, parsedLineage);
        }
        
        /// <summary>
        /// Extracts a Signing Certificate Lineage from the proof-of-rotation attribute in the V3
        /// signature block of the provided APK File.
        /// 
        /// @throws IllegalArgumentException if the provided APK does not contain a V3 signature block,
        /// or if the V3 signature block does not contain a valid lineage.
        /// </summary>
        public static SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage ReadFromApkFile(System.IO.FileInfo apkFile)
        {
            using(SigningServer.Android.IO.RandomAccessFile f = new SigningServer.Android.IO.RandomAccessFile(apkFile, "r"))
            {
                SigningServer.Android.Com.Android.Apksig.Util.DataSource apk = SigningServer.Android.Com.Android.Apksig.Util.DataSources.AsDataSource(f, 0, f.Length());
                return SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.ReadFromApkDataSource(apk);
            }
        }
        
        /// <summary>
        /// Extracts a Signing Certificate Lineage from the proof-of-rotation attribute in the V3
        /// signature block of the provided APK DataSource.
        /// 
        /// @throws IllegalArgumentException if the provided APK does not contain a V3 signature block,
        /// or if the V3 signature block does not contain a valid lineage.
        /// </summary>
        public static SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage ReadFromApkDataSource(SigningServer.Android.Com.Android.Apksig.Util.DataSource apk)
        {
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureInfo signatureInfo;
            try
            {
                SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.ZipSections zipSections = SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.FindZipSections(apk);
                SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result signingBlockResult = new SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V3);
                signatureInfo = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.FindSignature(apk, zipSections, SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SchemeConstants.APK_SIGNATURE_SCHEME_V3_BLOCK_ID, signingBlockResult);
            }
            catch (SigningServer.Android.Com.Android.Apksig.Zip.ZipFormatException e)
            {
                throw new SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException(e.GetMessage());
            }
            catch (SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignatureNotFoundException e)
            {
                throw new System.ArgumentException("The provided APK does not contain a valid V3 signature block.");
            }
            SigningServer.Android.IO.ByteBuffer signers = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.GetLengthPrefixedSlice(signatureInfo.signatureBlock);
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage> lineages = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage>(1);
            while (signers.HasRemaining())
            {
                SigningServer.Android.IO.ByteBuffer signer = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.GetLengthPrefixedSlice(signers);
                SigningServer.Android.IO.ByteBuffer signedData = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.GetLengthPrefixedSlice(signer);
                try
                {
                    SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage lineage = SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.ReadFromSignedData(signedData);
                    lineages.Add(lineage);
                }
                catch (System.ArgumentException ignored)
                {
                }
            }
            SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage result;
            if (lineages.IsEmpty())
            {
                throw new System.ArgumentException("The provided APK does not contain a valid lineage.");
            }
            else if (lineages.Size() > 1)
            {
                result = SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.ConsolidateLineages(lineages);
            }
            else 
            {
                result = lineages.Get(0);
            }
            return result;
        }
        
        /// <summary>
        /// Extracts a Signing Certificate Lineage from the proof-of-rotation attribute in the provided
        /// signed data portion of a signer in a V3 signature block.
        /// 
        /// @throws IllegalArgumentException if the provided signed data does not contain a valid
        /// lineage.
        /// </summary>
        public static SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage ReadFromSignedData(SigningServer.Android.IO.ByteBuffer signedData)
        {
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.GetLengthPrefixedSlice(signedData);
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.GetLengthPrefixedSlice(signedData);
            signedData.GetInt();
            signedData.GetInt();
            SigningServer.Android.IO.ByteBuffer additionalAttributes = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.GetLengthPrefixedSlice(signedData);
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage> lineages = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage>(1);
            while (additionalAttributes.HasRemaining())
            {
                SigningServer.Android.IO.ByteBuffer attribute = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.GetLengthPrefixedSlice(additionalAttributes);
                int id = attribute.GetInt();
                if (id == SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SchemeConstants.PROOF_OF_ROTATION_ATTR_ID)
                {
                    byte[] value = SigningServer.Android.Com.Android.Apksig.Internal.Util.ByteBufferUtils.ToByteArray(attribute);
                    SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage lineage = SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.ReadFromV3AttributeValue(value);
                    lineages.Add(lineage);
                }
            }
            SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage result;
            if (lineages.IsEmpty())
            {
                throw new System.ArgumentException("The signed data does not contain a valid lineage.");
            }
            else if (lineages.Size() > 1)
            {
                result = SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.ConsolidateLineages(lineages);
            }
            else 
            {
                result = lineages.Get(0);
            }
            return result;
        }
        
        public virtual byte[] GetBytes()
        {
            return Write().Array();
        }
        
        public virtual void WriteToFile(System.IO.FileInfo file)
        {
            if (file == null)
            {
                throw new System.NullReferenceException("file == null");
            }

            using (SigningServer.Android.IO.RandomAccessFile outputFile =
                   new SigningServer.Android.IO.RandomAccessFile(file, "rw"))
            {
                WriteToDataSink(new SigningServer.Android.Com.Android.Apksig.Internal.Util.RandomAccessFileDataSink(outputFile));
            }
        }
        
        public virtual void WriteToDataSink(SigningServer.Android.Com.Android.Apksig.Util.DataSink dataSink)
        {
            if (dataSink == null)
            {
                throw new System.NullReferenceException("dataSink == null");
            }
            dataSink.Consume(Write());
        }
        
        /// <summary>
        /// Add a new signing certificate to the lineage.  This effectively creates a signing certificate
        /// rotation event, forcing APKs which include this lineage to be signed by the new signer. The
        /// flags associated with the new signer are set to a default value.
        /// 
        /// @param parent current signing certificate of the containing APK
        /// @param child new signing certificate which will sign the APK contents
        /// </summary>
        public virtual SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage SpawnDescendant(SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerConfig parent, SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerConfig child)
        {
            if (parent == null || child == null)
            {
                throw new System.NullReferenceException("can't add new descendant to lineage with null inputs");
            }
            SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerCapabilities signerCapabilities = new SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerCapabilities.Builder().Build();
            return SpawnDescendant(parent, child, signerCapabilities);
        }
        
        /// <summary>
        /// Add a new signing certificate to the lineage.  This effectively creates a signing certificate
        /// rotation event, forcing APKs which include this lineage to be signed by the new signer.
        /// 
        /// @param parent current signing certificate of the containing APK
        /// @param child new signing certificate which will sign the APK contents
        /// @param childCapabilities flags
        /// </summary>
        public virtual SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage SpawnDescendant(SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerConfig parent, SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerConfig child, SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerCapabilities childCapabilities)
        {
            if (parent == null)
            {
                throw new System.NullReferenceException("parent == null");
            }
            if (child == null)
            {
                throw new System.NullReferenceException("child == null");
            }
            if (childCapabilities == null)
            {
                throw new System.NullReferenceException("childCapabilities == null");
            }
            if (mSigningLineage.IsEmpty())
            {
                throw new System.ArgumentException("Cannot spawn descendant signing certificate on an" + " empty SigningCertificateLineage: no parent node");
            }
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.SigningCertificateNode currentGeneration = mSigningLineage.Get(mSigningLineage.Size() - 1);
            if (!SigningServer.Android.Collections.Arrays.Equals(currentGeneration.signingCert.GetEncoded(), parent.GetCertificate().GetEncoded()))
            {
                throw new System.ArgumentException("SignerConfig Certificate containing private key" + " to sign the new SigningCertificateLineage record does not match the" + " existing most recent record");
            }
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm signatureAlgorithm = GetSignatureAlgorithm(parent);
            SigningServer.Android.IO.ByteBuffer prefixedSignedData = SigningServer.Android.IO.ByteBuffer.Wrap(SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.EncodeSignedData(child.GetCertificate(), signatureAlgorithm.GetId()));
            prefixedSignedData.Position(4);
            SigningServer.Android.IO.ByteBuffer signedDataBuffer = SigningServer.Android.IO.ByteBuffer.Allocate(prefixedSignedData.Remaining());
            signedDataBuffer.Put(prefixedSignedData);
            byte[] signedData = signedDataBuffer.Array();
            SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> certificates = new SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate>(1);
            certificates.Add(parent.GetCertificate());
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignerConfig newSignerConfig = new SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignerConfig();
            newSignerConfig.privateKey = parent.GetPrivateKey();
            newSignerConfig.certificates = certificates;
            newSignerConfig.signatureAlgorithms = SigningServer.Android.Util.Collections.SingletonList<SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm>(signatureAlgorithm);
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<int, byte[]>> signatures = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.GenerateSignaturesOverData(newSignerConfig, signedData);
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm sigAlgorithm = SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm.FindById(signatures.Get(0).GetFirst());
            byte[] signature = signatures.Get(0).GetSecond();
            currentGeneration.sigAlgorithm = sigAlgorithm;
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.SigningCertificateNode childNode = new SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.SigningCertificateNode(child.GetCertificate(), sigAlgorithm, null, signature, childCapabilities.GetFlags());
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.SigningCertificateNode> lineageCopy = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.SigningCertificateNode>(mSigningLineage);
            lineageCopy.Add(childNode);
            return new SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage(mMinSdkVersion, lineageCopy);
        }
        
        /// <summary>
        /// The number of signing certificates in the lineage, including the current signer, which means
        /// this value can also be used to V2determine the number of signing certificate rotations by
        /// subtracting 1.
        /// </summary>
        public virtual int Size()
        {
            return mSigningLineage.Size();
        }
        
        internal SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm GetSignatureAlgorithm(SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerConfig parent)
        {
            SigningServer.Android.Security.PublicKey publicKey = parent.GetCertificate().GetPublicKey();
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm> algorithms = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SchemeSigner.GetSuggestedSignatureAlgorithms(publicKey, mMinSdkVersion, false, false);
            return algorithms.Get(0);
        }
        
        internal SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage SpawnFirstDescendant(SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerConfig parent, SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerCapabilities signerCapabilities)
        {
            if (!mSigningLineage.IsEmpty())
            {
                throw new System.InvalidOperationException("SigningCertificateLineage already has its first node");
            }
            try
            {
                GetSignatureAlgorithm(parent);
            }
            catch (SigningServer.Android.Security.InvalidKeyException e)
            {
                throw new System.ArgumentException("Algorithm associated with first signing certificate" + " invalid on desired platform versions", e);
            }
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.SigningCertificateNode firstNode = new SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.SigningCertificateNode(parent.GetCertificate(), null, null, new byte[0], signerCapabilities.GetFlags());
            return new SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage(mMinSdkVersion, SigningServer.Android.Util.Collections.SingletonList<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.SigningCertificateNode>(firstNode));
        }
        
        internal static SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage Read(SigningServer.Android.IO.ByteBuffer inputByteBuffer)
        {
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.CheckByteOrderLittleEndian(inputByteBuffer);
            if (inputByteBuffer.Remaining() < 8)
            {
                throw new System.ArgumentException("Improper SigningCertificateLineage format: insufficient data for header.");
            }
            if (inputByteBuffer.GetInt() != SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.MAGIC)
            {
                throw new System.ArgumentException("Improper SigningCertificateLineage format: MAGIC header mismatch.");
            }
            return SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.Read(inputByteBuffer, inputByteBuffer.GetInt());
        }
        
        internal static SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage Read(SigningServer.Android.IO.ByteBuffer inputByteBuffer, int version)
        {
            switch (version)
            {
                case SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.FIRST_VERSION:
                    try
                    {
                        SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.SigningCertificateNode> nodes = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.ReadSigningCertificateLineage(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.GetLengthPrefixedSlice(inputByteBuffer));
                        int minSdkVersion = SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.CalculateMinSdkVersion(nodes);
                        return new SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage(minSdkVersion, nodes);
                    }
                    catch (SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException e)
                    {
                        throw new global::System.IO.IOException("Unable to read list of signing certificate nodes in " + "SigningCertificateLineage", e);
                    }
                default:
                    throw new System.ArgumentException("Improper SigningCertificateLineage format: unrecognized version.");
            }
        }
        
        internal static int CalculateMinSdkVersion(SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.SigningCertificateNode> nodes)
        {
            if (nodes == null)
            {
                throw new System.ArgumentException("Can't calculate minimum SDK version of null nodes");
            }
            int minSdkVersion = SigningServer.Android.Com.Android.Apksig.Internal.Util.AndroidSdkVersion.P;
            foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.SigningCertificateNode node in nodes)
            {
                if (node.sigAlgorithm != null)
                {
                    int nodeMinSdkVersion = node.sigAlgorithm.GetMinSdkVersion();
                    if (nodeMinSdkVersion > minSdkVersion)
                    {
                        minSdkVersion = nodeMinSdkVersion;
                    }
                }
            }
            return minSdkVersion;
        }
        
        internal SigningServer.Android.IO.ByteBuffer Write()
        {
            byte[] encodedLineage = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.EncodeSigningCertificateLineage(mSigningLineage);
            int payloadSize = 4 + 4 + 4 + encodedLineage.Length;
            SigningServer.Android.IO.ByteBuffer result = SigningServer.Android.IO.ByteBuffer.Allocate(payloadSize);
            result.Order(SigningServer.Android.IO.ByteOrder.LITTLE_ENDIAN);
            result.PutInt(SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.MAGIC);
            result.PutInt(SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.CURRENT_VERSION);
            result.PutInt(encodedLineage.Length);
            result.Put(encodedLineage);
            result.Flip();
            return result;
        }
        
        public virtual byte[] EncodeSigningCertificateLineage()
        {
            return SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.EncodeSigningCertificateLineage(mSigningLineage);
        }
        
        public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.SignerConfig> SortSignerConfigs(SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.SignerConfig> signerConfigs)
        {
            if (signerConfigs == null)
            {
                throw new System.NullReferenceException("signerConfigs == null");
            }
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.SignerConfig> sortedSignerConfigs = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.SignerConfig>(signerConfigs.Size());
            for (int i = 0;i < mSigningLineage.Size();i++)
            {
                for (int j = 0;j < signerConfigs.Size();j++)
                {
                    SigningServer.Android.Com.Android.Apksig.DefaultApkSignerEngine.SignerConfig config = signerConfigs.Get(j);
                    if (mSigningLineage.Get(i).signingCert.Equals(config.GetCertificates().Get(0)))
                    {
                        sortedSignerConfigs.Add(config);
                        break;
                    }
                }
            }
            if (sortedSignerConfigs.Size() != signerConfigs.Size())
            {
                throw new System.ArgumentException("SignerConfigs supplied which are not present in the" + " SigningCertificateLineage");
            }
            return sortedSignerConfigs;
        }
        
        /// <summary>
        /// Returns the SignerCapabilities for the signer in the lineage that matches the provided
        /// config.
        /// </summary>
        public virtual SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerCapabilities GetSignerCapabilities(SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerConfig config)
        {
            if (config == null)
            {
                throw new System.NullReferenceException("config == null");
            }
            SigningServer.Android.Security.Cert.X509Certificate cert = config.GetCertificate();
            return GetSignerCapabilities(cert);
        }
        
        /// <summary>
        /// Returns the SignerCapabilities for the signer in the lineage that matches the provided
        /// certificate.
        /// </summary>
        public virtual SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerCapabilities GetSignerCapabilities(SigningServer.Android.Security.Cert.X509Certificate cert)
        {
            if (cert == null)
            {
                throw new System.NullReferenceException("cert == null");
            }
            for (int i = 0;i < mSigningLineage.Size();i++)
            {
                SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.SigningCertificateNode lineageNode = mSigningLineage.Get(i);
                if (lineageNode.signingCert.Equals(cert))
                {
                    int flags = lineageNode.flags;
                    return new SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerCapabilities.Builder(flags).Build();
                }
            }
            throw new System.ArgumentException("Certificate (" + cert.GetSubjectDN() + ") not found in the SigningCertificateLineage");
        }
        
        /// <summary>
        /// Updates the SignerCapabilities for the signer in the lineage that matches the provided
        /// config. Only those capabilities that have been modified through the setXX methods will be
        /// updated for the signer to prevent unset default values from being applied.
        /// </summary>
        public virtual void UpdateSignerCapabilities(SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerConfig config, SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerCapabilities capabilities)
        {
            if (config == null)
            {
                throw new System.NullReferenceException("config == null");
            }
            SigningServer.Android.Security.Cert.X509Certificate cert = config.GetCertificate();
            for (int i = 0;i < mSigningLineage.Size();i++)
            {
                SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.SigningCertificateNode lineageNode = mSigningLineage.Get(i);
                if (lineageNode.signingCert.Equals(cert))
                {
                    int flags = lineageNode.flags;
                    SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerCapabilities newCapabilities = new SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerCapabilities.Builder(flags).SetCallerConfiguredCapabilities(capabilities).Build();
                    lineageNode.flags = newCapabilities.GetFlags();
                    return;
                }
            }
            throw new System.ArgumentException("Certificate (" + cert.GetSubjectDN() + ") not found in the SigningCertificateLineage");
        }
        
        /// <summary>
        /// Returns a list containing all of the certificates in the lineage.
        /// </summary>
        public virtual SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> GetCertificatesInLineage()
        {
            SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> certs = new SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate>();
            for (int i = 0;i < mSigningLineage.Size();i++)
            {
                SigningServer.Android.Security.Cert.X509Certificate cert = mSigningLineage.Get(i).signingCert;
                certs.Add(cert);
            }
            return certs;
        }
        
        /// <summary>
        /// Returns {@code true} if the specified config is in the lineage.
        /// </summary>
        public virtual bool IsSignerInLineage(SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerConfig config)
        {
            if (config == null)
            {
                throw new System.NullReferenceException("config == null");
            }
            SigningServer.Android.Security.Cert.X509Certificate cert = config.GetCertificate();
            return IsCertificateInLineage(cert);
        }
        
        /// <summary>
        /// Returns {@code true} if the specified certificate is in the lineage.
        /// </summary>
        public virtual bool IsCertificateInLineage(SigningServer.Android.Security.Cert.X509Certificate cert)
        {
            if (cert == null)
            {
                throw new System.NullReferenceException("cert == null");
            }
            for (int i = 0;i < mSigningLineage.Size();i++)
            {
                if (mSigningLineage.Get(i).signingCert.Equals(cert))
                {
                    return true;
                }
            }
            return false;
        }
        
        internal static int CalculateDefaultFlags()
        {
            return SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.PAST_CERT_INSTALLED_DATA | SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.PAST_CERT_PERMISSION | SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.PAST_CERT_SHARED_USER_ID | SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.PAST_CERT_AUTH;
        }
        
        /// <summary>
        /// Returns a new SigingCertificateLineage which terminates at the node corresponding to the
        /// given certificate.  This is useful in the event of rotating to a new signing algorithm that
        /// is only supported on some platform versions.  It enables a v3 signature to be generated using
        /// this signing certificate and the shortened proof-of-rotation record from this sub lineage in
        /// conjunction with the appropriate SDK version values.
        /// 
        /// @param x509Certificate the signing certificate for which to search
        /// @return A new SigningCertificateLineage if the given certificate is present.
        /// @throws IllegalArgumentException if the provided certificate is not in the lineage.
        /// </summary>
        public virtual SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage GetSubLineage(SigningServer.Android.Security.Cert.X509Certificate x509Certificate)
        {
            if (x509Certificate == null)
            {
                throw new System.NullReferenceException("x509Certificate == null");
            }
            for (int i = 0;i < mSigningLineage.Size();i++)
            {
                if (mSigningLineage.Get(i).signingCert.Equals(x509Certificate))
                {
                    return new SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage(mMinSdkVersion, new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.SigningCertificateNode>(mSigningLineage.SubList(0, i + 1)));
                }
            }
            throw new System.ArgumentException("Certificate not found in SigningCertificateLineage");
        }
        
        /// <summary>
        /// Consolidates all of the lineages found in an APK into one lineage, which is the longest one.
        /// In so doing, it also checks that all of the smaller lineages are contained in the largest,
        /// and that they properly cover the desired platform ranges.
        /// 
        /// An APK may contain multiple lineages, one for each signer, which correspond to different
        /// supported platform versions.  In this event, the lineage(s) from the earlier platform
        /// version(s) need to be present in the most recent (longest) one to make sure that when a
        /// platform version changes.
        /// 
        /// &lt;note&gt; This does not verify that the largest lineage corresponds to the most recent supported
        /// platform version.  That check requires is performed during v3 verification. &lt;/note&gt;
        /// </summary>
        public static SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage ConsolidateLineages(SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage> lineages)
        {
            if (lineages == null || lineages.IsEmpty())
            {
                return null;
            }
            int largestIndex = 0;
            int maxSize = 0;
            for (int i = 0;i < lineages.Size();i++)
            {
                int curSize = lineages.Get(i).Size();
                if (curSize > maxSize)
                {
                    largestIndex = i;
                    maxSize = curSize;
                }
            }
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.SigningCertificateNode> largestList = lineages.Get(largestIndex).mSigningLineage;
            for (int i = 0;i < lineages.Size();i++)
            {
                if (i == largestIndex)
                {
                    continue;
                }
                SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.SigningCertificateNode> underTest = lineages.Get(i).mSigningLineage;
                if (!underTest.Equals(largestList.SubList(0, underTest.Size())))
                {
                    throw new System.ArgumentException("Inconsistent SigningCertificateLineages. " + "Not all lineages are subsets of each other.");
                }
            }
            return lineages.Get(largestIndex);
        }
        
        /// <summary>
        /// Representation of the capabilities the APK would like to grant to its old signing
        /// certificates.  The {@code SigningCertificateLineage} provides two conceptual data structures.
        ///   1) proof of rotation - Evidence that other parties can trust an APK's current signing
        ///      certificate if they trust an older one in this lineage
        ///   2) self-trust - certain capabilities may have been granted by an APK to other parties based
        ///      on its own signing certificate.  When it changes its signing certificate it may want to
        ///      allow the other parties to retain those capabilities.
        /// {@code SignerCapabilties} provides a representation of the second structure.
        /// 
        /// &lt;p&gt;Use {@link Builder} to obtain configuration instances.
        /// </summary>
        public class SignerCapabilities
        {
            internal readonly int mFlags;
            
            internal readonly int mCallerConfiguredFlags;
            
            internal SignerCapabilities(int flags)
                : this (flags, 0)
            {
                ;
            }
            
            internal SignerCapabilities(int flags, int callerConfiguredFlags)
            {
                mFlags = flags;
                mCallerConfiguredFlags = callerConfiguredFlags;
            }
            
            internal int GetFlags()
            {
                return mFlags;
            }
            
            /// <summary>
            /// Returns {@code true} if the capabilities of this object match those of the provided
            /// object.
            /// </summary>
            public virtual bool Equals(SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerCapabilities other)
            {
                return this.mFlags == other.mFlags;
            }
            
            /// <summary>
            /// Returns {@code true} if this object has the installed data capability.
            /// </summary>
            public virtual bool HasInstalledData()
            {
                return (mFlags & SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.PAST_CERT_INSTALLED_DATA) != 0;
            }
            
            /// <summary>
            /// Returns {@code true} if this object has the shared UID capability.
            /// </summary>
            public virtual bool HasSharedUid()
            {
                return (mFlags & SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.PAST_CERT_SHARED_USER_ID) != 0;
            }
            
            /// <summary>
            /// Returns {@code true} if this object has the permission capability.
            /// </summary>
            public virtual bool HasPermission()
            {
                return (mFlags & SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.PAST_CERT_PERMISSION) != 0;
            }
            
            /// <summary>
            /// Returns {@code true} if this object has the rollback capability.
            /// </summary>
            public virtual bool HasRollback()
            {
                return (mFlags & SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.PAST_CERT_ROLLBACK) != 0;
            }
            
            /// <summary>
            /// Returns {@code true} if this object has the auth capability.
            /// </summary>
            public virtual bool HasAuth()
            {
                return (mFlags & SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.PAST_CERT_AUTH) != 0;
            }
            
            /// <summary>
            /// Builder of {@link SignerCapabilities} instances.
            /// </summary>
            public class Builder
            {
                internal int mFlags;
                
                internal int mCallerConfiguredFlags;
                
                /// <summary>
                /// Constructs a new {@code Builder}.
                /// </summary>
                public Builder()
                {
                    mFlags = SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.CalculateDefaultFlags();
                }
                
                /// <summary>
                /// Constructs a new {@code Builder} with the initial capabilities set to the provided
                /// flags.
                /// </summary>
                public Builder(int flags)
                {
                    mFlags = flags;
                }
                
                /// <summary>
                /// Set the {@code PAST_CERT_INSTALLED_DATA} flag in this capabilities object.  This flag
                /// is used by the platform to determine if installed data associated with previous
                /// signing certificate should be trusted.  In particular, this capability is required to
                /// perform signing certificate rotation during an upgrade on-device.  Without it, the
                /// platform will not permit the app data from the old signing certificate to
                /// propagate to the new version.  Typically, this flag should be set to enable signing
                /// certificate rotation, and may be unset later when the app developer is satisfied that
                /// their install base is as migrated as it will be.
                /// </summary>
                public virtual SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerCapabilities.Builder SetInstalledData(bool enabled)
                {
                    mCallerConfiguredFlags |= SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.PAST_CERT_INSTALLED_DATA;
                    if (enabled)
                    {
                        mFlags |= SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.PAST_CERT_INSTALLED_DATA;
                    }
                    else 
                    {
                        mFlags &= ~SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.PAST_CERT_INSTALLED_DATA;
                    }
                    return this;
                }
                
                /// <summary>
                /// Set the {@code PAST_CERT_SHARED_USER_ID} flag in this capabilities object.  This flag
                /// is used by the platform to determine if this app is willing to be sharedUid with
                /// other apps which are still signed with the associated signing certificate.  This is
                /// useful in situations where sharedUserId apps would like to change their signing
                /// certificate, but can't guarantee the order of updates to those apps.
                /// </summary>
                public virtual SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerCapabilities.Builder SetSharedUid(bool enabled)
                {
                    mCallerConfiguredFlags |= SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.PAST_CERT_SHARED_USER_ID;
                    if (enabled)
                    {
                        mFlags |= SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.PAST_CERT_SHARED_USER_ID;
                    }
                    else 
                    {
                        mFlags &= ~SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.PAST_CERT_SHARED_USER_ID;
                    }
                    return this;
                }
                
                /// <summary>
                /// Set the {@code PAST_CERT_PERMISSION} flag in this capabilities object.  This flag
                /// is used by the platform to determine if this app is willing to grant SIGNATURE
                /// permissions to apps signed with the associated signing certificate.  Without this
                /// capability, an application signed with the older certificate will not be granted the
                /// SIGNATURE permissions defined by this app.  In addition, if multiple apps define the
                /// same SIGNATURE permission, the second one the platform sees will not be installable
                /// if this capability is not set and the signing certificates differ.
                /// </summary>
                public virtual SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerCapabilities.Builder SetPermission(bool enabled)
                {
                    mCallerConfiguredFlags |= SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.PAST_CERT_PERMISSION;
                    if (enabled)
                    {
                        mFlags |= SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.PAST_CERT_PERMISSION;
                    }
                    else 
                    {
                        mFlags &= ~SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.PAST_CERT_PERMISSION;
                    }
                    return this;
                }
                
                /// <summary>
                /// Set the {@code PAST_CERT_ROLLBACK} flag in this capabilities object.  This flag
                /// is used by the platform to determine if this app is willing to upgrade to a new
                /// version that is signed by one of its past signing certificates.
                /// 
                /// &lt;note&gt; WARNING: this effectively removes any benefit of signing certificate changes,
                /// since a compromised key could retake control of an app even after change, and should
                /// only be used if there is a problem encountered when trying to ditch an older cert
                /// &lt;/note&gt;
                /// </summary>
                public virtual SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerCapabilities.Builder SetRollback(bool enabled)
                {
                    mCallerConfiguredFlags |= SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.PAST_CERT_ROLLBACK;
                    if (enabled)
                    {
                        mFlags |= SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.PAST_CERT_ROLLBACK;
                    }
                    else 
                    {
                        mFlags &= ~SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.PAST_CERT_ROLLBACK;
                    }
                    return this;
                }
                
                /// <summary>
                /// Set the {@code PAST_CERT_AUTH} flag in this capabilities object.  This flag
                /// is used by the platform to determine whether or not privileged access based on
                /// authenticator module signing certificates should be granted.
                /// </summary>
                public virtual SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerCapabilities.Builder SetAuth(bool enabled)
                {
                    mCallerConfiguredFlags |= SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.PAST_CERT_AUTH;
                    if (enabled)
                    {
                        mFlags |= SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.PAST_CERT_AUTH;
                    }
                    else 
                    {
                        mFlags &= ~SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.PAST_CERT_AUTH;
                    }
                    return this;
                }
                
                /// <summary>
                /// Applies the capabilities that were explicitly set in the provided capabilities object
                /// to this builder. Any values that were not set will not be applied to this builder
                /// to prevent unintentinoally setting a capability back to a default value.
                /// </summary>
                public virtual SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerCapabilities.Builder SetCallerConfiguredCapabilities(SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerCapabilities capabilities)
                {
                    mFlags = (mFlags & ~capabilities.mCallerConfiguredFlags) | (capabilities.mFlags & capabilities.mCallerConfiguredFlags);
                    return this;
                }
                
                /// <summary>
                /// Returns a new {@code SignerConfig} instance configured based on the configuration of
                /// this builder.
                /// </summary>
                public virtual SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerCapabilities Build()
                {
                    return new SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerCapabilities(mFlags, mCallerConfiguredFlags);
                }
                
            }
            
        }
        
        /// <summary>
        /// Configuration of a signer.  Used to add a new entry to the {@link SigningCertificateLineage}
        /// 
        /// &lt;p&gt;Use {@link Builder} to obtain configuration instances.
        /// </summary>
        public class SignerConfig
        {
            internal readonly SigningServer.Android.Security.PrivateKey mPrivateKey;
            
            internal readonly SigningServer.Android.Security.Cert.X509Certificate mCertificate;
            
            internal SignerConfig(SigningServer.Android.Security.PrivateKey privateKey, SigningServer.Android.Security.Cert.X509Certificate certificate)
            {
                mPrivateKey = privateKey;
                mCertificate = certificate;
            }
            
            /// <summary>
            /// Returns the signing key of this signer.
            /// </summary>
            public virtual SigningServer.Android.Security.PrivateKey GetPrivateKey()
            {
                return mPrivateKey;
            }
            
            /// <summary>
            /// Returns the certificate(s) of this signer. The first certificate's public key corresponds
            /// to this signer's private key.
            /// </summary>
            public virtual SigningServer.Android.Security.Cert.X509Certificate GetCertificate()
            {
                return mCertificate;
            }
            
            /// <summary>
            /// Builder of {@link SignerConfig} instances.
            /// </summary>
            public class Builder
            {
                internal readonly SigningServer.Android.Security.PrivateKey mPrivateKey;
                
                internal readonly SigningServer.Android.Security.Cert.X509Certificate mCertificate;
                
                /// <summary>
                /// Constructs a new {@code Builder}.
                /// 
                /// @param privateKey signing key
                /// @param certificate the X.509 certificate with a subject public key of the
                /// {@code privateKey}.
                /// </summary>
                public Builder(SigningServer.Android.Security.PrivateKey privateKey, SigningServer.Android.Security.Cert.X509Certificate certificate)
                {
                    mPrivateKey = privateKey;
                    mCertificate = certificate;
                }
                
                /// <summary>
                /// Returns a new {@code SignerConfig} instance configured based on the configuration of
                /// this builder.
                /// </summary>
                public virtual SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerConfig Build()
                {
                    return new SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerConfig(mPrivateKey, mCertificate);
                }
                
            }
            
        }
        
        /// <summary>
        /// Builder of {@link SigningCertificateLineage} instances.
        /// </summary>
        public class Builder
        {
            internal readonly SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerConfig mOriginalSignerConfig;
            
            internal readonly SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerConfig mNewSignerConfig;
            
            internal SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerCapabilities mOriginalCapabilities;
            
            internal SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerCapabilities mNewCapabilities;
            
            internal int mMinSdkVersion;
            
            /// <summary>
            /// Constructs a new {@code Builder}.
            /// 
            /// @param originalSignerConfig first signer in this lineage, parent of the next
            /// @param newSignerConfig new signer in the lineage; the new signing key that the APK will
            ///                        use
            /// </summary>
            public Builder(SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerConfig originalSignerConfig, SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerConfig newSignerConfig)
            {
                if (originalSignerConfig == null || newSignerConfig == null)
                {
                    throw new System.NullReferenceException("Can't pass null SignerConfigs when constructing a " + "new SigningCertificateLineage");
                }
                mOriginalSignerConfig = originalSignerConfig;
                mNewSignerConfig = newSignerConfig;
            }
            
            /// <summary>
            /// Sets the minimum Android platform version (API Level) on which this lineage is expected
            /// to validate.  It is possible that newer signers in the lineage may not be recognized on
            /// the given platform, but as long as an older signer is, the lineage can still be used to
            /// sign an APK for the given platform.
            /// 
            /// &lt;note&gt; By default, this value is set to the value for the
            /// P release, since this structure was created for that release, and will also be set to
            /// that value if a smaller one is specified. &lt;/note&gt;
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.Builder SetMinSdkVersion(int minSdkVersion)
            {
                mMinSdkVersion = minSdkVersion;
                return this;
            }
            
            /// <summary>
            /// Sets capabilities to give {@code mOriginalSignerConfig}. These capabilities allow an
            /// older signing certificate to still be used in some situations on the platform even though
            /// the APK is now being signed by a newer signing certificate.
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.Builder SetOriginalCapabilities(SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerCapabilities signerCapabilities)
            {
                if (signerCapabilities == null)
                {
                    throw new System.NullReferenceException("signerCapabilities == null");
                }
                mOriginalCapabilities = signerCapabilities;
                return this;
            }
            
            /// <summary>
            /// Sets capabilities to give {@code mNewSignerConfig}. These capabilities allow an
            /// older signing certificate to still be used in some situations on the platform even though
            /// the APK is now being signed by a newer signing certificate.  By default, the new signer
            /// will have all capabilities, so when first switching to a new signing certificate, these
            /// capabilities have no effect, but they will act as the default level of trust when moving
            /// to a new signing certificate.
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.Builder SetNewCapabilities(SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerCapabilities signerCapabilities)
            {
                if (signerCapabilities == null)
                {
                    throw new System.NullReferenceException("signerCapabilities == null");
                }
                mNewCapabilities = signerCapabilities;
                return this;
            }
            
            public virtual SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage Build()
            {
                if (mMinSdkVersion < SigningServer.Android.Com.Android.Apksig.Internal.Util.AndroidSdkVersion.P)
                {
                    mMinSdkVersion = SigningServer.Android.Com.Android.Apksig.Internal.Util.AndroidSdkVersion.P;
                }
                if (mOriginalCapabilities == null)
                {
                    mOriginalCapabilities = new SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerCapabilities.Builder().Build();
                }
                if (mNewCapabilities == null)
                {
                    mNewCapabilities = new SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.SignerCapabilities.Builder().Build();
                }
                return SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage.CreateSigningLineage(mMinSdkVersion, mOriginalSignerConfig, mOriginalCapabilities, mNewSignerConfig, mNewCapabilities);
            }
            
        }
        
    }
    
}
