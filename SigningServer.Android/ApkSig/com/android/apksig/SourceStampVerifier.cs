// <auto-generated>
// This code was auto-generated.
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
// </auto-generated>

using System;

namespace SigningServer.Android.Com.Android.Apksig
{
    /// <summary>
    /// APK source stamp verifier intended only to verify the validity of the stamp signature.
    /// 
    /// &lt;p&gt;Note, this verifier does not validate the signatures of the jar signing / APK signature blocks
    /// when obtaining the digests for verification. This verifier should only be used in cases where
    /// another mechanism has already been used to verify the APK signatures.
    /// </summary>
    public class SourceStampVerifier
    {
        internal readonly System.IO.FileInfo mApkFile;
        
        internal readonly SigningServer.Android.Com.Android.Apksig.Util.DataSource mApkDataSource;
        
        internal readonly int mMinSdkVersion;
        
        internal readonly int mMaxSdkVersion;
        
        internal SourceStampVerifier(System.IO.FileInfo apkFile, SigningServer.Android.Com.Android.Apksig.Util.DataSource apkDataSource, int minSdkVersion, int maxSdkVersion)
        {
            mApkFile = apkFile;
            mApkDataSource = apkDataSource;
            mMinSdkVersion = minSdkVersion;
            mMaxSdkVersion = maxSdkVersion;
        }
        
        /// <summary>
        /// Verifies the APK's source stamp signature and returns the result of the verification.
        /// 
        /// &lt;p&gt;The APK's source stamp can be considered verified if the result's {@link
        /// Result#isVerified()} returns {@code true}. If source stamp verification fails all of the
        /// resulting errors can be obtained from {@link Result#getAllErrors()}, or individual errors
        /// can be obtained as follows:
        /// &lt;ul&gt;
        ///     &lt;li&gt;Obtain the generic errors via {@link Result#getErrors()}
        ///     &lt;li&gt;Obtain the V2 signers via {@link Result#getV2SchemeSigners()}, then for each signer
        ///     query for any errors with {@link Result.SignerInfo#getErrors()}
        ///     &lt;li&gt;Obtain the V3 signers via {@link Result#getV3SchemeSigners()}, then for each signer
        ///     query for any errors with {@link Result.SignerInfo#getErrors()}
        ///     &lt;li&gt;Obtain the source stamp signer via {@link Result#getSourceStampInfo()}, then query
        ///     for any stamp errors with {@link Result.SourceStampInfo#getErrors()}
        /// &lt;/ul&gt;
        /// </summary>
        public virtual SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result VerifySourceStamp()
        {
            return VerifySourceStamp(null);
        }
        
        /// <summary>
        /// Verifies the APK's source stamp signature, including verification that the SHA-256 digest of
        /// the stamp signing certificate matches the {@code expectedCertDigest}, and returns the result
        /// of the verification.
        /// 
        /// &lt;p&gt;A value of {@code null} for the {@code expectedCertDigest} will verify the source stamp,
        /// if present, without verifying the actual source stamp certificate used to sign the source
        /// stamp. This can be used to verify an APK contains a properly signed source stamp without
        /// verifying a particular signer.
        /// 
        /// @see #verifySourceStamp()
        /// </summary>
        public virtual SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result VerifySourceStamp(string expectedCertDigest)
        {
            System.IDisposable input = null;
            try
            {
                SigningServer.Android.Com.Android.Apksig.Util.DataSource apk;
                if (mApkDataSource != null)
                {
                    apk = mApkDataSource;
                }
                else if (mApkFile != null)
                {
                    SigningServer.Android.IO.RandomAccessFile f = new SigningServer.Android.IO.RandomAccessFile(mApkFile, "r");
                    input = f;
                    apk = SigningServer.Android.Com.Android.Apksig.Util.DataSources.AsDataSource(f, 0, f.Length());
                }
                else 
                {
                    throw new System.InvalidOperationException("APK not provided");
                }
                return VerifySourceStamp(apk, expectedCertDigest);
            }
            catch (SigningServer.Android.IO.IOException e)
            {
                SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result result = new SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result();
                result.AddVerificationError(SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue.UNEXPECTED_EXCEPTION, e);
                return result;
            }
            finally
            {
                if (input != null)
                {
                    try
                    {
                        input.Dispose();
                    }
                    catch (SigningServer.Android.IO.IOException ignored)
                    {
                    }
                }
            }
        }
        
        /// <summary>
        /// Verifies the provided {@code apk}'s source stamp signature, including verification of the
        /// SHA-256 digest of the stamp signing certificate matches the {@code expectedCertDigest}, and
        /// returns the result of the verification.
        /// 
        /// @see #verifySourceStamp(String)
        /// </summary>
        internal SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result VerifySourceStamp(SigningServer.Android.Com.Android.Apksig.Util.DataSource apk, string expectedCertDigest)
        {
            SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result result = new SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result();
            try
            {
                SigningServer.Android.Com.Android.Apksig.Zip.ZipSections zipSections = SigningServer.Android.Com.Android.Apksig.Apk.ApkUtilsLite.FindZipSections(apk);
                SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord> cdRecords = SigningServer.Android.Com.Android.Apksig.Internal.Zip.ZipUtils.ParseZipCentralDirectory(apk, zipSections);
                SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord sourceStampCdRecord = null;
                foreach (SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord cdRecord in cdRecords)
                {
                    if (SigningServer.Android.Com.Android.Apksig.Internal.Apk.Stamp.SourceStampConstants.SOURCE_STAMP_CERTIFICATE_HASH_ZIP_ENTRY_NAME.Equals(cdRecord.GetName()))
                    {
                        sourceStampCdRecord = cdRecord;
                        break;
                    }
                }
                if (sourceStampCdRecord == null)
                {
                    bool stampSigningBlockFound;
                    try
                    {
                        SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtilsLite.FindSignature(apk, zipSections, SigningServer.Android.Com.Android.Apksig.Internal.Apk.Stamp.SourceStampConstants.V2_SOURCE_STAMP_BLOCK_ID);
                        stampSigningBlockFound = true;
                    }
                    catch (SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureNotFoundException e)
                    {
                        stampSigningBlockFound = false;
                    }
                    result.AddVerificationError(stampSigningBlockFound ? SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue.SOURCE_STAMP_SIGNATURE_BLOCK_WITHOUT_CERT_DIGEST : SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue.SOURCE_STAMP_CERT_DIGEST_AND_SIG_BLOCK_MISSING);
                    return result;
                }
                sbyte[] sourceStampCertificateDigest = SigningServer.Android.Com.Android.Apksig.Internal.Zip.LocalFileRecord.GetUncompressedData(apk, sourceStampCdRecord, zipSections.GetZipCentralDirectoryOffset());
                if (expectedCertDigest != null)
                {
                    string actualCertDigest = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtilsLite.ToHex(sourceStampCertificateDigest);
                    if (!expectedCertDigest.EqualsIgnoreCase(actualCertDigest))
                    {
                        result.AddVerificationError(SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue.SOURCE_STAMP_EXPECTED_DIGEST_MISMATCH, actualCertDigest, expectedCertDigest);
                        return result;
                    }
                }
                SigningServer.Android.Collections.Map<int, SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]>> signatureSchemeApkContentDigests = new SigningServer.Android.Collections.HashMap<int, SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]>>();
                if (mMaxSdkVersion >= SigningServer.Android.Com.Android.Apksig.Internal.Util.AndroidSdkVersion.P)
                {
                    SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureInfo signatureInfo;
                    try
                    {
                        signatureInfo = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtilsLite.FindSignature(apk, zipSections, SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SchemeConstants.APK_SIGNATURE_SCHEME_V3_BLOCK_ID);
                    }
                    catch (SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureNotFoundException e)
                    {
                        signatureInfo = null;
                    }
                    if (signatureInfo != null)
                    {
                        SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]> apkContentDigests = new SigningServer.Android.Collections.EnumMap<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]>(typeof(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm));
                        SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.ParseSigners(signatureInfo.signatureBlock, SigningServer.Android.Com.Android.Apksig.Constants.VERSION_APK_SIGNATURE_SCHEME_V3, apkContentDigests, result);
                        signatureSchemeApkContentDigests.Put(SigningServer.Android.Com.Android.Apksig.Constants.VERSION_APK_SIGNATURE_SCHEME_V3, apkContentDigests);
                    }
                }
                if (mMaxSdkVersion >= SigningServer.Android.Com.Android.Apksig.Internal.Util.AndroidSdkVersion.N && (mMinSdkVersion < SigningServer.Android.Com.Android.Apksig.Internal.Util.AndroidSdkVersion.P || signatureSchemeApkContentDigests.IsEmpty()))
                {
                    SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureInfo signatureInfo;
                    try
                    {
                        signatureInfo = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtilsLite.FindSignature(apk, zipSections, SigningServer.Android.Com.Android.Apksig.Internal.Apk.V2.V2SchemeConstants.APK_SIGNATURE_SCHEME_V2_BLOCK_ID);
                    }
                    catch (SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureNotFoundException e)
                    {
                        signatureInfo = null;
                    }
                    if (signatureInfo != null)
                    {
                        SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]> apkContentDigests = new SigningServer.Android.Collections.EnumMap<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]>(typeof(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm));
                        SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.ParseSigners(signatureInfo.signatureBlock, SigningServer.Android.Com.Android.Apksig.Constants.VERSION_APK_SIGNATURE_SCHEME_V2, apkContentDigests, result);
                        signatureSchemeApkContentDigests.Put(SigningServer.Android.Com.Android.Apksig.Constants.VERSION_APK_SIGNATURE_SCHEME_V2, apkContentDigests);
                    }
                }
                if (mMinSdkVersion < SigningServer.Android.Com.Android.Apksig.Internal.Util.AndroidSdkVersion.N || signatureSchemeApkContentDigests.IsEmpty())
                {
                    SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]> apkContentDigests = SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.GetApkContentDigestFromV1SigningScheme(cdRecords, apk, zipSections, result);
                    signatureSchemeApkContentDigests.Put(SigningServer.Android.Com.Android.Apksig.Constants.VERSION_JAR_SIGNATURE_SCHEME, apkContentDigests);
                }
                SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigResult sourceStampResult = SigningServer.Android.Com.Android.Apksig.Internal.Apk.Stamp.V2SourceStampVerifier.Verify(
                    apk
                    , 
                    zipSections
                    , 
                    sourceStampCertificateDigest
                    , 
                    signatureSchemeApkContentDigests
                    , 
                    mMinSdkVersion
                    , 
                    mMaxSdkVersion
                
                );
                result.MergeFrom(sourceStampResult);
                return result;
            }
            catch (System.Exception e) when ( e is SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException || e is SigningServer.Android.IO.IOException || e is SigningServer.Android.Com.Android.Apksig.Zip.ZipFormatException)
            {
                result.AddVerificationError(SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue.MALFORMED_APK, e);
            }
            catch (SigningServer.Android.Security.NoSuchAlgorithmException e)
            {
                result.AddVerificationError(SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue.UNEXPECTED_EXCEPTION, e);
            }
            catch (SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureNotFoundException e)
            {
                result.AddVerificationError(SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue.SOURCE_STAMP_SIG_MISSING);
            }
            return result;
        }
        
        /// <summary>
        /// Parses each signer in the provided APK V2 / V3 signature block and populates corresponding
        /// {@code SignerInfo} of the provided {@code result} and their {@code apkContentDigests}.
        /// 
        /// &lt;p&gt;This method adds one or more errors to the {@code result} if a verification error is
        /// expected to be encountered on an Android platform version in the
        /// {@code [minSdkVersion, maxSdkVersion]} range.
        /// </summary>
        public static void ParseSigners(SigningServer.Android.IO.ByteBuffer apkSignatureSchemeBlock, int apkSigSchemeVersion, SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]> apkContentDigests, SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result result)
        {
            bool isV2Block = apkSigSchemeVersion == SigningServer.Android.Com.Android.Apksig.Constants.VERSION_APK_SIGNATURE_SCHEME_V2;
            SigningServer.Android.IO.ByteBuffer signers;
            try
            {
                signers = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtilsLite.GetLengthPrefixedSlice(apkSignatureSchemeBlock);
            }
            catch (SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException e)
            {
                result.AddVerificationWarning(isV2Block ? SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue.V2_SIG_MALFORMED_SIGNERS : SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue.V3_SIG_MALFORMED_SIGNERS);
                return;
            }
            if (!signers.HasRemaining())
            {
                result.AddVerificationWarning(isV2Block ? SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue.V2_SIG_NO_SIGNERS : SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue.V3_SIG_NO_SIGNERS);
                return;
            }
            SigningServer.Android.Security.Cert.CertificateFactory certFactory;
            try
            {
                certFactory = SigningServer.Android.Security.Cert.CertificateFactory.GetInstance("X.509");
            }
            catch (SigningServer.Android.Security.Cert.CertificateException e)
            {
                throw new SigningServer.Android.Core.RuntimeException("Failed to obtain X.509 CertificateFactory", e);
            }
            while (signers.HasRemaining())
            {
                SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result.SignerInfo signerInfo = new SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result.SignerInfo();
                if (isV2Block)
                {
                    result.AddV2Signer(signerInfo);
                }
                else 
                {
                    result.AddV3Signer(signerInfo);
                }
                try
                {
                    SigningServer.Android.IO.ByteBuffer signer = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtilsLite.GetLengthPrefixedSlice(signers);
                    SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.ParseSigner(signer, apkSigSchemeVersion, certFactory, apkContentDigests, signerInfo);
                }
                catch (System.Exception e) when ( e is SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException || e is SigningServer.Android.IO.BufferUnderflowException)
                {
                    signerInfo.AddVerificationWarning(isV2Block ? SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue.V2_SIG_MALFORMED_SIGNER : SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue.V3_SIG_MALFORMED_SIGNER);
                    return;
                }
            }
        }
        
        /// <summary>
        /// Parses the provided signer block and populates the {@code result}.
        /// 
        /// &lt;p&gt;This verifies signatures over {@code signed-data} contained in this block but does not
        /// verify the integrity of the rest of the APK. To facilitate APK integrity verification, this
        /// method adds the {@code contentDigestsToVerify}. These digests can then be used to verify the
        /// integrity of the APK.
        /// 
        /// &lt;p&gt;This method adds one or more errors to the {@code result} if a verification error is
        /// expected to be encountered on an Android platform version in the
        /// {@code [minSdkVersion, maxSdkVersion]} range.
        /// </summary>
        internal static void ParseSigner(SigningServer.Android.IO.ByteBuffer signerBlock, int apkSigSchemeVersion, SigningServer.Android.Security.Cert.CertificateFactory certFactory, SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]> apkContentDigests, SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result.SignerInfo signerInfo)
        {
            bool isV2Signer = apkSigSchemeVersion == SigningServer.Android.Com.Android.Apksig.Constants.VERSION_APK_SIGNATURE_SCHEME_V2;
            SigningServer.Android.IO.ByteBuffer signedData = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtilsLite.GetLengthPrefixedSlice(signerBlock);
            SigningServer.Android.IO.ByteBuffer digests = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtilsLite.GetLengthPrefixedSlice(signedData);
            SigningServer.Android.IO.ByteBuffer certificates = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtilsLite.GetLengthPrefixedSlice(signedData);
            while (digests.HasRemaining())
            {
                try
                {
                    SigningServer.Android.IO.ByteBuffer digest = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtilsLite.GetLengthPrefixedSlice(digests);
                    int sigAlgorithmId = digest.GetInt();
                    sbyte[] digestBytes = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtilsLite.ReadLengthPrefixedByteArray(digest);
                    SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm signatureAlgorithm = SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm.FindById(sigAlgorithmId);
                    if (signatureAlgorithm == null)
                    {
                        continue;
                    }
                    apkContentDigests.Put(signatureAlgorithm.GetContentDigestAlgorithm(), digestBytes);
                }
                catch (System.Exception e) when ( e is SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException || e is SigningServer.Android.IO.BufferUnderflowException)
                {
                    signerInfo.AddVerificationWarning(isV2Signer ? SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue.V2_SIG_MALFORMED_DIGEST : SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue.V3_SIG_MALFORMED_DIGEST);
                    return;
                }
            }
            if (certificates.HasRemaining())
            {
                sbyte[] encodedCert = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtilsLite.ReadLengthPrefixedByteArray(certificates);
                SigningServer.Android.Security.Cert.X509Certificate certificate;
                try
                {
                    certificate = (SigningServer.Android.Security.Cert.X509Certificate)certFactory.GenerateCertificate(new SigningServer.Android.IO.ByteArrayInputStream(encodedCert));
                }
                catch (SigningServer.Android.Security.Cert.CertificateException e)
                {
                    signerInfo.AddVerificationWarning(isV2Signer ? SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue.V2_SIG_MALFORMED_CERTIFICATE : SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue.V3_SIG_MALFORMED_CERTIFICATE);
                    return;
                }
                certificate = new SigningServer.Android.Com.Android.Apksig.Internal.Util.GuaranteedEncodedFormX509Certificate(certificate, encodedCert);
                signerInfo.SetSigningCertificate(certificate);
            }
            if (signerInfo.GetSigningCertificate() == null)
            {
                signerInfo.AddVerificationWarning(isV2Signer ? SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue.V2_SIG_NO_CERTIFICATES : SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue.V3_SIG_NO_CERTIFICATES);
                return;
            }
        }
        
        /// <summary>
        /// Returns a mapping of the {@link ContentDigestAlgorithm} to the {@code byte[]} digest of the
        /// V1 / jar signing META-INF/MANIFEST.MF; if this file is not found then an empty {@code Map} is
        /// returned.
        /// 
        /// &lt;p&gt;If any errors are encountered while parsing the V1 signers the provided {@code result}
        /// will be updated to include a warning, but the source stamp verification can still proceed.
        /// </summary>
        internal static SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]> GetApkContentDigestFromV1SigningScheme(SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord> cdRecords, SigningServer.Android.Com.Android.Apksig.Util.DataSource apk, SigningServer.Android.Com.Android.Apksig.Zip.ZipSections zipSections, SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result result)
        {
            SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord manifestCdRecord = null;
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord> signatureBlockRecords = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord>(1);
            SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]> v1ContentDigest = new SigningServer.Android.Collections.EnumMap<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]>(typeof(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm));
            foreach (SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord cdRecord in cdRecords)
            {
                string cdRecordName = cdRecord.GetName();
                if (cdRecordName == null)
                {
                    continue;
                }
                if (manifestCdRecord == null && SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeConstants.MANIFEST_ENTRY_NAME.Equals(cdRecordName))
                {
                    manifestCdRecord = cdRecord;
                    continue;
                }
                if (cdRecordName.StartsWith("META-INF/") && (cdRecordName.EndsWith(".RSA") || cdRecordName.EndsWith(".DSA") || cdRecordName.EndsWith(".EC")))
                {
                    signatureBlockRecords.Add(cdRecord);
                }
            }
            if (manifestCdRecord == null)
            {
                return v1ContentDigest;
            }
            if (signatureBlockRecords.IsEmpty())
            {
                result.AddVerificationWarning(SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue.JAR_SIG_NO_SIGNATURES);
            }
            else 
            {
                foreach (SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord signatureBlockRecord in signatureBlockRecords)
                {
                    try
                    {
                        SigningServer.Android.Security.Cert.CertificateFactory certFactory = SigningServer.Android.Security.Cert.CertificateFactory.GetInstance("X.509");
                        sbyte[] signatureBlockBytes = SigningServer.Android.Com.Android.Apksig.Internal.Zip.LocalFileRecord.GetUncompressedData(apk, signatureBlockRecord, zipSections.GetZipCentralDirectoryOffset());
                        foreach (SigningServer.Android.Security.Cert.Certificate certificate in certFactory.GenerateCertificates(new SigningServer.Android.IO.ByteArrayInputStream(signatureBlockBytes)))
                        {
                            if (certificate is SigningServer.Android.Security.Cert.X509Certificate)
                            {
                                SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result.SignerInfo signerInfo = new SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result.SignerInfo();
                                signerInfo.SetSigningCertificate((SigningServer.Android.Security.Cert.X509Certificate)certificate);
                                result.AddV1Signer(signerInfo);
                                break;
                            }
                        }
                    }
                    catch (SigningServer.Android.Security.Cert.CertificateException e)
                    {
                        result.AddVerificationWarning(SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue.JAR_SIG_PARSE_EXCEPTION, signatureBlockRecord.GetName(), e);
                        break;
                    }
                    catch (SigningServer.Android.Com.Android.Apksig.Zip.ZipFormatException e)
                    {
                        throw new SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException("Failed to read APK", e);
                    }
                }
            }
            try
            {
                sbyte[] manifestBytes = SigningServer.Android.Com.Android.Apksig.Internal.Zip.LocalFileRecord.GetUncompressedData(apk, manifestCdRecord, zipSections.GetZipCentralDirectoryOffset());
                v1ContentDigest.Put(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm.SHA256, SigningServer.Android.Com.Android.Apksig.Apk.ApkUtilsLite.ComputeSha256DigestBytes(manifestBytes));
                return v1ContentDigest;
            }
            catch (SigningServer.Android.Com.Android.Apksig.Zip.ZipFormatException e)
            {
                throw new SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException("Failed to read APK", e);
            }
        }
        
        /// <summary>
        /// Result of verifying the APK's source stamp signature; this signature can only be considered
        /// verified if {@link #isVerified()} returns true.
        /// </summary>
        public class Result
        {
            internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result.SignerInfo> mV1SchemeSigners = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result.SignerInfo>();
            
            internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result.SignerInfo> mV2SchemeSigners = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result.SignerInfo>();
            
            internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result.SignerInfo> mV3SchemeSigners = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result.SignerInfo>();
            
            internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result.SignerInfo>> mAllSchemeSigners;
            
            internal SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result.SourceStampInfo mSourceStampInfo;
            
            internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue> mErrors = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue>();
            
            internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue> mWarnings = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue>();
            
            internal bool mVerified;

            public Result()
            {
                mAllSchemeSigners = SigningServer.Android.Collections.Arrays.AsList(mV1SchemeSigners, mV2SchemeSigners, mV3SchemeSigners);
            }

            public virtual void AddVerificationError(int errorId, params object[] parameters)
            {
                mErrors.Add(new SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue(errorId, parameters));
            }
            
            public virtual void AddVerificationWarning(int warningId, params object[] parameters)
            {
                mWarnings.Add(new SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue(warningId, parameters));
            }
            
            internal void AddV1Signer(SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result.SignerInfo signerInfo)
            {
                mV1SchemeSigners.Add(signerInfo);
            }
            
            internal void AddV2Signer(SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result.SignerInfo signerInfo)
            {
                mV2SchemeSigners.Add(signerInfo);
            }
            
            internal void AddV3Signer(SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result.SignerInfo signerInfo)
            {
                mV3SchemeSigners.Add(signerInfo);
            }
            
            /// <summary>
            /// Returns {@code true} if the APK's source stamp signature
            /// </summary>
            public virtual bool IsVerified()
            {
                return mVerified;
            }
            
            internal void MergeFrom(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigResult source)
            {
                switch (source.signatureSchemeVersion)
                {
                    case SigningServer.Android.Com.Android.Apksig.Constants.VERSION_SOURCE_STAMP:
                        mVerified = source.verified;
                        if (!source.mSigners.IsEmpty())
                        {
                            mSourceStampInfo = new SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result.SourceStampInfo(source.mSigners.Get(0));
                        }
                        break;
                    default:
                        throw new System.ArgumentException("Unknown ApkSigResult Signing Block Scheme Id " + source.signatureSchemeVersion);
                }
            }
            
            /// <summary>
            /// Returns a {@code List} of {@link SignerInfo} objects representing the V1 signers of the
            /// provided APK.
            /// </summary>
            public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result.SignerInfo> GetV1SchemeSigners()
            {
                return mV1SchemeSigners;
            }
            
            /// <summary>
            /// Returns a {@code List} of {@link SignerInfo} objects representing the V2 signers of the
            /// provided APK.
            /// </summary>
            public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result.SignerInfo> GetV2SchemeSigners()
            {
                return mV2SchemeSigners;
            }
            
            /// <summary>
            /// Returns a {@code List} of {@link SignerInfo} objects representing the V3 signers of the
            /// provided APK.
            /// </summary>
            public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result.SignerInfo> GetV3SchemeSigners()
            {
                return mV3SchemeSigners;
            }
            
            /// <summary>
            /// Returns the {@link SourceStampInfo} instance representing the source stamp signer for the
            /// APK, or null if the source stamp signature verification failed before the stamp signature
            /// block could be fully parsed.
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result.SourceStampInfo GetSourceStampInfo()
            {
                return mSourceStampInfo;
            }
            
            /// <summary>
            /// Returns {@code true} if an error was encountered while verifying the APK.
            /// 
            /// &lt;p&gt;Any error prevents the APK from being considered verified.
            /// </summary>
            public virtual bool ContainsErrors()
            {
                if (!mErrors.IsEmpty())
                {
                    return true;
                }
                foreach (SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result.SignerInfo> signers in mAllSchemeSigners)
                {
                    foreach (SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result.SignerInfo signer in signers)
                    {
                        if (signer.ContainsErrors())
                        {
                            return true;
                        }
                    }
                }
                if (mSourceStampInfo != null)
                {
                    if (mSourceStampInfo.ContainsErrors())
                    {
                        return true;
                    }
                }
                return false;
            }
            
            /// <summary>
            /// Returns the errors encountered while verifying the APK's source stamp.
            /// </summary>
            public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue> GetErrors()
            {
                return mErrors;
            }
            
            /// <summary>
            /// Returns the warnings encountered while verifying the APK's source stamp.
            /// </summary>
            public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue> GetWarnings()
            {
                return mWarnings;
            }
            
            /// <summary>
            /// Returns all errors for this result, including any errors from signature scheme signers
            /// and the source stamp.
            /// </summary>
            public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue> GetAllErrors()
            {
                SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue> errors = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue>();
                errors.AddAll(mErrors);
                foreach (SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result.SignerInfo> signers in mAllSchemeSigners)
                {
                    foreach (SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result.SignerInfo signer in signers)
                    {
                        errors.AddAll(signer.GetErrors());
                    }
                }
                if (mSourceStampInfo != null)
                {
                    errors.AddAll(mSourceStampInfo.GetErrors());
                }
                return errors;
            }
            
            /// <summary>
            /// Returns all warnings for this result, including any warnings from signature scheme
            /// signers and the source stamp.
            /// </summary>
            public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue> GetAllWarnings()
            {
                SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue> warnings = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue>();
                warnings.AddAll(mWarnings);
                foreach (SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result.SignerInfo> signers in mAllSchemeSigners)
                {
                    foreach (SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result.SignerInfo signer in signers)
                    {
                        warnings.AddAll(signer.GetWarnings());
                    }
                }
                if (mSourceStampInfo != null)
                {
                    warnings.AddAll(mSourceStampInfo.GetWarnings());
                }
                return warnings;
            }
            
            /// <summary>
            /// Contains information about an APK's signer and any errors encountered while parsing the
            /// corresponding signature block.
            /// </summary>
            public class SignerInfo
            {
                internal SigningServer.Android.Security.Cert.X509Certificate mSigningCertificate;
                
                internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue> mErrors = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue>();
                
                internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue> mWarnings = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue>();
                
                public virtual void SetSigningCertificate(SigningServer.Android.Security.Cert.X509Certificate signingCertificate)
                {
                    mSigningCertificate = signingCertificate;
                }
                
                public virtual void AddVerificationError(int errorId, params object[] parameters)
                {
                    mErrors.Add(new SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue(errorId, parameters));
                }
                
                public virtual void AddVerificationWarning(int warningId, params object[] parameters)
                {
                    mWarnings.Add(new SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue(warningId, parameters));
                }
                
                /// <summary>
                /// Returns the current signing certificate used by this signer.
                /// </summary>
                public virtual SigningServer.Android.Security.Cert.X509Certificate GetSigningCertificate()
                {
                    return mSigningCertificate;
                }
                
                /// <summary>
                /// Returns a {@link List} of {@link ApkVerificationIssue} objects representing errors
                /// encountered during processing of this signer's signature block.
                /// </summary>
                public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue> GetErrors()
                {
                    return mErrors;
                }
                
                /// <summary>
                /// Returns a {@link List} of {@link ApkVerificationIssue} objects representing warnings
                /// encountered during processing of this signer's signature block.
                /// </summary>
                public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue> GetWarnings()
                {
                    return mWarnings;
                }
                
                /// <summary>
                /// Returns {@code true} if any errors were encountered while parsing this signer's
                /// signature block.
                /// </summary>
                public virtual bool ContainsErrors()
                {
                    return !mErrors.IsEmpty();
                }
                
            }
            
            /// <summary>
            /// Contains information about an APK's source stamp and any errors encountered while
            /// parsing the stamp signature block.
            /// </summary>
            public class SourceStampInfo
            {
                internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> mCertificates;
                
                internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> mCertificateLineage;
                
                internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue> mErrors = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue>();
                
                internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue> mWarnings = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue>();
                
                internal static readonly bool mWarningsAsErrors = true;
                
                internal SourceStampInfo(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSignerInfo result)
                {
                    mCertificates = result.certs;
                    mCertificateLineage = result.certificateLineage;
                    mErrors.AddAll(result.GetErrors());
                    mWarnings.AddAll(result.GetWarnings());
                }
                
                /// <summary>
                /// Returns the SourceStamp's signing certificate or {@code null} if not available. The
                /// certificate is guaranteed to be available if no errors were encountered during
                /// verification (see {@link #containsErrors()}.
                /// 
                /// &lt;p&gt;This certificate contains the SourceStamp's public key.
                /// </summary>
                public virtual SigningServer.Android.Security.Cert.X509Certificate GetCertificate()
                {
                    return mCertificates.IsEmpty() ? null : mCertificates.Get(0);
                }
                
                /// <summary>
                /// Returns a {@code List} of {@link X509Certificate} instances representing the source
                /// stamp signer's lineage with the oldest signer at element 0, or an empty {@code List}
                /// if the stamp's signing certificate has not been rotated.
                /// </summary>
                public virtual SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> GetCertificatesInLineage()
                {
                    return mCertificateLineage;
                }
                
                /// <summary>
                /// Returns whether any errors were encountered during the source stamp verification.
                /// </summary>
                public virtual bool ContainsErrors()
                {
                    return !mErrors.IsEmpty() || (SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result.SourceStampInfo.mWarningsAsErrors && !mWarnings.IsEmpty());
                }
                
                /// <summary>
                /// Returns a {@code List} of {@link ApkVerificationIssue} representing errors that were
                /// encountered during source stamp verification.
                /// </summary>
                public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue> GetErrors()
                {
                    if (!SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Result.SourceStampInfo.mWarningsAsErrors)
                    {
                        return mErrors;
                    }
                    SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue> result = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue>();
                    result.AddAll(mErrors);
                    result.AddAll(mWarnings);
                    return result;
                }
                
                /// <summary>
                /// Returns a {@code List} of {@link ApkVerificationIssue} representing warnings that
                /// were encountered during source stamp verification.
                /// </summary>
                public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue> GetWarnings()
                {
                    return mWarnings;
                }
                
            }
            
        }
        
        /// <summary>
        /// Builder of {@link SourceStampVerifier} instances.
        /// 
        /// &lt;p&gt; The resulting verifier, by default, checks whether the APK's source stamp signature will
        /// verify on all platform versions. The APK's {@code android:minSdkVersion} attribute is not
        /// queried to determine the APK's minimum supported level, so the caller should specify a lower
        /// bound with {@link #setMinCheckedPlatformVersion(int)}.
        /// </summary>
        public class Builder
        {
            internal readonly System.IO.FileInfo mApkFile;
            
            internal readonly SigningServer.Android.Com.Android.Apksig.Util.DataSource mApkDataSource;
            
            internal int mMinSdkVersion = 1;
            
            internal int mMaxSdkVersion = SigningServer.Android.Core.IntExtensions.MaxValue;
            
            /// <summary>
            /// Constructs a new {@code Builder} for source stamp verification of the provided {@code
            /// apk}.
            /// </summary>
            public Builder(System.IO.FileInfo apk)
            {
                if (apk == null)
                {
                    throw new System.NullReferenceException("apk == null");
                }
                mApkFile = apk;
                mApkDataSource = null;
            }
            
            /// <summary>
            /// Constructs a new {@code Builder} for source stamp verification of the provided {@code
            /// apk}.
            /// </summary>
            public Builder(SigningServer.Android.Com.Android.Apksig.Util.DataSource apk)
            {
                if (apk == null)
                {
                    throw new System.NullReferenceException("apk == null");
                }
                mApkDataSource = apk;
                mApkFile = null;
            }
            
            /// <summary>
            /// Sets the oldest Android platform version for which the APK's source stamp is verified.
            /// 
            /// &lt;p&gt;APK source stamp verification will confirm that the APK's stamp is expected to verify
            /// on all Android platforms starting from the platform version with the provided {@code
            /// minSdkVersion}. The upper end of the platform versions range can be modified via
            /// {@link #setMaxCheckedPlatformVersion(int)}.
            /// 
            /// @param minSdkVersion API Level of the oldest platform for which to verify the APK
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Builder SetMinCheckedPlatformVersion(int minSdkVersion)
            {
                mMinSdkVersion = minSdkVersion;
                return this;
            }
            
            /// <summary>
            /// Sets the newest Android platform version for which the APK's source stamp  is verified.
            /// 
            /// &lt;p&gt;APK source stamp verification will confirm that the APK's stamp is expected to verify
            /// on all platform versions up to and including the proviced {@code maxSdkVersion}. The
            /// lower end of the platform versions range can be modified via {@link
            /// #setMinCheckedPlatformVersion(int)}.
            /// 
            /// @param maxSdkVersion API Level of the newest platform for which to verify the APK
            /// @see #setMinCheckedPlatformVersion(int)
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.SourceStampVerifier.Builder SetMaxCheckedPlatformVersion(int maxSdkVersion)
            {
                mMaxSdkVersion = maxSdkVersion;
                return this;
            }
            
            /// <summary>
            /// Returns a {@link SourceStampVerifier} initialized according to the configuration of this
            /// builder.
            /// </summary>
            public virtual SigningServer.Android.Com.Android.Apksig.SourceStampVerifier Build()
            {
                return new SigningServer.Android.Com.Android.Apksig.SourceStampVerifier(mApkFile, mApkDataSource, mMinSdkVersion, mMaxSdkVersion);
            }
            
        }
        
    }
    
}
