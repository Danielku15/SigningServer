// <auto-generated>
// This code was auto-generated.
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
// </auto-generated>

using System;
using SigningServer.Android.Com.Android.Apksig.Util;

namespace SigningServer.Android.Com.Android.Apksig.Internal.Apk
{
    public class ApkSigningBlockUtils
    {
        internal static readonly long CONTENT_DIGESTED_CHUNK_MAX_SIZE_BYTES = 1024 * 1024;
        
        public static readonly int ANDROID_COMMON_PAGE_ALIGNMENT_BYTES = 4096;
        
        internal static readonly sbyte[] APK_SIGNING_BLOCK_MAGIC = new sbyte[]{
            
            0x41, 
            0x50, 
            0x4b, 
            0x20, 
            0x53, 
            0x69, 
            0x67, 
            0x20, 
            0x42, 
            0x6c, 
            0x6f, 
            0x63, 
            0x6b, 
            0x20, 
            0x34, 
            0x32}
        ;
        
        public static readonly int VERITY_PADDING_BLOCK_ID = 0x42726577;
        
        internal static readonly SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm[] V4_CONTENT_DIGEST_ALGORITHMS = {SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm.CHUNKED_SHA512, SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm.VERITY_CHUNKED_SHA256, SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm.CHUNKED_SHA256};
        
        public const int VERSION_SOURCE_STAMP = 0;
        
        public static readonly int VERSION_JAR_SIGNATURE_SCHEME = 1;
        
        public const int VERSION_APK_SIGNATURE_SCHEME_V2 = 2;
        
        public const int VERSION_APK_SIGNATURE_SCHEME_V3 = 3;
        
        public const int VERSION_APK_SIGNATURE_SCHEME_V4 = 4;
        
        /// <summary>
        /// Returns positive number if {@code alg1} is preferred over {@code alg2}, {@code -1} if
        /// {@code alg2} is preferred over {@code alg1}, and {@code 0} if there is no preference.
        /// </summary>
        public static int CompareSignatureAlgorithm(SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm alg1, SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm alg2)
        {
            return SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtilsLite.CompareSignatureAlgorithm(alg1, alg2);
        }
        
        /// <summary>
        /// Verifies integrity of the APK outside of the APK Signing Block by computing digests of the
        /// APK and comparing them against the digests listed in APK Signing Block. The expected digests
        /// are taken from {@code SignerInfos} of the provided {@code result}.
        /// 
        /// &lt;p&gt;This method adds one or more errors to the {@code result} if a verification error is
        /// expected to be encountered on Android. No errors are added to the {@code result} if the APK's
        /// integrity is expected to verify on Android for each algorithm in
        /// {@code contentDigestAlgorithms}.
        /// 
        /// &lt;p&gt;The reason this method is currently not parameterized by a
        /// {@code [minSdkVersion, maxSdkVersion]} range is that up until now content digest algorithms
        /// exhibit the same behavior on all Android platform versions.
        /// </summary>
        public static void VerifyIntegrity(SigningServer.Android.Com.Android.Apksig.Util.RunnablesExecutor executor, SigningServer.Android.Com.Android.Apksig.Util.DataSource beforeApkSigningBlock, SigningServer.Android.Com.Android.Apksig.Util.DataSource centralDir, SigningServer.Android.IO.ByteBuffer eocd, SigningServer.Android.Collections.Set<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm> contentDigestAlgorithms, SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result result)
        {
            if (contentDigestAlgorithms.IsEmpty())
            {
                throw new SigningServer.Android.Core.RuntimeException("No content digests found");
            }
            SigningServer.Android.IO.ByteBuffer modifiedEocd = SigningServer.Android.IO.ByteBuffer.Allocate(eocd.Remaining());
            int eocdSavedPos = eocd.Position();
            modifiedEocd.Order(SigningServer.Android.IO.ByteOrder.LITTLE_ENDIAN);
            modifiedEocd.Put(eocd);
            modifiedEocd.Flip();
            eocd.Position(eocdSavedPos);
            SigningServer.Android.Com.Android.Apksig.Internal.Zip.ZipUtils.SetZipEocdCentralDirectoryOffset(modifiedEocd, beforeApkSigningBlock.Size());
            SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]> actualContentDigests;
            try
            {
                actualContentDigests = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ComputeContentDigests(executor, contentDigestAlgorithms, beforeApkSigningBlock, centralDir, new SigningServer.Android.Com.Android.Apksig.Internal.Util.ByteBufferDataSource(modifiedEocd));
                if (actualContentDigests.ContainsKey(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm.VERITY_CHUNKED_SHA256))
                {
                    if ((beforeApkSigningBlock.Size() % SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ANDROID_COMMON_PAGE_ALIGNMENT_BYTES != 0))
                    {
                        throw new SigningServer.Android.Core.RuntimeException("APK Signing Block is not aligned on 4k boundary: " + beforeApkSigningBlock.Size());
                    }
                    long centralDirOffset = SigningServer.Android.Com.Android.Apksig.Internal.Zip.ZipUtils.GetZipEocdCentralDirectoryOffset(eocd);
                    long signingBlockSize = centralDirOffset - beforeApkSigningBlock.Size();
                    if (signingBlockSize % SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ANDROID_COMMON_PAGE_ALIGNMENT_BYTES != 0)
                    {
                        throw new SigningServer.Android.Core.RuntimeException("APK Signing Block size is not multiple of page size: " + signingBlockSize);
                    }
                }
            }
            catch (SigningServer.Android.Security.DigestException e)
            {
                throw new SigningServer.Android.Core.RuntimeException("Failed to compute content digests", e);
            }
            if (!contentDigestAlgorithms.Equals(actualContentDigests.KeySet()))
            {
                throw new SigningServer.Android.Core.RuntimeException("Mismatch between sets of requested and computed content digests" + " . Requested: " + contentDigestAlgorithms + ", computed: " + actualContentDigests.KeySet());
            }
            foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo signerInfo in result.signers)
            {
                foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo.ContentDigest expected in signerInfo.contentDigests)
                {
                    SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm signatureAlgorithm = SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm.FindById(expected.GetSignatureAlgorithmId());
                    if (signatureAlgorithm == null)
                    {
                        continue;
                    }
                    SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm contentDigestAlgorithm = signatureAlgorithm.GetContentDigestAlgorithm();
                    if (!contentDigestAlgorithms.Contains(contentDigestAlgorithm))
                    {
                        continue;
                    }
                    sbyte[] expectedDigest = expected.GetValue();
                    sbyte[] actualDigest = actualContentDigests.Get(contentDigestAlgorithm);
                    if (!SigningServer.Android.Collections.Arrays.Equals(expectedDigest, actualDigest))
                    {
                        if (result.signatureSchemeVersion == SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V2)
                        {
                            signerInfo.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.V2_SIG_APK_DIGEST_DID_NOT_VERIFY, contentDigestAlgorithm, SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ToHex(expectedDigest), SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ToHex(actualDigest));
                        }
                        else if (result.signatureSchemeVersion == SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERSION_APK_SIGNATURE_SCHEME_V3)
                        {
                            signerInfo.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.V3_SIG_APK_DIGEST_DID_NOT_VERIFY, contentDigestAlgorithm, SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ToHex(expectedDigest), SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ToHex(actualDigest));
                        }
                        continue;
                    }
                    signerInfo.verifiedContentDigests.Put(contentDigestAlgorithm, actualDigest);
                }
            }
        }
        
        public static SigningServer.Android.IO.ByteBuffer FindApkSignatureSchemeBlock(SigningServer.Android.IO.ByteBuffer apkSigningBlock, int blockId, SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result result)
        {
            try
            {
                return SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtilsLite.FindApkSignatureSchemeBlock(apkSigningBlock, blockId);
            }
            catch (SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureNotFoundException e)
            {
                throw new SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignatureNotFoundException(e.GetMessage());
            }
        }
        
        public static void CheckByteOrderLittleEndian(SigningServer.Android.IO.ByteBuffer buffer)
        {
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtilsLite.CheckByteOrderLittleEndian(buffer);
        }
        
        public static SigningServer.Android.IO.ByteBuffer GetLengthPrefixedSlice(SigningServer.Android.IO.ByteBuffer source)
        {
            return SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtilsLite.GetLengthPrefixedSlice(source);
        }
        
        public static sbyte[] ReadLengthPrefixedByteArray(SigningServer.Android.IO.ByteBuffer buf)
        {
            return SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtilsLite.ReadLengthPrefixedByteArray(buf);
        }
        
        public static string ToHex(sbyte[] value)
        {
            return SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtilsLite.ToHex(value);
        }
        
        public static SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]> ComputeContentDigests(SigningServer.Android.Com.Android.Apksig.Util.RunnablesExecutor executor, SigningServer.Android.Collections.Set<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm> digestAlgorithms, SigningServer.Android.Com.Android.Apksig.Util.DataSource beforeCentralDir, SigningServer.Android.Com.Android.Apksig.Util.DataSource centralDir, SigningServer.Android.Com.Android.Apksig.Util.DataSource eocd)
        {
            SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]> contentDigests = new SigningServer.Android.Collections.HashMap<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]>();
            SigningServer.Android.Collections.Set<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm> oneMbChunkBasedAlgorithm = new SigningServer.Android.Collections.HashSet<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm>();
            foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm digestAlgorithm in digestAlgorithms)
            {
                if (digestAlgorithm == SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm.CHUNKED_SHA256 || digestAlgorithm == SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm.CHUNKED_SHA512)
                {
                    oneMbChunkBasedAlgorithm.Add(digestAlgorithm);
                }
            }
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ComputeOneMbChunkContentDigests(executor, oneMbChunkBasedAlgorithm, new SigningServer.Android.Com.Android.Apksig.Util.DataSource[]{
                beforeCentralDir, centralDir, eocd}
            , contentDigests);
            if (digestAlgorithms.Contains(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm.VERITY_CHUNKED_SHA256))
            {
                SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ComputeApkVerityDigest(beforeCentralDir, centralDir, eocd, contentDigests);
            }
            return contentDigests;
        }
        
        public static void ComputeOneMbChunkContentDigests(SigningServer.Android.Collections.Set<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm> digestAlgorithms, SigningServer.Android.Com.Android.Apksig.Util.DataSource[] contents, SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]> outputContentDigests)
        {
            long chunkCountLong = 0;
            foreach (SigningServer.Android.Com.Android.Apksig.Util.DataSource input in contents)
            {
                chunkCountLong += SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.GetChunkCount(input.Size(), SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.CONTENT_DIGESTED_CHUNK_MAX_SIZE_BYTES);
            }
            if (chunkCountLong > SigningServer.Android.Core.IntExtensions.MaxValue)
            {
                throw new SigningServer.Android.Security.DigestException("Input too long: " + chunkCountLong + " chunks");
            }
            int chunkCount = (int)chunkCountLong;
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm[] digestAlgorithmsArray = digestAlgorithms.ToArray(new SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm[digestAlgorithms.Size()]);
            SigningServer.Android.Security.MessageDigest[] mds = new SigningServer.Android.Security.MessageDigest[digestAlgorithmsArray.Length];
            sbyte[][] digestsOfChunks = new sbyte[digestAlgorithmsArray.Length][];
            int[] digestOutputSizes = new int[digestAlgorithmsArray.Length];
            for (int i = 0;i < digestAlgorithmsArray.Length;i++)
            {
                SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm digestAlgorithm = digestAlgorithmsArray[i];
                int digestOutputSizeBytes = digestAlgorithm.GetChunkDigestOutputSizeBytes();
                digestOutputSizes[i] = digestOutputSizeBytes;
                sbyte[] concatenationOfChunkCountAndChunkDigests = new sbyte[5 + chunkCount * digestOutputSizeBytes];
                concatenationOfChunkCountAndChunkDigests[0] = 0x5a;
                SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SetUnsignedInt32LittleEndian(chunkCount, concatenationOfChunkCountAndChunkDigests, 1);
                digestsOfChunks[i] = concatenationOfChunkCountAndChunkDigests;
                string jcaAlgorithm = digestAlgorithm.GetJcaMessageDigestAlgorithm();
                mds[i] = SigningServer.Android.Security.MessageDigest.GetInstance(jcaAlgorithm);
            }
            SigningServer.Android.Com.Android.Apksig.Util.DataSink mdSink = SigningServer.Android.Com.Android.Apksig.Util.DataSinks.AsDataSink(mds);
            sbyte[] chunkContentPrefix = new sbyte[5];
            chunkContentPrefix[0] = unchecked((sbyte)0xa5);
            int chunkIndex = 0;
            foreach (SigningServer.Android.Com.Android.Apksig.Util.DataSource input in contents)
            {
                long inputOffset = 0;
                long inputRemaining = input.Size();
                while (inputRemaining > 0)
                {
                    int chunkSize = (int)SigningServer.Android.Core.Math.Min(inputRemaining, SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.CONTENT_DIGESTED_CHUNK_MAX_SIZE_BYTES);
                    SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SetUnsignedInt32LittleEndian(chunkSize, chunkContentPrefix, 1);
                    for (int i = 0;i < mds.Length;i++)
                    {
                        mds[i].Update(chunkContentPrefix);
                    }
                    try
                    {
                        input.Feed(inputOffset, chunkSize, mdSink);
                    }
                    catch (SigningServer.Android.IO.IOException e)
                    {
                        throw new SigningServer.Android.IO.IOException("Failed to read chunk #" + chunkIndex, e);
                    }
                    for (int i = 0;i < digestAlgorithmsArray.Length;i++)
                    {
                        SigningServer.Android.Security.MessageDigest md = mds[i];
                        sbyte[] concatenationOfChunkCountAndChunkDigests = digestsOfChunks[i];
                        int expectedDigestSizeBytes = digestOutputSizes[i];
                        int actualDigestSizeBytes = md.Digest(concatenationOfChunkCountAndChunkDigests, 5 + chunkIndex * expectedDigestSizeBytes, expectedDigestSizeBytes);
                        if (actualDigestSizeBytes != expectedDigestSizeBytes)
                        {
                            throw new SigningServer.Android.Core.RuntimeException("Unexpected output size of " + md.GetAlgorithm() + " digest: " + actualDigestSizeBytes);
                        }
                    }
                    inputOffset += chunkSize;
                    inputRemaining -= chunkSize;
                    chunkIndex++;
                }
            }
            for (int i = 0;i < digestAlgorithmsArray.Length;i++)
            {
                SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm digestAlgorithm = digestAlgorithmsArray[i];
                sbyte[] concatenationOfChunkCountAndChunkDigests = digestsOfChunks[i];
                SigningServer.Android.Security.MessageDigest md = mds[i];
                sbyte[] digest = md.Digest(concatenationOfChunkCountAndChunkDigests);
                outputContentDigests.Put(digestAlgorithm, digest);
            }
        }
        
        public static void ComputeOneMbChunkContentDigests(SigningServer.Android.Com.Android.Apksig.Util.RunnablesExecutor executor, SigningServer.Android.Collections.Set<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm> digestAlgorithms, SigningServer.Android.Com.Android.Apksig.Util.DataSource[] contents, SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]> outputContentDigests)
        {
            long chunkCountLong = 0;
            foreach (SigningServer.Android.Com.Android.Apksig.Util.DataSource input in contents)
            {
                chunkCountLong += SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.GetChunkCount(input.Size(), SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.CONTENT_DIGESTED_CHUNK_MAX_SIZE_BYTES);
            }
            if (chunkCountLong > SigningServer.Android.Core.IntExtensions.MaxValue)
            {
                throw new SigningServer.Android.Security.DigestException("Input too long: " + chunkCountLong + " chunks");
            }
            int chunkCount = (int)chunkCountLong;
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ChunkDigests> chunkDigestsList = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ChunkDigests>(digestAlgorithms.Size());
            foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm algorithms in digestAlgorithms)
            {
                chunkDigestsList.Add(new SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ChunkDigests(algorithms, chunkCount));
            }
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ChunkSupplier chunkSupplier = new SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ChunkSupplier(contents);
            executor.Execute(new DelegateRunnablesProvider(() => new SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ChunkDigester(chunkSupplier, chunkDigestsList)));
            foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ChunkDigests chunkDigests in chunkDigestsList)
            {
                SigningServer.Android.Security.MessageDigest messageDigest = chunkDigests.CreateMessageDigest();
                outputContentDigests.Put(chunkDigests.algorithm, messageDigest.Digest(chunkDigests.concatOfDigestsOfChunks));
            }
        }
        
        internal class ChunkDigests
        {
            internal readonly SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm algorithm;
            
            internal readonly int digestOutputSize;
            
            internal readonly sbyte[] concatOfDigestsOfChunks;
            
            internal ChunkDigests(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm algorithm, int chunkCount)
            {
                this.algorithm = algorithm;
                digestOutputSize = this.algorithm.GetChunkDigestOutputSizeBytes();
                concatOfDigestsOfChunks = new sbyte[1 + 4 + chunkCount * digestOutputSize];
                concatOfDigestsOfChunks[0] = 0x5a;
                SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SetUnsignedInt32LittleEndian(chunkCount, concatOfDigestsOfChunks, 1);
            }
            
            internal SigningServer.Android.Security.MessageDigest CreateMessageDigest()
            {
                return SigningServer.Android.Security.MessageDigest.GetInstance(algorithm.GetJcaMessageDigestAlgorithm());
            }
            
            internal int GetOffset(int chunkIndex)
            {
                return 1 + 4 + chunkIndex * digestOutputSize;
            }
            
        }
        
        /// <summary>
        /// A per-thread digest worker.
        /// </summary>
        internal class ChunkDigester: SigningServer.Android.Core.Runnable
        {
            internal readonly SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ChunkSupplier dataSupplier;
            
            internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ChunkDigests> chunkDigests;
            
            internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Security.MessageDigest> messageDigests;
            
            internal readonly SigningServer.Android.Com.Android.Apksig.Util.DataSink mdSink;
            
            internal ChunkDigester(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ChunkSupplier dataSupplier, SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ChunkDigests> chunkDigests)
            {
                this.dataSupplier = dataSupplier;
                this.chunkDigests = chunkDigests;
                messageDigests = new SigningServer.Android.Collections.List<SigningServer.Android.Security.MessageDigest>(chunkDigests.Size());
                foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ChunkDigests chunkDigest in chunkDigests)
                {
                    try
                    {
                        messageDigests.Add(chunkDigest.CreateMessageDigest());
                    }
                    catch (SigningServer.Android.Security.NoSuchAlgorithmException ex)
                    {
                        throw new SigningServer.Android.Core.RuntimeException(ex);
                    }
                }
                mdSink = SigningServer.Android.Com.Android.Apksig.Util.DataSinks.AsDataSink(messageDigests.ToArray());
            }
            
            public void Run()
            {
                sbyte[] chunkContentPrefix = new sbyte[5];
                chunkContentPrefix[0] = unchecked((sbyte)0xa5);
                try
                {
                    for (SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ChunkSupplier.Chunk chunk = dataSupplier.Get();chunk != null;chunk = dataSupplier.Get())
                    {
                        int size = chunk.size;
                        if (size > SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.CONTENT_DIGESTED_CHUNK_MAX_SIZE_BYTES)
                        {
                            throw new SigningServer.Android.Core.RuntimeException("Chunk size greater than expected: " + size);
                        }
                        SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SetUnsignedInt32LittleEndian(size, chunkContentPrefix, 1);
                        mdSink.Consume(chunkContentPrefix, 0, chunkContentPrefix.Length);
                        mdSink.Consume(chunk.data);
                        for (int i = 0;i < chunkDigests.Size();i++)
                        {
                            SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ChunkDigests chunkDigest = chunkDigests.Get(i);
                            int actualDigestSize = messageDigests.Get(i).Digest(chunkDigest.concatOfDigestsOfChunks, chunkDigest.GetOffset(chunk.chunkIndex), chunkDigest.digestOutputSize);
                            if (actualDigestSize != chunkDigest.digestOutputSize)
                            {
                                throw new SigningServer.Android.Core.RuntimeException("Unexpected output size of " + chunkDigest.algorithm + " digest: " + actualDigestSize);
                            }
                        }
                    }
                }
                catch (System.Exception e) when ( e is SigningServer.Android.IO.IOException || e is SigningServer.Android.Security.DigestException)
                {
                    throw new SigningServer.Android.Core.RuntimeException(e);
                }
            }
            
        }
        
        /// <summary>
        /// Thread-safe 1MB DataSource chunk supplier. When bounds are met in a
        /// supplied {@link DataSource}, the data from the next {@link DataSource}
        /// are NOT concatenated. Only the next call to get() will fetch from the
        /// next {@link DataSource} in the input {@link DataSource} array.
        /// </summary>
        internal class ChunkSupplier: SigningServer.Android.Util.Function.Supplier<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ChunkSupplier.Chunk>
        {
            internal readonly SigningServer.Android.Com.Android.Apksig.Util.DataSource[] dataSources;
            
            internal readonly int[] chunkCounts;
            
            internal readonly int totalChunkCount;
            
            internal readonly SigningServer.Android.Util.Concurrent.Atomic.AtomicInteger nextIndex;
            
            internal ChunkSupplier(SigningServer.Android.Com.Android.Apksig.Util.DataSource[] dataSources)
            {
                this.dataSources = dataSources;
                chunkCounts = new int[dataSources.Length];
                int totalChunkCount = 0;
                for (int i = 0;i < dataSources.Length;i++)
                {
                    long chunkCount = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.GetChunkCount(dataSources[i].Size(), SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.CONTENT_DIGESTED_CHUNK_MAX_SIZE_BYTES);
                    if (chunkCount > SigningServer.Android.Core.IntExtensions.MaxValue)
                    {
                        throw new SigningServer.Android.Core.RuntimeException(SigningServer.Android.Core.StringExtensions.Format("Number of chunks in dataSource[%d] is greater than max int.", i));
                    }
                    chunkCounts[i] = (int)chunkCount;
                    totalChunkCount = (int)(totalChunkCount + chunkCount);
                }
                this.totalChunkCount = totalChunkCount;
                nextIndex = new SigningServer.Android.Util.Concurrent.Atomic.AtomicInteger(0);
            }
            
            /// <summary>
            /// We map an integer index to the termination-adjusted dataSources 1MB chunks.
            /// Note that {@link Chunk}s could be less than 1MB, namely the last 1MB-aligned
            /// blocks in each input {@link DataSource} (unless the DataSource itself is
            /// 1MB-aligned).
            /// </summary>
            public SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ChunkSupplier.Chunk Get()
            {
                int index = nextIndex.GetAndIncrement();
                if (index < 0 || index >= totalChunkCount)
                {
                    return null;
                }
                int dataSourceIndex = 0;
                long dataSourceChunkOffset = index;
                for (;dataSourceIndex < dataSources.Length;dataSourceIndex++)
                {
                    if (dataSourceChunkOffset < chunkCounts[dataSourceIndex])
                    {
                        break;
                    }
                    dataSourceChunkOffset -= chunkCounts[dataSourceIndex];
                }
                long remainingSize = SigningServer.Android.Core.Math.Min(dataSources[dataSourceIndex].Size() - dataSourceChunkOffset * SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.CONTENT_DIGESTED_CHUNK_MAX_SIZE_BYTES, SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.CONTENT_DIGESTED_CHUNK_MAX_SIZE_BYTES);
                int size = (int)remainingSize;
                SigningServer.Android.IO.ByteBuffer buffer = SigningServer.Android.IO.ByteBuffer.Allocate(size);
                try
                {
                    dataSources[dataSourceIndex].CopyTo(dataSourceChunkOffset * SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.CONTENT_DIGESTED_CHUNK_MAX_SIZE_BYTES, size, buffer);
                }
                catch (SigningServer.Android.IO.IOException e)
                {
                    throw new System.InvalidOperationException("Failed to read chunk", e);
                }
                buffer.Rewind();
                return new SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ChunkSupplier.Chunk(index, buffer, size);
            }
            
            internal class Chunk
            {
                internal readonly int chunkIndex;
                
                internal readonly SigningServer.Android.IO.ByteBuffer data;
                
                internal readonly int size;
                
                internal Chunk(int chunkIndex, SigningServer.Android.IO.ByteBuffer data, int size)
                {
                    this.chunkIndex = chunkIndex;
                    this.data = data;
                    this.size = size;
                }
                
            }
            
        }
        
        internal static void ComputeApkVerityDigest(SigningServer.Android.Com.Android.Apksig.Util.DataSource beforeCentralDir, SigningServer.Android.Com.Android.Apksig.Util.DataSource centralDir, SigningServer.Android.Com.Android.Apksig.Util.DataSource eocd, SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]> outputContentDigests)
        {
            SigningServer.Android.IO.ByteBuffer encoded = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.CreateVerityDigestBuffer(true);
            using(SigningServer.Android.Com.Android.Apksig.Internal.Util.VerityTreeBuilder builder = new SigningServer.Android.Com.Android.Apksig.Internal.Util.VerityTreeBuilder(new sbyte[8]))
            {
                sbyte[] rootHash = builder.GenerateVerityTreeRootHash(beforeCentralDir, centralDir, eocd);
                encoded.Put(rootHash);
                encoded.PutLong(beforeCentralDir.Size() + centralDir.Size() + eocd.Size());
                outputContentDigests.Put(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm.VERITY_CHUNKED_SHA256, encoded.Array());
            }
        }
        
        internal static SigningServer.Android.IO.ByteBuffer CreateVerityDigestBuffer(bool includeSourceDataSize)
        {
            int backBufferSize = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm.VERITY_CHUNKED_SHA256.GetChunkDigestOutputSizeBytes();
            if (includeSourceDataSize)
            {
                backBufferSize += SigningServer.Android.Core.LongExtensions.SIZE / SigningServer.Android.Core.SByteExtensions.SIZE;
            }
            SigningServer.Android.IO.ByteBuffer encoded = SigningServer.Android.IO.ByteBuffer.Allocate(backBufferSize);
            encoded.Order(SigningServer.Android.IO.ByteOrder.LITTLE_ENDIAN);
            return encoded;
        }
        
        public class VerityTreeAndDigest
        {
            public readonly SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm contentDigestAlgorithm;
            
            public readonly sbyte[] rootHash;
            
            public readonly sbyte[] tree;
            
            internal VerityTreeAndDigest(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm contentDigestAlgorithm, sbyte[] rootHash, sbyte[] tree)
            {
                this.contentDigestAlgorithm = contentDigestAlgorithm;
                this.rootHash = rootHash;
                this.tree = tree;
            }
            
        }
        
        public static SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VerityTreeAndDigest ComputeChunkVerityTreeAndDigest(SigningServer.Android.Com.Android.Apksig.Util.DataSource dataSource)
        {
            SigningServer.Android.IO.ByteBuffer encoded = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.CreateVerityDigestBuffer(false);
            using(SigningServer.Android.Com.Android.Apksig.Internal.Util.VerityTreeBuilder builder = new SigningServer.Android.Com.Android.Apksig.Internal.Util.VerityTreeBuilder(null))
            {
                SigningServer.Android.IO.ByteBuffer tree = builder.GenerateVerityTree(dataSource);
                sbyte[] rootHash = builder.GetRootHashFromTree(tree);
                encoded.Put(rootHash);
                return new SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VerityTreeAndDigest(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm.VERITY_CHUNKED_SHA256, encoded.Array(), tree.Array());
            }
        }
        
        internal static long GetChunkCount(long inputSize, long chunkSize)
        {
            return (inputSize + chunkSize - 1) / chunkSize;
        }
        
        internal static void SetUnsignedInt32LittleEndian(int value, sbyte[] result, int offset)
        {
            result[offset] = (sbyte)(value & 0xff);
            result[offset + 1] = (sbyte)((value >> 8) & 0xff);
            result[offset + 2] = (sbyte)((value >> 16) & 0xff);
            result[offset + 3] = (sbyte)((value >> 24) & 0xff);
        }
        
        public static sbyte[] EncodePublicKey(SigningServer.Android.Security.PublicKey publicKey)
        {
            sbyte[] encodedPublicKey = null;
            if ("X.509".Equals(publicKey.GetFormat()))
            {
                encodedPublicKey = publicKey.GetEncoded();
                if ("RSA".Equals(publicKey.GetAlgorithm()))
                {
                    try
                    {
                        SigningServer.Android.IO.ByteBuffer encodedPublicKeyBuffer = SigningServer.Android.IO.ByteBuffer.Wrap(encodedPublicKey);
                        SigningServer.Android.Com.Android.Apksig.Internal.X509.SubjectPublicKeyInfo subjectPublicKeyInfo = SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1BerParser.Parse<SigningServer.Android.Com.Android.Apksig.Internal.X509.SubjectPublicKeyInfo>(encodedPublicKeyBuffer);
                        SigningServer.Android.IO.ByteBuffer subjectPublicKeyBuffer = subjectPublicKeyInfo.subjectPublicKey;
                        sbyte padding = subjectPublicKeyBuffer.Get();
                        SigningServer.Android.Com.Android.Apksig.Internal.X509.RSAPublicKey rsaPublicKey = SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1BerParser.Parse<SigningServer.Android.Com.Android.Apksig.Internal.X509.RSAPublicKey>(subjectPublicKeyBuffer);
                        if (rsaPublicKey.modulus.CompareTo(SigningServer.Android.Math.BigInteger.ZERO) < 0)
                        {
                            sbyte[] encodedModulus = rsaPublicKey.modulus.ToByteArray();
                            sbyte[] reencodedModulus = new sbyte[encodedModulus.Length + 1];
                            reencodedModulus[0] = 0;
                            SigningServer.Android.Core.System.Arraycopy(encodedModulus, 0, reencodedModulus, 1, encodedModulus.Length);
                            rsaPublicKey.modulus = new SigningServer.Android.Math.BigInteger(reencodedModulus);
                            sbyte[] reencodedRSAPublicKey = SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1DerEncoder.Encode(rsaPublicKey);
                            sbyte[] reencodedSubjectPublicKey = new sbyte[reencodedRSAPublicKey.Length + 1];
                            reencodedSubjectPublicKey[0] = padding;
                            SigningServer.Android.Core.System.Arraycopy(reencodedRSAPublicKey, 0, reencodedSubjectPublicKey, 1, reencodedRSAPublicKey.Length);
                            subjectPublicKeyInfo.subjectPublicKey = SigningServer.Android.IO.ByteBuffer.Wrap(reencodedSubjectPublicKey);
                            encodedPublicKey = SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1DerEncoder.Encode(subjectPublicKeyInfo);
                        }
                    }
                    catch (System.Exception e) when ( e is SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1DecodingException || e is SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1EncodingException)
                    {
                        SigningServer.Android.Core.System.output.Println("Caught a exception encoding the public key: " + e);
                        e.PrintStackTrace();
                        encodedPublicKey = null;
                    }
                }
            }
            if (encodedPublicKey == null)
            {
                try
                {
                    encodedPublicKey = SigningServer.Android.Security.KeyFactory.GetInstance(publicKey.GetAlgorithm()).GetKeySpec<SigningServer.Android.Security.Spec.X509EncodedKeySpec>(publicKey).GetEncoded();
                }
                catch (SigningServer.Android.Security.Spec.InvalidKeySpecException e)
                {
                    throw new SigningServer.Android.Security.InvalidKeyException("Failed to obtain X.509 encoded form of public key " + publicKey + " of class " + publicKey.GetType().GetName(), e);
                }
            }
            if ((encodedPublicKey == null) || (encodedPublicKey.Length == 0))
            {
                throw new SigningServer.Android.Security.InvalidKeyException("Failed to obtain X.509 encoded form of public key " + publicKey + " of class " + publicKey.GetType().GetName());
            }
            return encodedPublicKey;
        }
        
        public static SigningServer.Android.Collections.List<sbyte[]> EncodeCertificates(SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> certificates)
        {
            SigningServer.Android.Collections.List<sbyte[]> result = new SigningServer.Android.Collections.List<sbyte[]>(certificates.Size());
            foreach (SigningServer.Android.Security.Cert.X509Certificate certificate in certificates)
            {
                result.Add(certificate.GetEncoded());
            }
            return result;
        }
        
        public static sbyte[] EncodeAsLengthPrefixedElement(sbyte[] bytes)
        {
            sbyte[][] adapterBytes = new sbyte[1][];
            adapterBytes[0] = bytes;
            return SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.EncodeAsSequenceOfLengthPrefixedElements(adapterBytes);
        }
        
        public static sbyte[] EncodeAsSequenceOfLengthPrefixedElements(SigningServer.Android.Collections.List<sbyte[]> sequence)
        {
            return SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.EncodeAsSequenceOfLengthPrefixedElements(sequence.ToArray());
        }
        
        public static sbyte[] EncodeAsSequenceOfLengthPrefixedElements(sbyte[][] sequence)
        {
            int payloadSize = 0;
            foreach (sbyte[] element in sequence)
            {
                payloadSize += 4 + element.Length;
            }
            SigningServer.Android.IO.ByteBuffer result = SigningServer.Android.IO.ByteBuffer.Allocate(payloadSize);
            result.Order(SigningServer.Android.IO.ByteOrder.LITTLE_ENDIAN);
            foreach (sbyte[] element in sequence)
            {
                result.PutInt(element.Length);
                result.Put(element);
            }
            return result.Array();
        }
        
        public static sbyte[] EncodeAsSequenceOfLengthPrefixedPairsOfIntAndLengthPrefixedBytes(SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<int, sbyte[]>> sequence)
        {
            return SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtilsLite.EncodeAsSequenceOfLengthPrefixedPairsOfIntAndLengthPrefixedBytes(sequence);
        }
        
        /// <summary>
        /// Returns the APK Signature Scheme block contained in the provided APK file for the given ID
        /// and the additional information relevant for verifying the block against the file.
        /// 
        /// @param blockId the ID value in the APK Signing Block's sequence of ID-value pairs
        ///                identifying the appropriate block to find, e.g. the APK Signature Scheme v2
        ///                block ID.
        /// @throws SignatureNotFoundException if the APK is not signed using given APK Signature Scheme
        /// @throws IOException if an I/O error occurs while reading the APK
        /// </summary>
        public static SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureInfo FindSignature(SigningServer.Android.Com.Android.Apksig.Util.DataSource apk, SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.ZipSections zipSections, int blockId, SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result result)
        {
            try
            {
                return SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtilsLite.FindSignature(apk, zipSections, blockId);
            }
            catch (SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureNotFoundException e)
            {
                throw new SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignatureNotFoundException(e.GetMessage());
            }
        }
        
        /// <summary>
        /// Generates a new DataSource representing the APK contents before the Central Directory with
        /// padding, if padding is requested.  If the existing data entries before the Central Directory
        /// are already aligned, or no padding is requested, the original DataSource is used.  This
        /// padding is used to allow for verity-based APK verification.
        /// 
        /// @return {@code Pair} containing the potentially new {@code DataSource} and the amount of
        ///         padding used.
        /// </summary>
        public static SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<SigningServer.Android.Com.Android.Apksig.Util.DataSource, int> GenerateApkSigningBlockPadding(SigningServer.Android.Com.Android.Apksig.Util.DataSource beforeCentralDir, bool apkSigningBlockPaddingSupported)
        {
            int padSizeBeforeSigningBlock = 0;
            if (apkSigningBlockPaddingSupported && (beforeCentralDir.Size() % SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ANDROID_COMMON_PAGE_ALIGNMENT_BYTES != 0))
            {
                padSizeBeforeSigningBlock = (int)(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ANDROID_COMMON_PAGE_ALIGNMENT_BYTES - beforeCentralDir.Size() % SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ANDROID_COMMON_PAGE_ALIGNMENT_BYTES);
                beforeCentralDir = new SigningServer.Android.Com.Android.Apksig.Internal.Util.ChainedDataSource(beforeCentralDir, SigningServer.Android.Com.Android.Apksig.Util.DataSources.AsDataSource(SigningServer.Android.IO.ByteBuffer.Allocate(padSizeBeforeSigningBlock)));
            }
            return SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair.Of<SigningServer.Android.Com.Android.Apksig.Util.DataSource, int>(beforeCentralDir, padSizeBeforeSigningBlock);
        }
        
        public static SigningServer.Android.Com.Android.Apksig.Util.DataSource CopyWithModifiedCDOffset(SigningServer.Android.Com.Android.Apksig.Util.DataSource beforeCentralDir, SigningServer.Android.Com.Android.Apksig.Util.DataSource eocd)
        {
            long centralDirOffsetForDigesting = beforeCentralDir.Size();
            SigningServer.Android.IO.ByteBuffer eocdBuf = SigningServer.Android.IO.ByteBuffer.Allocate((int)eocd.Size());
            eocdBuf.Order(SigningServer.Android.IO.ByteOrder.LITTLE_ENDIAN);
            eocd.CopyTo(0, (int)eocd.Size(), eocdBuf);
            eocdBuf.Flip();
            SigningServer.Android.Com.Android.Apksig.Internal.Zip.ZipUtils.SetZipEocdCentralDirectoryOffset(eocdBuf, centralDirOffsetForDigesting);
            return SigningServer.Android.Com.Android.Apksig.Util.DataSources.AsDataSource(eocdBuf);
        }
        
        public static sbyte[] GenerateApkSigningBlock(SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<sbyte[], int>> apkSignatureSchemeBlockPairs)
        {
            int blocksSize = 0;
            foreach (SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<sbyte[], int> schemeBlockPair in apkSignatureSchemeBlockPairs)
            {
                blocksSize += 8 + 4 + schemeBlockPair.GetFirst().Length;
            }
            int resultSize = 8 + blocksSize + 8 + 16;
            SigningServer.Android.IO.ByteBuffer paddingPair = null;
            if (resultSize % SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ANDROID_COMMON_PAGE_ALIGNMENT_BYTES != 0)
            {
                int padding = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ANDROID_COMMON_PAGE_ALIGNMENT_BYTES - (resultSize % SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ANDROID_COMMON_PAGE_ALIGNMENT_BYTES);
                if (padding < 12)
                {
                    padding += SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ANDROID_COMMON_PAGE_ALIGNMENT_BYTES;
                }
                paddingPair = SigningServer.Android.IO.ByteBuffer.Allocate(padding).Order(SigningServer.Android.IO.ByteOrder.LITTLE_ENDIAN);
                paddingPair.PutLong(padding - 8);
                paddingPair.PutInt(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.VERITY_PADDING_BLOCK_ID);
                paddingPair.Rewind();
                resultSize += padding;
            }
            SigningServer.Android.IO.ByteBuffer result = SigningServer.Android.IO.ByteBuffer.Allocate(resultSize);
            result.Order(SigningServer.Android.IO.ByteOrder.LITTLE_ENDIAN);
            long blockSizeFieldValue = resultSize - 8L;
            result.PutLong(blockSizeFieldValue);
            foreach (SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<sbyte[], int> schemeBlockPair in apkSignatureSchemeBlockPairs)
            {
                sbyte[] apkSignatureSchemeBlock = schemeBlockPair.GetFirst();
                int apkSignatureSchemeId = schemeBlockPair.GetSecond();
                long pairSizeFieldValue = 4L + apkSignatureSchemeBlock.Length;
                result.PutLong(pairSizeFieldValue);
                result.PutInt(apkSignatureSchemeId);
                result.Put(apkSignatureSchemeBlock);
            }
            if (paddingPair != null)
            {
                result.Put(paddingPair);
            }
            result.PutLong(blockSizeFieldValue);
            result.Put(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.APK_SIGNING_BLOCK_MAGIC);
            return result.Array();
        }
        
        /// <summary>
        /// Returns the individual APK signature blocks within the provided {@code apkSigningBlock} in a
        /// {@code List} of {@code Pair} instances where the first element in the {@code Pair} is the
        /// contents / value of the signature block and the second element is the ID of the block.
        /// 
        /// @throws IOException if an error is encountered reading the provided {@code apkSigningBlock}
        /// </summary>
        public static SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<sbyte[], int>> GetApkSignatureBlocks(SigningServer.Android.Com.Android.Apksig.Util.DataSource apkSigningBlock)
        {
            long apkSigningBlockSize = apkSigningBlock.Size();
            if (apkSigningBlock.Size() > SigningServer.Android.Core.IntExtensions.MaxValue || apkSigningBlockSize < 32)
            {
                throw new System.ArgumentException("APK signing block size out of range: " + apkSigningBlockSize);
            }
            SigningServer.Android.IO.ByteBuffer apkSigningBlockBuffer = apkSigningBlock.GetByteBuffer(8, (int)apkSigningBlock.Size() - 32);
            apkSigningBlockBuffer.Order(SigningServer.Android.IO.ByteOrder.LITTLE_ENDIAN);
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<sbyte[], int>> signatureBlocks = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<sbyte[], int>>();
            while (apkSigningBlockBuffer.HasRemaining())
            {
                long blockLength = apkSigningBlockBuffer.GetLong();
                if (blockLength > SigningServer.Android.Core.IntExtensions.MaxValue || blockLength < 4)
                {
                    throw new System.ArgumentException("Block index " + (signatureBlocks.Size() + 1) + " size out of range: " + blockLength);
                }
                int blockId = apkSigningBlockBuffer.GetInt();
                sbyte[] blockValue = new sbyte[(int)blockLength - 4];
                apkSigningBlockBuffer.Get(blockValue);
                signatureBlocks.Add(SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair.Of<sbyte[], int>(blockValue, blockId));
            }
            return signatureBlocks;
        }
        
        /// <summary>
        /// Returns the individual APK signers within the provided {@code signatureBlock} in a {@code
        /// List} of {@code Pair} instances where the first element is a {@code List} of {@link
        /// X509Certificate}s and the second element is a byte array of the individual signer's block.
        /// 
        /// &lt;p&gt;This method supports any signature block that adheres to the following format up to the
        /// signing certificate(s):
        /// &lt;pre&gt;
        /// * length-prefixed sequence of length-prefixed signers
        ///   * length-prefixed signed data
        ///     * length-prefixed sequence of length-prefixed digests:
        ///       * uint32: signature algorithm ID
        ///       * length-prefixed bytes: digest of contents
        ///     * length-prefixed sequence of certificates:
        ///       * length-prefixed bytes: X.509 certificate (ASN.1 DER encoded).
        /// &lt;/pre&gt;
        /// 
        /// &lt;p&gt;Note, this is a convenience method to obtain any signers from an existing signature block;
        /// the signature of each signer will not be verified.
        /// 
        /// @throws ApkFormatException if an error is encountered while parsing the provided {@code
        /// signatureBlock}
        /// @throws CertificateException if the signing certificate(s) within an individual signer block
        /// cannot be parsed
        /// </summary>
        public static SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate>, sbyte[]>> GetApkSignatureBlockSigners(sbyte[] signatureBlock)
        {
            SigningServer.Android.IO.ByteBuffer signatureBlockBuffer = SigningServer.Android.IO.ByteBuffer.Wrap(signatureBlock);
            signatureBlockBuffer.Order(SigningServer.Android.IO.ByteOrder.LITTLE_ENDIAN);
            SigningServer.Android.IO.ByteBuffer signersBuffer = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.GetLengthPrefixedSlice(signatureBlockBuffer);
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate>, sbyte[]>> signers = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate>, sbyte[]>>();
            while (signersBuffer.HasRemaining())
            {
                SigningServer.Android.IO.ByteBuffer signer = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.GetLengthPrefixedSlice(signersBuffer);
                sbyte[] signerBytes = new sbyte[signer.Remaining()];
                signer.Get(signerBytes);
                signer.Rewind();
                SigningServer.Android.IO.ByteBuffer signedData = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.GetLengthPrefixedSlice(signer);
                SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.GetLengthPrefixedSlice(signedData);
                SigningServer.Android.IO.ByteBuffer certificatesBuffer = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.GetLengthPrefixedSlice(signedData);
                SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> certificates = new SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate>();
                while (certificatesBuffer.HasRemaining())
                {
                    int certLength = certificatesBuffer.GetInt();
                    sbyte[] certBytes = new sbyte[certLength];
                    if (certLength > certificatesBuffer.Remaining())
                    {
                        throw new System.ArgumentException("Cert index " + (certificates.Size() + 1) + " under signer index " + (signers.Size() + 1) + " size out of range: " + certLength);
                    }
                    certificatesBuffer.Get(certBytes);
                    SigningServer.Android.Com.Android.Apksig.Internal.Util.GuaranteedEncodedFormX509Certificate signerCert = new SigningServer.Android.Com.Android.Apksig.Internal.Util.GuaranteedEncodedFormX509Certificate(SigningServer.Android.Com.Android.Apksig.Internal.Util.X509CertificateUtils.GenerateCertificate(certBytes), certBytes);
                    certificates.Add(signerCert);
                }
                signers.Add(SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair.Of<SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate>, sbyte[]>(certificates, signerBytes));
            }
            return signers;
        }
        
        /// <summary>
        /// Computes the digests of the given APK components according to the algorithms specified in the
        /// given SignerConfigs.
        /// 
        /// @param signerConfigs signer configurations, one for each signer At least one signer config
        ///        must be provided.
        /// @throws IOException if an I/O error occurs
        /// @throws NoSuchAlgorithmException if a required cryptographic algorithm implementation is
        ///         missing
        /// @throws SignatureException if an error occurs when computing digests of generating
        ///         signatures
        /// </summary>
        public static SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignerConfig>, SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]>> ComputeContentDigests(SigningServer.Android.Com.Android.Apksig.Util.RunnablesExecutor executor, SigningServer.Android.Com.Android.Apksig.Util.DataSource beforeCentralDir, SigningServer.Android.Com.Android.Apksig.Util.DataSource centralDir, SigningServer.Android.Com.Android.Apksig.Util.DataSource eocd, SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignerConfig> signerConfigs)
        {
            if (signerConfigs.IsEmpty())
            {
                throw new System.ArgumentException("No signer configs provided. At least one is required");
            }
            SigningServer.Android.Collections.Set<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm> contentDigestAlgorithms = new SigningServer.Android.Collections.HashSet<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm>(1);
            foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignerConfig signerConfig in signerConfigs)
            {
                foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm signatureAlgorithm in signerConfig.signatureAlgorithms)
                {
                    contentDigestAlgorithms.Add(signatureAlgorithm.GetContentDigestAlgorithm());
                }
            }
            SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]> contentDigests;
            try
            {
                contentDigests = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ComputeContentDigests(executor, contentDigestAlgorithms, beforeCentralDir, centralDir, eocd);
            }
            catch (SigningServer.Android.IO.IOException e)
            {
                throw new SigningServer.Android.IO.IOException("Failed to read APK being signed", e);
            }
            catch (SigningServer.Android.Security.DigestException e)
            {
                throw new SigningServer.Android.Security.SignatureException("Failed to compute digests of APK", e);
            }
            return SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair.Of<SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignerConfig>, SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]>>(signerConfigs, contentDigests);
        }
        
        /// <summary>
        /// Returns the subset of signatures which are expected to be verified by at least one Android
        /// platform version in the {@code [minSdkVersion, maxSdkVersion]} range. The returned result is
        /// guaranteed to contain at least one signature.
        /// 
        /// &lt;p&gt;Each Android platform version typically verifies exactly one signature from the provided
        /// {@code signatures} set. This method returns the set of these signatures collected over all
        /// requested platform versions. As a result, the result may contain more than one signature.
        /// 
        /// @throws NoSupportedSignaturesException if no supported signatures were
        ///         found for an Android platform version in the range.
        /// </summary>
        public static SigningServer.Android.Collections.List<T> GetSignaturesToVerify<T>(SigningServer.Android.Collections.List<T> signatures, int minSdkVersion, int maxSdkVersion) where T : ApkSupportedSignature
        {
            return SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.GetSignaturesToVerify<T>(signatures, minSdkVersion, maxSdkVersion, false);
        }
        
        /// <summary>
        /// Returns the subset of signatures which are expected to be verified by at least one Android
        /// platform version in the {@code [minSdkVersion, maxSdkVersion]} range. The returned result is
        /// guaranteed to contain at least one signature.
        /// 
        /// &lt;p&gt;{@code onlyRequireJcaSupport} can be set to true for cases that only require verifying a
        /// signature within the signing block using the standard JCA.
        /// 
        /// &lt;p&gt;Each Android platform version typically verifies exactly one signature from the provided
        /// {@code signatures} set. This method returns the set of these signatures collected over all
        /// requested platform versions. As a result, the result may contain more than one signature.
        /// 
        /// @throws NoSupportedSignaturesException if no supported signatures were
        ///         found for an Android platform version in the range.
        /// </summary>
        public static SigningServer.Android.Collections.List<T> GetSignaturesToVerify<T>(SigningServer.Android.Collections.List<T> signatures, int minSdkVersion, int maxSdkVersion, bool onlyRequireJcaSupport) where T : ApkSupportedSignature
        {
            try
            {
                return SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtilsLite.GetSignaturesToVerify<T>(signatures, minSdkVersion, maxSdkVersion, onlyRequireJcaSupport);
            }
            catch (SigningServer.Android.Com.Android.Apksig.Internal.Apk.NoApkSupportedSignaturesException e)
            {
                throw new SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.NoSupportedSignaturesException(e.GetMessage());
            }
        }
        
        public class NoSupportedSignaturesException: SigningServer.Android.Com.Android.Apksig.Internal.Apk.NoApkSupportedSignaturesException
        {
            public NoSupportedSignaturesException(string message)
                : base (message)
            {
                ;
            }
            
        }
        
        public class SignatureNotFoundException: System.Exception
        {
            internal static readonly long serialVersionUID = 1L;
            
            public SignatureNotFoundException(string message)
                : base (message)
            {
                ;
            }
            
            public SignatureNotFoundException(string message, System.Exception cause)
                : base (message, cause)
            {
                ;
            }
            
        }
        
        /// <summary>
        /// uses the SignatureAlgorithms in the provided signerConfig to sign the provided data
        /// 
        /// @return list of signature algorithm IDs and their corresponding signatures over the data.
        /// </summary>
        public static SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<int, sbyte[]>> GenerateSignaturesOverData(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.SignerConfig signerConfig, sbyte[] data)
        {
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<int, sbyte[]>> signatures = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<int, sbyte[]>>(signerConfig.signatureAlgorithms.Size());
            SigningServer.Android.Security.PublicKey publicKey = signerConfig.certificates.Get(0).GetPublicKey();
            foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm signatureAlgorithm in signerConfig.signatureAlgorithms)
            {
                SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<string, SigningServer.Android.Security.Spec.AlgorithmParameterSpec> sigAlgAndParams = signatureAlgorithm.GetJcaSignatureAlgorithmAndParams();
                string jcaSignatureAlgorithm = sigAlgAndParams.GetFirst();
                SigningServer.Android.Security.Spec.AlgorithmParameterSpec jcaSignatureAlgorithmParams = sigAlgAndParams.GetSecond();
                sbyte[] signatureBytes;
                try
                {
                    SigningServer.Android.Security.Signature signature = SigningServer.Android.Security.Signature.GetInstance(jcaSignatureAlgorithm);
                    signature.InitSign(signerConfig.privateKey);
                    if (jcaSignatureAlgorithmParams != null)
                    {
                        signature.SetParameter(jcaSignatureAlgorithmParams);
                    }
                    signature.Update(data);
                    signatureBytes = signature.Sign();
                }
                catch (SigningServer.Android.Security.InvalidKeyException e)
                {
                    throw new SigningServer.Android.Security.InvalidKeyException("Failed to sign using " + jcaSignatureAlgorithm, e);
                }
                catch (System.Exception e) when ( e is SigningServer.Android.Security.InvalidAlgorithmParameterException || e is SigningServer.Android.Security.SignatureException)
                {
                    throw new SigningServer.Android.Security.SignatureException("Failed to sign using " + jcaSignatureAlgorithm, e);
                }
                try
                {
                    SigningServer.Android.Security.Signature signature = SigningServer.Android.Security.Signature.GetInstance(jcaSignatureAlgorithm);
                    signature.InitVerify(publicKey);
                    if (jcaSignatureAlgorithmParams != null)
                    {
                        signature.SetParameter(jcaSignatureAlgorithmParams);
                    }
                    signature.Update(data);
                    if (!signature.Verify(signatureBytes))
                    {
                        throw new SigningServer.Android.Security.SignatureException("Failed to verify generated " + jcaSignatureAlgorithm + " signature using public key from certificate");
                    }
                }
                catch (SigningServer.Android.Security.InvalidKeyException e)
                {
                    throw new SigningServer.Android.Security.InvalidKeyException("Failed to verify generated " + jcaSignatureAlgorithm + " signature using" + " public key from certificate", e);
                }
                catch (System.Exception e) when ( e is SigningServer.Android.Security.InvalidAlgorithmParameterException || e is SigningServer.Android.Security.SignatureException)
                {
                    throw new SigningServer.Android.Security.SignatureException("Failed to verify generated " + jcaSignatureAlgorithm + " signature using" + " public key from certificate", e);
                }
                signatures.Add(SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair.Of<int, sbyte[]>(signatureAlgorithm.GetId(), signatureBytes));
            }
            return signatures;
        }
        
        /// <summary>
        /// Wrap the signature according to CMS PKCS #7 RFC 5652.
        /// The high-level simplified structure is as follows:
        /// // ContentInfo
        ///     //   digestAlgorithm
        ///     //   SignedData
        ///     //     bag of certificates
        ///     //     SignerInfo
        ///     //       signing cert issuer and serial number (for locating the cert in the above bag)
        ///     //       digestAlgorithm
        ///     //       signatureAlgorithm
        ///     //       signature
        /// 
        /// @throws Asn1EncodingException if the ASN.1 structure could not be encoded
        /// </summary>
        public static sbyte[] GeneratePkcs7DerEncodedMessage(sbyte[] signatureBytes, SigningServer.Android.IO.ByteBuffer data, SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> signerCerts, SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.AlgorithmIdentifier digestAlgorithmId, SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.AlgorithmIdentifier signatureAlgorithmId)
        {
            SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.SignerInfo signerInfo = new SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.SignerInfo();
            signerInfo.version = 1;
            SigningServer.Android.Security.Cert.X509Certificate signingCert = signerCerts.Get(0);
            var signerCertIssuer = signingCert.GetIssuerX500Principal();
            signerInfo.sid = new SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.SignerIdentifier(new SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.IssuerAndSerialNumber(new SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1OpaqueObject(signerCertIssuer.GetEncoded()), signingCert.GetSerialNumber()));
            signerInfo.digestAlgorithm = digestAlgorithmId;
            signerInfo.signatureAlgorithm = signatureAlgorithmId;
            signerInfo.signature = SigningServer.Android.IO.ByteBuffer.Wrap(signatureBytes);
            SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.SignedData signedData = new SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.SignedData();
            signedData.certificates = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1OpaqueObject>(signerCerts.Size());
            foreach (SigningServer.Android.Security.Cert.X509Certificate cert in signerCerts)
            {
                signedData.certificates.Add(new SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1OpaqueObject(cert.GetEncoded()));
            }
            signedData.version = 1;
            signedData.digestAlgorithms = SigningServer.Android.Util.Collections.SingletonList<SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.AlgorithmIdentifier>(digestAlgorithmId);
            signedData.encapContentInfo = new SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.EncapsulatedContentInfo(SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.Pkcs7Constants.OID_DATA);
            signedData.encapContentInfo.content = data;
            signedData.signerInfos = SigningServer.Android.Util.Collections.SingletonList<SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.SignerInfo>(signerInfo);
            SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.ContentInfo contentInfo = new SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.ContentInfo();
            contentInfo.contentType = SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.Pkcs7Constants.OID_SIGNED_DATA;
            contentInfo.content = new SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1OpaqueObject(SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1DerEncoder.Encode(signedData));
            return SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1DerEncoder.Encode(contentInfo);
        }
        
        /// <summary>
        /// Picks the correct v2/v3 digest for v4 signature verification.
        /// 
        /// Keep in sync with pickBestDigestForV4 in framework's ApkSigningBlockUtils.
        /// </summary>
        public static sbyte[] PickBestDigestForV4(SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]> contentDigests)
        {
            foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm algo in SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.V4_CONTENT_DIGEST_ALGORITHMS)
            {
                if (contentDigests.ContainsKey(algo))
                {
                    return contentDigests.Get(algo);
                }
            }
            return null;
        }
        
        /// <summary>
        /// Signer configuration.
        /// </summary>
        public class SignerConfig
        {
            /// <summary>
            /// Private key.
            /// </summary>
            public SigningServer.Android.Security.PrivateKey privateKey;
            
            /// <summary>
            /// Certificates, with the first certificate containing the public key corresponding to
            /// {@link #privateKey}.
            /// </summary>
            public SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> certificates;
            
            /// <summary>
            /// List of signature algorithms with which to sign.
            /// </summary>
            public SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm> signatureAlgorithms;
            
            public int minSdkVersion;
            
            public int maxSdkVersion;
            
            public SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage mSigningCertificateLineage;
            
        }
        
        public class Result: SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigResult
        {
            public SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage signingCertificateLineage = null;
            
            public readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo> signers = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo>();
            
            internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue> mWarnings = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue>();
            
            internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue> mErrors = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue>();
            
            public Result(int signatureSchemeVersion)
                : base (signatureSchemeVersion)
            {
                ;
            }
            
            public virtual bool ContainsErrors()
            {
                if (!mErrors.IsEmpty())
                {
                    return true;
                }
                if (!signers.IsEmpty())
                {
                    foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo signer in signers)
                    {
                        if (signer.ContainsErrors())
                        {
                            return true;
                        }
                    }
                }
                return false;
            }
            
            public virtual bool ContainsWarnings()
            {
                if (!mWarnings.IsEmpty())
                {
                    return true;
                }
                if (!signers.IsEmpty())
                {
                    foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo signer in signers)
                    {
                        if (signer.ContainsWarnings())
                        {
                            return true;
                        }
                    }
                }
                return false;
            }
            
            public virtual void AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue msg, params object[] parameters)
            {
                mErrors.Add(new SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams(msg, parameters));
            }
            
            public virtual void AddWarning(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue msg, params object[] parameters)
            {
                mWarnings.Add(new SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams(msg, parameters));
            }
            
            public override SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue> GetErrors()
            {
                return mErrors;
            }
            
            public override SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerificationIssue> GetWarnings()
            {
                return mWarnings;
            }
            
            public class SignerInfo: SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSignerInfo
            {
                public SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo.ContentDigest> contentDigests = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo.ContentDigest>();
                
                public SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]> verifiedContentDigests = new SigningServer.Android.Collections.HashMap<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]>();
                
                public SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo.Signature> signatures = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo.Signature>();
                
                public SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm, sbyte[]> verifiedSignatures = new SigningServer.Android.Collections.HashMap<SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm, sbyte[]>();
                
                public SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo.AdditionalAttribute> additionalAttributes = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.Result.SignerInfo.AdditionalAttribute>();
                
                public sbyte[] signedData;
                
                public int minSdkVersion;
                
                public int maxSdkVersion;
                
                public SigningServer.Android.Com.Android.Apksig.SigningCertificateLineage signingCertificateLineage;
                
                internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> mWarnings = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams>();
                
                internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> mErrors = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams>();
                
                public virtual void AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue msg, params object[] parameters)
                {
                    mErrors.Add(new SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams(msg, parameters));
                }
                
                public virtual void AddWarning(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue msg, params object[] parameters)
                {
                    mWarnings.Add(new SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams(msg, parameters));
                }
                
                public virtual bool ContainsErrors()
                {
                    return !mErrors.IsEmpty();
                }
                
                public virtual bool ContainsWarnings()
                {
                    return !mWarnings.IsEmpty();
                }
                
                public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> GetErrors()
                {
                    return mErrors;
                }
                
                public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> GetWarnings()
                {
                    return mWarnings;
                }
                
                public class ContentDigest
                {
                    internal readonly int mSignatureAlgorithmId;
                    
                    internal readonly sbyte[] mValue;
                    
                    public ContentDigest(int signatureAlgorithmId, sbyte[] value)
                    {
                        mSignatureAlgorithmId = signatureAlgorithmId;
                        mValue = value;
                    }
                    
                    public virtual int GetSignatureAlgorithmId()
                    {
                        return mSignatureAlgorithmId;
                    }
                    
                    public virtual sbyte[] GetValue()
                    {
                        return mValue;
                    }
                    
                }
                
                public class Signature
                {
                    internal readonly int mAlgorithmId;
                    
                    internal readonly sbyte[] mValue;
                    
                    public Signature(int algorithmId, sbyte[] value)
                    {
                        mAlgorithmId = algorithmId;
                        mValue = value;
                    }
                    
                    public virtual int GetAlgorithmId()
                    {
                        return mAlgorithmId;
                    }
                    
                    public virtual sbyte[] GetValue()
                    {
                        return mValue;
                    }
                    
                }
                
                public class AdditionalAttribute
                {
                    internal readonly int mId;
                    
                    internal readonly sbyte[] mValue;
                    
                    public AdditionalAttribute(int id, sbyte[] value)
                    {
                        mId = id;
                        mValue = (sbyte[])value.Clone();
                    }
                    
                    public virtual int GetId()
                    {
                        return mId;
                    }
                    
                    public virtual sbyte[] GetValue()
                    {
                        return (sbyte[])mValue.Clone();
                    }
                    
                }
                
            }
            
        }
        
        public class SupportedSignature: SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSupportedSignature
        {
            public SupportedSignature(SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm algorithm, sbyte[] signature)
                : base (algorithm, signature)
            {
                ;
            }
            
        }
        
        public class SigningSchemeBlockAndDigests
        {
            public readonly SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<sbyte[], int> signingSchemeBlock;
            
            public readonly SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]> digestInfo;
            
            public SigningSchemeBlockAndDigests(SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<sbyte[], int> signingSchemeBlock, SigningServer.Android.Collections.Map<SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm, sbyte[]> digestInfo)
            {
                this.signingSchemeBlock = signingSchemeBlock;
                this.digestInfo = digestInfo;
            }
            
        }
        
    }
    
}
