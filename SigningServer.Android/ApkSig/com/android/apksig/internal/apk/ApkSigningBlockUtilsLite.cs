// <auto-generated>
// This code was auto-generated.
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
// </auto-generated>

using System;

namespace SigningServer.Android.Com.Android.Apksig.Internal.Apk
{
    /// <summary>
    /// Lightweight version of the ApkSigningBlockUtils for clients that only require a subset of the
    /// utility functionality.
    /// </summary>
    public class ApkSigningBlockUtilsLite
    {
        internal ApkSigningBlockUtilsLite()
        {
        }
        
        internal static readonly char[] HEX_DIGITS = "0123456789abcdef".ToCharArray();
        
        /// <summary>
        /// Returns the APK Signature Scheme block contained in the provided APK file for the given ID
        /// and the additional information relevant for verifying the block against the file.
        /// 
        /// @param blockId the ID value in the APK Signing Block's sequence of ID-value pairs
        ///                identifying the appropriate block to find, e.g. the APK Signature Scheme v2
        ///                block ID.
        /// @throws SignatureNotFoundException if the APK is not signed using given APK Signature Scheme
        /// @throws IOException if an I/O error occurs while reading the APK
        /// </summary>
        public static SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureInfo FindSignature(SigningServer.Android.Com.Android.Apksig.Util.DataSource apk, SigningServer.Android.Com.Android.Apksig.Zip.ZipSections zipSections, int blockId)
        {
            SigningServer.Android.Com.Android.Apksig.Util.DataSource apkSigningBlock;
            long apkSigningBlockOffset;
            try
            {
                SigningServer.Android.Com.Android.Apksig.Apk.ApkUtilsLite.ApkSigningBlock apkSigningBlockInfo = SigningServer.Android.Com.Android.Apksig.Apk.ApkUtilsLite.FindApkSigningBlock(apk, zipSections);
                apkSigningBlockOffset = apkSigningBlockInfo.GetStartOffset();
                apkSigningBlock = apkSigningBlockInfo.GetContents();
            }
            catch (SigningServer.Android.Com.Android.Apksig.Apk.ApkSigningBlockNotFoundException e)
            {
                throw new SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureNotFoundException(e.GetMessage(), e);
            }
            SigningServer.Android.IO.ByteBuffer apkSigningBlockBuf = apkSigningBlock.GetByteBuffer(0, (int)apkSigningBlock.Size());
            apkSigningBlockBuf.Order(SigningServer.Android.IO.ByteOrder.LITTLE_ENDIAN);
            SigningServer.Android.IO.ByteBuffer apkSignatureSchemeBlock = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtilsLite.FindApkSignatureSchemeBlock(apkSigningBlockBuf, blockId);
            return new SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureInfo(apkSignatureSchemeBlock, apkSigningBlockOffset, zipSections.GetZipCentralDirectoryOffset(), zipSections.GetZipEndOfCentralDirectoryOffset(), zipSections.GetZipEndOfCentralDirectory());
        }
        
        public static SigningServer.Android.IO.ByteBuffer FindApkSignatureSchemeBlock(SigningServer.Android.IO.ByteBuffer apkSigningBlock, int blockId)
        {
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtilsLite.CheckByteOrderLittleEndian(apkSigningBlock);
            SigningServer.Android.IO.ByteBuffer pairs = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtilsLite.SliceFromTo(apkSigningBlock, 8, apkSigningBlock.Capacity() - 24);
            int entryCount = 0;
            while (pairs.HasRemaining())
            {
                entryCount++;
                if (pairs.Remaining() < 8)
                {
                    throw new SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureNotFoundException("Insufficient data to read size of APK Signing Block entry #" + entryCount);
                }
                long lenLong = pairs.GetLong();
                if ((lenLong < 4) || (lenLong > SigningServer.Android.Core.IntExtensions.MaxValue))
                {
                    throw new SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureNotFoundException("APK Signing Block entry #" + entryCount + " size out of range: " + lenLong);
                }
                int len = (int)lenLong;
                int nextEntryPos = pairs.Position() + len;
                if (len > pairs.Remaining())
                {
                    throw new SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureNotFoundException("APK Signing Block entry #" + entryCount + " size out of range: " + len + ", available: " + pairs.Remaining());
                }
                int id = pairs.GetInt();
                if (id == blockId)
                {
                    return SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtilsLite.GetByteBuffer(pairs, len - 4);
                }
                pairs.Position(nextEntryPos);
            }
            throw new SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureNotFoundException("No APK Signature Scheme block in APK Signing Block with ID: " + blockId);
        }
        
        public static void CheckByteOrderLittleEndian(SigningServer.Android.IO.ByteBuffer buffer)
        {
            if (buffer.Order() != SigningServer.Android.IO.ByteOrder.LITTLE_ENDIAN)
            {
                throw new System.ArgumentException("ByteBuffer byte order must be little endian");
            }
        }
        
        /// <summary>
        /// Returns the subset of signatures which are expected to be verified by at least one Android
        /// platform version in the {@code [minSdkVersion, maxSdkVersion]} range. The returned result is
        /// guaranteed to contain at least one signature.
        /// 
        /// &lt;p&gt;Each Android platform version typically verifies exactly one signature from the provided
        /// {@code signatures} set. This method returns the set of these signatures collected over all
        /// requested platform versions. As a result, the result may contain more than one signature.
        /// 
        /// @throws NoApkSupportedSignaturesException if no supported signatures were
        ///         found for an Android platform version in the range.
        /// </summary>
        public static SigningServer.Android.Collections.List<T> GetSignaturesToVerify<T>(SigningServer.Android.Collections.List<T> signatures, int minSdkVersion, int maxSdkVersion)
            where T : ApkSupportedSignature
        {
            return SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtilsLite.GetSignaturesToVerify(signatures, minSdkVersion, maxSdkVersion, false);
        }
        
        /// <summary>
        /// Returns the subset of signatures which are expected to be verified by at least one Android
        /// platform version in the {@code [minSdkVersion, maxSdkVersion]} range. The returned result is
        /// guaranteed to contain at least one signature.
        /// 
        /// &lt;p&gt;{@code onlyRequireJcaSupport} can be set to true for cases that only require verifying a
        /// signature within the signing block using the standard JCA.
        /// 
        /// &lt;p&gt;Each Android platform version typically verifies exactly one signature from the provided
        /// {@code signatures} set. This method returns the set of these signatures collected over all
        /// requested platform versions. As a result, the result may contain more than one signature.
        /// 
        /// @throws NoApkSupportedSignaturesException if no supported signatures were
        ///         found for an Android platform version in the range.
        /// </summary>
        public static SigningServer.Android.Collections.List<T> GetSignaturesToVerify<T>(SigningServer.Android.Collections.List<T> signatures, int minSdkVersion, int maxSdkVersion, bool onlyRequireJcaSupport)
            where T : ApkSupportedSignature
        {
            SigningServer.Android.Collections.Map<int?, T> bestSigAlgorithmOnSdkVersion = new SigningServer.Android.Collections.HashMap<int?, T>();
            int minProvidedSignaturesVersion = SigningServer.Android.Core.IntExtensions.MaxValue;
            foreach (T sig in signatures)
            {
                SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm sigAlgorithm = sig.algorithm;
                int sigMinSdkVersion = onlyRequireJcaSupport ? sigAlgorithm.GetJcaSigAlgMinSdkVersion() : sigAlgorithm.GetMinSdkVersion();
                if (sigMinSdkVersion > maxSdkVersion)
                {
                    continue;
                }
                if (sigMinSdkVersion < minProvidedSignaturesVersion)
                {
                    minProvidedSignaturesVersion = sigMinSdkVersion;
                }
                T candidate = bestSigAlgorithmOnSdkVersion.Get(sigMinSdkVersion);
                if ((candidate == null) || (CompareSignatureAlgorithm(sigAlgorithm, candidate.algorithm) > 0))
                {
                    bestSigAlgorithmOnSdkVersion.Put(sigMinSdkVersion, sig);
                }
            }
            if (minSdkVersion < minProvidedSignaturesVersion)
            {
                throw new SigningServer.Android.Com.Android.Apksig.Internal.Apk.NoApkSupportedSignaturesException("Minimum provided signature version " + minProvidedSignaturesVersion + " > minSdkVersion " + minSdkVersion);
            }
            if (bestSigAlgorithmOnSdkVersion.IsEmpty())
            {
                throw new SigningServer.Android.Com.Android.Apksig.Internal.Apk.NoApkSupportedSignaturesException("No supported signature");
            }
            SigningServer.Android.Collections.List<T> signaturesToVerify = new SigningServer.Android.Collections.List<T>(bestSigAlgorithmOnSdkVersion.Values());
            SigningServer.Android.Util.Collections.Sort(signaturesToVerify, ( sig1,  sig2) => sig1.algorithm.GetId().CompareTo(sig2.algorithm.GetId()));
            return signaturesToVerify;
        }
        
        /// <summary>
        /// Returns positive number if {@code alg1} is preferred over {@code alg2}, {@code -1} if
        /// {@code alg2} is preferred over {@code alg1}, and {@code 0} if there is no preference.
        /// </summary>
        public static int CompareSignatureAlgorithm(SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm alg1, SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm alg2)
        {
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm digestAlg1 = alg1.GetContentDigestAlgorithm();
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm digestAlg2 = alg2.GetContentDigestAlgorithm();
            return SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtilsLite.CompareContentDigestAlgorithm(digestAlg1, digestAlg2);
        }
        
        /// <summary>
        /// Returns a positive number if {@code alg1} is preferred over {@code alg2}, a negative number
        /// if {@code alg2} is preferred over {@code alg1}, or {@code 0} if there is no preference.
        /// </summary>
        internal static int CompareContentDigestAlgorithm(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm alg1, SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm alg2)
        {
            switch (alg1.Case)
            {
                case SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm.CHUNKED_SHA256_CASE:
                    switch (alg2.Case)
                    {
                        case SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm.CHUNKED_SHA256_CASE:
                            return 0;
                        case SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm.CHUNKED_SHA512_CASE:
                        case SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm.VERITY_CHUNKED_SHA256_CASE:
                            return -1;
                        default:
                            throw new System.ArgumentException("Unknown alg2: " + alg2);
                    }
                case SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm.CHUNKED_SHA512_CASE:
                    switch (alg2.Case)
                    {
                        case SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm.CHUNKED_SHA256_CASE:
                        case SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm.VERITY_CHUNKED_SHA256_CASE:
                            return 1;
                        case SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm.CHUNKED_SHA512_CASE:
                            return 0;
                        default:
                            throw new System.ArgumentException("Unknown alg2: " + alg2);
                    }
                case SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm.VERITY_CHUNKED_SHA256_CASE:
                    switch (alg2.Case)
                    {
                        case SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm.CHUNKED_SHA256_CASE:
                            return 1;
                        case SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm.VERITY_CHUNKED_SHA256_CASE:
                            return 0;
                        case SigningServer.Android.Com.Android.Apksig.Internal.Apk.ContentDigestAlgorithm.CHUNKED_SHA512_CASE:
                            return -1;
                        default:
                            throw new System.ArgumentException("Unknown alg2: " + alg2);
                    }
                default:
                    throw new System.ArgumentException("Unknown alg1: " + alg1);
            }
        }
        
        /// <summary>
        /// Returns new byte buffer whose content is a shared subsequence of this buffer's content
        /// between the specified start (inclusive) and end (exclusive) positions. As opposed to
        /// {@link ByteBuffer#slice()}, the returned buffer's byte order is the same as the source
        /// buffer's byte order.
        /// </summary>
        internal static SigningServer.Android.IO.ByteBuffer SliceFromTo(SigningServer.Android.IO.ByteBuffer source, int start, int end)
        {
            if (start < 0)
            {
                throw new System.ArgumentException("start: " + start);
            }
            if (end < start)
            {
                throw new System.ArgumentException("end < start: " + end + " < " + start);
            }
            int capacity = source.Capacity();
            if (end > source.Capacity())
            {
                throw new System.ArgumentException("end > capacity: " + end + " > " + capacity);
            }
            int originalLimit = source.Limit();
            int originalPosition = source.Position();
            try
            {
                source.Position(0);
                source.Limit(end);
                source.Position(start);
                SigningServer.Android.IO.ByteBuffer result = source.Slice();
                result.Order(source.Order());
                return result;
            }
            finally
            {
                source.Position(0);
                source.Limit(originalLimit);
                source.Position(originalPosition);
            }
        }
        
        /// <summary>
        /// Relative &lt;em&gt;get&lt;/em&gt; method for reading {@code size} number of bytes from the current
        /// position of this buffer.
        /// 
        /// &lt;p&gt;This method reads the next {@code size} bytes at this buffer's current position,
        /// returning them as a {@code ByteBuffer} with start set to 0, limit and capacity set to
        /// {@code size}, byte order set to this buffer's byte order; and then increments the position by
        /// {@code size}.
        /// </summary>
        internal static SigningServer.Android.IO.ByteBuffer GetByteBuffer(SigningServer.Android.IO.ByteBuffer source, int size)
        {
            if (size < 0)
            {
                throw new System.ArgumentException("size: " + size);
            }
            int originalLimit = source.Limit();
            int position = source.Position();
            int limit = position + size;
            if ((limit < position) || (limit > originalLimit))
            {
                throw new SigningServer.Android.IO.BufferUnderflowException();
            }
            source.Limit(limit);
            try
            {
                SigningServer.Android.IO.ByteBuffer result = source.Slice();
                result.Order(source.Order());
                source.Position(limit);
                return result;
            }
            finally
            {
                source.Limit(originalLimit);
            }
        }
        
        public static string ToHex(sbyte[] value)
        {
            SigningServer.Android.Core.StringBuilder sb = new SigningServer.Android.Core.StringBuilder(value.Length * 2);
            int len = value.Length;
            for (int i = 0;i < len;i++)
            {
                int hi = SigningServer.Android.TypeUtils.UnsignedRightShift((value[i] & 0xff), 4);
                int lo = value[i] & 0x0f;
                sb.Append(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtilsLite.HEX_DIGITS[hi]).Append(SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtilsLite.HEX_DIGITS[lo]);
            }
            return sb.ToString();
        }
        
        public static SigningServer.Android.IO.ByteBuffer GetLengthPrefixedSlice(SigningServer.Android.IO.ByteBuffer source)
        {
            if (source.Remaining() < 4)
            {
                throw new SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException("Remaining buffer too short to contain length of length-prefixed field" + ". Remaining: " + source.Remaining());
            }
            int len = source.GetInt();
            if (len < 0)
            {
                throw new System.ArgumentException("Negative length");
            }
            else if (len > source.Remaining())
            {
                throw new SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException("Length-prefixed field longer than remaining buffer" + ". Field length: " + len + ", remaining: " + source.Remaining());
            }
            return SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtilsLite.GetByteBuffer(source, len);
        }
        
        public static sbyte[] ReadLengthPrefixedByteArray(SigningServer.Android.IO.ByteBuffer buf)
        {
            int len = buf.GetInt();
            if (len < 0)
            {
                throw new SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException("Negative length");
            }
            else if (len > buf.Remaining())
            {
                throw new SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException("Underflow while reading length-prefixed value. Length: " + len + ", available: " + buf.Remaining());
            }
            sbyte[] result = new sbyte[len];
            buf.Get(result);
            return result;
        }
        
        public static sbyte[] EncodeAsSequenceOfLengthPrefixedPairsOfIntAndLengthPrefixedBytes(SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<int, sbyte[]>> sequence)
        {
            int resultSize = 0;
            foreach (SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<int, sbyte[]> element in sequence)
            {
                resultSize += 12 + element.GetSecond().Length;
            }
            SigningServer.Android.IO.ByteBuffer result = SigningServer.Android.IO.ByteBuffer.Allocate(resultSize);
            result.Order(SigningServer.Android.IO.ByteOrder.LITTLE_ENDIAN);
            foreach (SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<int, sbyte[]> element in sequence)
            {
                sbyte[] second = element.GetSecond();
                result.PutInt(8 + second.Length);
                result.PutInt(element.GetFirst());
                result.PutInt(second.Length);
                result.Put(second);
            }
            return result.Array();
        }
        
    }
    
}
