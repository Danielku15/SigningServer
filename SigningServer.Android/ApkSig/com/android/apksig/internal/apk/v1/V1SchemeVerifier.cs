// <auto-generated>
// This code was auto-generated.
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
// </auto-generated>

using System;

namespace SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1
{
    /// <summary>
    /// APK verifier which uses JAR signing (aka v1 signing scheme).
    /// 
    /// @see &lt;a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html#Signed_JAR_File"&gt;Signed JAR File&lt;/a&gt;
    /// </summary>
    public abstract class V1SchemeVerifier
    {
        internal V1SchemeVerifier()
        {
        }
        
        /// <summary>
        /// Verifies the provided APK's JAR signatures and returns the result of verification. APK is
        /// considered verified only if {@link Result#verified} is {@code true}. If verification fails,
        /// the result will contain errors -- see {@link Result#getErrors()}.
        /// 
        /// &lt;p&gt;Verification succeeds iff the APK's JAR signatures are expected to verify on all Android
        /// platform versions in the {@code [minSdkVersion, maxSdkVersion]} range. If the APK's signature
        /// is expected to not verify on any of the specified platform versions, this method returns a
        /// result with one or more errors and whose {@code Result.verified == false}, or this method
        /// throws an exception.
        /// 
        /// @throws ApkFormatException if the APK is malformed
        /// @throws IOException if an I/O error occurs when reading the APK
        /// @throws NoSuchAlgorithmException if the APK's JAR signatures cannot be verified because a
        ///         required cryptographic algorithm implementation is missing
        /// </summary>
        public static SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Result Verify(SigningServer.Android.Com.Android.Apksig.Util.DataSource apk, SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.ZipSections apkSections, SigningServer.Android.Collections.Map<int?, string> supportedApkSigSchemeNames, SigningServer.Android.Collections.Set<int?> foundApkSigSchemeIds, int minSdkVersion, int maxSdkVersion)
        {
            if (minSdkVersion > maxSdkVersion)
            {
                throw new System.ArgumentException("minSdkVersion (" + minSdkVersion + ") > maxSdkVersion (" + maxSdkVersion + ")");
            }
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Result result = new SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Result();
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord> cdRecords = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.ParseZipCentralDirectory(apk, apkSections);
            SigningServer.Android.Collections.Set<string> cdEntryNames = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.CheckForDuplicateEntries(cdRecords, result);
            if (result.ContainsErrors())
            {
                return result;
            }
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Signers.Verify(
                apk
                , 
                apkSections.GetZipCentralDirectoryOffset()
                , 
                cdRecords
                , 
                cdEntryNames
                , 
                supportedApkSigSchemeNames
                , 
                foundApkSigSchemeIds
                , 
                minSdkVersion
                , 
                maxSdkVersion
                , 
                result
            
            );
            return result;
        }
        
        /// <summary>
        /// Returns the set of entry names and reports any duplicate entry names in the {@code result}
        /// as errors.
        /// </summary>
        internal static SigningServer.Android.Collections.Set<string> CheckForDuplicateEntries(SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord> cdRecords, SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Result result)
        {
            SigningServer.Android.Collections.Set<string> cdEntryNames = new SigningServer.Android.Collections.HashSet<string>(cdRecords.Size());
            SigningServer.Android.Collections.Set<string> duplicateCdEntryNames = null;
            foreach (SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord cdRecord in cdRecords)
            {
                string entryName = cdRecord.GetName();
                if (!cdEntryNames.Add(entryName))
                {
                    if (duplicateCdEntryNames == null)
                    {
                        duplicateCdEntryNames = new SigningServer.Android.Collections.HashSet<string>();
                    }
                    if (duplicateCdEntryNames.Add(entryName))
                    {
                        result.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.JAR_SIG_DUPLICATE_ZIP_ENTRY, entryName);
                    }
                }
            }
            return cdEntryNames;
        }
        
        /// <summary>
        /// Parses raw representation of MANIFEST.MF file into a pair of main entry manifest section
        /// representation and a mapping between entry name and its manifest section representation.
        /// 
        /// @param manifestBytes raw representation of Manifest.MF
        /// @param cdEntryNames expected set of entry names
        /// @param result object to keep track of errors that happened during the parsing
        /// @return a pair of main entry manifest section representation and a mapping between entry name
        ///     and its manifest section representation
        /// </summary>
        public static SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<SigningServer.Android.Com.Android.Apksig.Internal.Jar.ManifestParser.Section, SigningServer.Android.Collections.Map<string, SigningServer.Android.Com.Android.Apksig.Internal.Jar.ManifestParser.Section>> ParseManifest(sbyte[] manifestBytes, SigningServer.Android.Collections.Set<string> cdEntryNames, SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Result result)
        {
            SigningServer.Android.Com.Android.Apksig.Internal.Jar.ManifestParser manifest = new SigningServer.Android.Com.Android.Apksig.Internal.Jar.ManifestParser(manifestBytes);
            SigningServer.Android.Com.Android.Apksig.Internal.Jar.ManifestParser.Section manifestMainSection = manifest.ReadSection();
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Jar.ManifestParser.Section> manifestIndividualSections = manifest.ReadAllSections();
            SigningServer.Android.Collections.Map<string, SigningServer.Android.Com.Android.Apksig.Internal.Jar.ManifestParser.Section> entryNameToManifestSection = new SigningServer.Android.Collections.HashMap<string, SigningServer.Android.Com.Android.Apksig.Internal.Jar.ManifestParser.Section>(manifestIndividualSections.Size());
            int manifestSectionNumber = 0;
            foreach (SigningServer.Android.Com.Android.Apksig.Internal.Jar.ManifestParser.Section manifestSection in manifestIndividualSections)
            {
                manifestSectionNumber++;
                string entryName = manifestSection.GetName();
                if (entryName == null)
                {
                    result.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.JAR_SIG_UNNNAMED_MANIFEST_SECTION, manifestSectionNumber);
                    continue;
                }
                if (entryNameToManifestSection.Put(entryName, manifestSection) != null)
                {
                    result.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.JAR_SIG_DUPLICATE_MANIFEST_SECTION, entryName);
                    continue;
                }
                if (!cdEntryNames.Contains(entryName))
                {
                    result.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.JAR_SIG_MISSING_ZIP_ENTRY_REFERENCED_IN_MANIFEST, entryName);
                    continue;
                }
            }
            return SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair.Of<SigningServer.Android.Com.Android.Apksig.Internal.Jar.ManifestParser.Section, SigningServer.Android.Collections.Map<string, SigningServer.Android.Com.Android.Apksig.Internal.Jar.ManifestParser.Section>>(manifestMainSection, entryNameToManifestSection);
        }
        
        /// <summary>
        /// All JAR signers of an APK.
        /// </summary>
        internal class Signers
        {
            /// <summary>
            /// Verifies JAR signatures of the provided APK and populates the provided result container
            /// with errors, warnings, and information about signers. The APK is considered verified if
            /// the {@link Result#verified} is {@code true}.
            /// </summary>
            internal static void Verify(SigningServer.Android.Com.Android.Apksig.Util.DataSource apk, long cdStartOffset, SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord> cdRecords, SigningServer.Android.Collections.Set<string> cdEntryNames, SigningServer.Android.Collections.Map<int?, string> supportedApkSigSchemeNames, SigningServer.Android.Collections.Set<int?> foundApkSigSchemeIds, int minSdkVersion, int maxSdkVersion, SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Result result)
            {
                SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord manifestEntry = null;
                SigningServer.Android.Collections.Map<string, SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord> sigFileEntries = new SigningServer.Android.Collections.HashMap<string, SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord>(1);
                SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord> sigBlockEntries = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord>(1);
                foreach (SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord cdRecord in cdRecords)
                {
                    string entryName = cdRecord.GetName();
                    if (!entryName.StartsWith("META-INF/"))
                    {
                        continue;
                    }
                    if ((manifestEntry == null) && (SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeConstants.MANIFEST_ENTRY_NAME.Equals(entryName)))
                    {
                        manifestEntry = cdRecord;
                        continue;
                    }
                    if (entryName.EndsWith(".SF"))
                    {
                        sigFileEntries.Put(entryName, cdRecord);
                        continue;
                    }
                    if ((entryName.EndsWith(".RSA")) || (entryName.EndsWith(".DSA")) || (entryName.EndsWith(".EC")))
                    {
                        sigBlockEntries.Add(cdRecord);
                        continue;
                    }
                }
                if (manifestEntry == null)
                {
                    result.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.JAR_SIG_NO_MANIFEST);
                    return;
                }
                sbyte[] manifestBytes;
                try
                {
                    manifestBytes = SigningServer.Android.Com.Android.Apksig.Internal.Zip.LocalFileRecord.GetUncompressedData(apk, manifestEntry, cdStartOffset);
                }
                catch (SigningServer.Android.Com.Android.Apksig.Zip.ZipFormatException e)
                {
                    throw new SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException("Malformed ZIP entry: " + manifestEntry.GetName(), e);
                }
                SigningServer.Android.Com.Android.Apksig.Internal.Util.Pair<SigningServer.Android.Com.Android.Apksig.Internal.Jar.ManifestParser.Section, SigningServer.Android.Collections.Map<string, SigningServer.Android.Com.Android.Apksig.Internal.Jar.ManifestParser.Section>> manifestSections = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.ParseManifest(manifestBytes, cdEntryNames, result);
                if (result.ContainsErrors())
                {
                    return;
                }
                SigningServer.Android.Com.Android.Apksig.Internal.Jar.ManifestParser.Section manifestMainSection = manifestSections.GetFirst();
                SigningServer.Android.Collections.Map<string, SigningServer.Android.Com.Android.Apksig.Internal.Jar.ManifestParser.Section> entryNameToManifestSection = manifestSections.GetSecond();
                SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Signer> signers = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Signer>(sigBlockEntries.Size());
                foreach (SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord sigBlockEntry in sigBlockEntries)
                {
                    string sigBlockEntryName = sigBlockEntry.GetName();
                    int extensionDelimiterIndex = sigBlockEntryName.LastIndexOf('.');
                    if (extensionDelimiterIndex == -1)
                    {
                        throw new SigningServer.Android.Core.RuntimeException("Signature block file name does not contain extension: " + sigBlockEntryName);
                    }
                    string sigFileEntryName = sigBlockEntryName.Substring(0, extensionDelimiterIndex) + ".SF";
                    SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord sigFileEntry = sigFileEntries.Get(sigFileEntryName);
                    if (sigFileEntry == null)
                    {
                        result.AddWarning(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.JAR_SIG_MISSING_FILE, sigBlockEntryName, sigFileEntryName);
                        continue;
                    }
                    string signerName = sigBlockEntryName.Substring("META-INF/".Length());
                    SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Result.SignerInfo signerInfo = new SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Result.SignerInfo(signerName, sigBlockEntryName, sigFileEntry.GetName());
                    SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Signer signer = new SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Signer(signerName, sigBlockEntry, sigFileEntry, signerInfo);
                    signers.Add(signer);
                }
                if (signers.IsEmpty())
                {
                    result.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.JAR_SIG_NO_SIGNATURES);
                    return;
                }
                foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Signer signer in signers)
                {
                    signer.VerifySigBlockAgainstSigFile(apk, cdStartOffset, minSdkVersion, maxSdkVersion);
                    if (signer.GetResult().ContainsErrors())
                    {
                        result.signers.Add(signer.GetResult());
                    }
                }
                if (result.ContainsErrors())
                {
                    return;
                }
                SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Signer> remainingSigners = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Signer>(signers.Size());
                foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Signer signer in signers)
                {
                    signer.VerifySigFileAgainstManifest(
                        manifestBytes
                        , 
                        manifestMainSection
                        , 
                        entryNameToManifestSection
                        , 
                        supportedApkSigSchemeNames
                        , 
                        foundApkSigSchemeIds
                        , 
                        minSdkVersion
                        , 
                        maxSdkVersion
                    
                    );
                    if (signer.IsIgnored())
                    {
                        result.ignoredSigners.Add(signer.GetResult());
                    }
                    else 
                    {
                        if (signer.GetResult().ContainsErrors())
                        {
                            result.signers.Add(signer.GetResult());
                        }
                        else 
                        {
                            remainingSigners.Add(signer);
                        }
                    }
                }
                if (result.ContainsErrors())
                {
                    return;
                }
                signers = remainingSigners;
                if (signers.IsEmpty())
                {
                    result.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.JAR_SIG_NO_SIGNATURES);
                    return;
                }
                SigningServer.Android.Collections.Set<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Signer> apkSigners = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.VerifyJarEntriesAgainstManifestAndSigners(
                    apk
                    , 
                    cdStartOffset
                    , 
                    cdRecords
                    , 
                    entryNameToManifestSection
                    , 
                    signers
                    , 
                    minSdkVersion
                    , 
                    maxSdkVersion
                    , 
                    result
                
                );
                if (result.ContainsErrors())
                {
                    return;
                }
                SigningServer.Android.Collections.Set<string> signatureEntryNames = new SigningServer.Android.Collections.HashSet<string>(1 + result.signers.Size() * 2);
                signatureEntryNames.Add(manifestEntry.GetName());
                foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Signer signer in apkSigners)
                {
                    signatureEntryNames.Add(signer.GetSignatureBlockEntryName());
                    signatureEntryNames.Add(signer.GetSignatureFileEntryName());
                }
                foreach (SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord cdRecord in cdRecords)
                {
                    string entryName = cdRecord.GetName();
                    if ((entryName.StartsWith("META-INF/")) && (!entryName.EndsWith("/")) && (!signatureEntryNames.Contains(entryName)))
                    {
                        result.AddWarning(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.JAR_SIG_UNPROTECTED_ZIP_ENTRY, entryName);
                    }
                }
                foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Signer signer in signers)
                {
                    if (apkSigners.Contains(signer))
                    {
                        result.signers.Add(signer.GetResult());
                    }
                    else 
                    {
                        result.ignoredSigners.Add(signer.GetResult());
                    }
                }
                result.verified = true;
            }
            
        }
        
        internal class Signer
        {
            internal readonly string mName;
            
            internal readonly SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Result.SignerInfo mResult;
            
            internal readonly SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord mSignatureFileEntry;
            
            internal readonly SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord mSignatureBlockEntry;
            
            internal bool mIgnored;
            
            internal sbyte[] mSigFileBytes;
            
            internal SigningServer.Android.Collections.Set<string> mSigFileEntryNames;
            
            internal Signer(string name, SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord sigBlockEntry, SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord sigFileEntry, SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Result.SignerInfo result)
            {
                mName = name;
                mResult = result;
                mSignatureBlockEntry = sigBlockEntry;
                mSignatureFileEntry = sigFileEntry;
            }
            
            public virtual string GetName()
            {
                return mName;
            }
            
            public virtual string GetSignatureFileEntryName()
            {
                return mSignatureFileEntry.GetName();
            }
            
            public virtual string GetSignatureBlockEntryName()
            {
                return mSignatureBlockEntry.GetName();
            }
            
            public virtual void SetIgnored()
            {
                mIgnored = true;
            }
            
            public virtual bool IsIgnored()
            {
                return mIgnored;
            }
            
            public virtual SigningServer.Android.Collections.Set<string> GetSigFileEntryNames()
            {
                return mSigFileEntryNames;
            }
            
            public virtual SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Result.SignerInfo GetResult()
            {
                return mResult;
            }
            
            public virtual void VerifySigBlockAgainstSigFile(SigningServer.Android.Com.Android.Apksig.Util.DataSource apk, long cdStartOffset, int minSdkVersion, int maxSdkVersion)
            {
                sbyte[] sigBlockBytes;
                try
                {
                    sigBlockBytes = SigningServer.Android.Com.Android.Apksig.Internal.Zip.LocalFileRecord.GetUncompressedData(apk, mSignatureBlockEntry, cdStartOffset);
                }
                catch (SigningServer.Android.Com.Android.Apksig.Zip.ZipFormatException e)
                {
                    throw new SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException("Malformed ZIP entry: " + mSignatureBlockEntry.GetName(), e);
                }
                try
                {
                    mSigFileBytes = SigningServer.Android.Com.Android.Apksig.Internal.Zip.LocalFileRecord.GetUncompressedData(apk, mSignatureFileEntry, cdStartOffset);
                }
                catch (SigningServer.Android.Com.Android.Apksig.Zip.ZipFormatException e)
                {
                    throw new SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException("Malformed ZIP entry: " + mSignatureFileEntry.GetName(), e);
                }
                SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.SignedData signedData;
                try
                {
                    SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.ContentInfo contentInfo = SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1BerParser.Parse(SigningServer.Android.IO.ByteBuffer.Wrap(sigBlockBytes), typeof(SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.ContentInfo));
                    if (!SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.Pkcs7Constants.OID_SIGNED_DATA.Equals(contentInfo.contentType))
                    {
                        throw new SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1DecodingException("Unsupported ContentInfo.contentType: " + contentInfo.contentType);
                    }
                    signedData = SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1BerParser.Parse(contentInfo.content.GetEncoded(), typeof(SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.SignedData));
                }
                catch (SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1DecodingException e)
                {
                    e.PrintStackTrace();
                    mResult.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.JAR_SIG_PARSE_EXCEPTION, mSignatureBlockEntry.GetName(), e);
                    return;
                }
                if (signedData.signerInfos.IsEmpty())
                {
                    mResult.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.JAR_SIG_NO_SIGNERS, mSignatureBlockEntry.GetName());
                    return;
                }
                SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.SignerInfo firstVerifiedSignerInfo = null;
                SigningServer.Android.Security.Cert.X509Certificate firstVerifiedSignerInfoSigningCertificate = null;
                SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.SignerInfo> unverifiedSignerInfosToTry;
                if (minSdkVersion < SigningServer.Android.Com.Android.Apksig.Internal.Util.AndroidSdkVersion.N)
                {
                    unverifiedSignerInfosToTry = SigningServer.Android.Util.Collections.SingletonList<SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.SignerInfo>(signedData.signerInfos.Get(0));
                }
                else 
                {
                    unverifiedSignerInfosToTry = signedData.signerInfos;
                }
                SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> signedDataCertificates = null;
                foreach (SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.SignerInfo unverifiedSignerInfo in unverifiedSignerInfosToTry)
                {
                    if (signedDataCertificates == null)
                    {
                        try
                        {
                            signedDataCertificates = SigningServer.Android.Com.Android.Apksig.Internal.X509.Certificate.ParseCertificates(signedData.certificates);
                        }
                        catch (SigningServer.Android.Security.Cert.CertificateException e)
                        {
                            mResult.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.JAR_SIG_PARSE_EXCEPTION, mSignatureBlockEntry.GetName(), e);
                            return;
                        }
                    }
                    SigningServer.Android.Security.Cert.X509Certificate signingCertificate;
                    try
                    {
                        signingCertificate = VerifySignerInfoAgainstSigFile(
                            signedData
                            , 
                            signedDataCertificates
                            , 
                            unverifiedSignerInfo
                            , 
                            mSigFileBytes
                            , 
                            minSdkVersion
                            , 
                            maxSdkVersion
                        
                        );
                        if (mResult.ContainsErrors())
                        {
                            return;
                        }
                        if (signingCertificate != null)
                        {
                            if (firstVerifiedSignerInfo == null)
                            {
                                firstVerifiedSignerInfo = unverifiedSignerInfo;
                                firstVerifiedSignerInfoSigningCertificate = signingCertificate;
                            }
                        }
                    }
                    catch (SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.Pkcs7DecodingException e)
                    {
                        mResult.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.JAR_SIG_PARSE_EXCEPTION, mSignatureBlockEntry.GetName(), e);
                        return;
                    }
                    catch (System.Exception e) when ( e is SigningServer.Android.Security.InvalidKeyException || e is SigningServer.Android.Security.SignatureException)
                    {
                        mResult.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.JAR_SIG_VERIFY_EXCEPTION, mSignatureBlockEntry.GetName(), mSignatureFileEntry.GetName(), e);
                        return;
                    }
                }
                if (firstVerifiedSignerInfo == null)
                {
                    mResult.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.JAR_SIG_DID_NOT_VERIFY, mSignatureBlockEntry.GetName(), mSignatureFileEntry.GetName());
                    return;
                }
                SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> signingCertChain = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Signer.GetCertificateChain(signedDataCertificates, firstVerifiedSignerInfoSigningCertificate);
                mResult.certChain.Clear();
                mResult.certChain.AddAll(signingCertChain);
            }
            
            /// <summary>
            /// Returns the signing certificate if the provided {@link SignerInfo} verifies against the
            /// contents of the provided signature file, or {@code null} if it does not verify.
            /// </summary>
            internal SigningServer.Android.Security.Cert.X509Certificate VerifySignerInfoAgainstSigFile(SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.SignedData signedData, SigningServer.Android.Collections.Collection<SigningServer.Android.Security.Cert.X509Certificate> signedDataCertificates, SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.SignerInfo signerInfo, sbyte[] signatureFile, int minSdkVersion, int maxSdkVersion)
            {
                string digestAlgorithmOid = signerInfo.digestAlgorithm.algorithm;
                string signatureAlgorithmOid = signerInfo.signatureAlgorithm.algorithm;
                SigningServer.Android.Com.Android.Apksig.Internal.Util.InclusiveIntRange desiredApiLevels = SigningServer.Android.Com.Android.Apksig.Internal.Util.InclusiveIntRange.FromTo(minSdkVersion, maxSdkVersion);
                SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Util.InclusiveIntRange> apiLevelsWhereDigestAndSigAlgorithmSupported = SigningServer.Android.Com.Android.Apksig.Internal.Oid.OidConstants.GetSigAlgSupportedApiLevels(digestAlgorithmOid, signatureAlgorithmOid);
                SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Util.InclusiveIntRange> apiLevelsWhereDigestAlgorithmNotSupported = desiredApiLevels.GetValuesNotIn(apiLevelsWhereDigestAndSigAlgorithmSupported);
                if (!apiLevelsWhereDigestAlgorithmNotSupported.IsEmpty())
                {
                    string digestAlgorithmUserFriendly = SigningServer.Android.Com.Android.Apksig.Internal.Oid.OidConstants.OidToUserFriendlyNameMapper.GetUserFriendlyNameForOid(digestAlgorithmOid);
                    if (digestAlgorithmUserFriendly == null)
                    {
                        digestAlgorithmUserFriendly = digestAlgorithmOid;
                    }
                    string signatureAlgorithmUserFriendly = SigningServer.Android.Com.Android.Apksig.Internal.Oid.OidConstants.OidToUserFriendlyNameMapper.GetUserFriendlyNameForOid(signatureAlgorithmOid);
                    if (signatureAlgorithmUserFriendly == null)
                    {
                        signatureAlgorithmUserFriendly = signatureAlgorithmOid;
                    }
                    SigningServer.Android.Core.StringBuilder apiLevelsUserFriendly = new SigningServer.Android.Core.StringBuilder();
                    foreach (SigningServer.Android.Com.Android.Apksig.Internal.Util.InclusiveIntRange range in apiLevelsWhereDigestAlgorithmNotSupported)
                    {
                        if (apiLevelsUserFriendly.Length() > 0)
                        {
                            apiLevelsUserFriendly.Append(", ");
                        }
                        if (range.GetMin() == range.GetMax())
                        {
                            apiLevelsUserFriendly.Append(SigningServer.Android.Core.StringExtensions.ValueOf(range.GetMin()));
                        }
                        else if (range.GetMax() == SigningServer.Android.Core.IntExtensions.MaxValue)
                        {
                            apiLevelsUserFriendly.Append(range.GetMin() + "+");
                        }
                        else 
                        {
                            apiLevelsUserFriendly.Append(range.GetMin() + "-" + range.GetMax());
                        }
                    }
                    mResult.AddError(
                        SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.JAR_SIG_UNSUPPORTED_SIG_ALG
                        , 
                        mSignatureBlockEntry.GetName()
                        , 
                        digestAlgorithmOid
                        , 
                        signatureAlgorithmOid
                        , 
                        apiLevelsUserFriendly.ToString()
                        , 
                        digestAlgorithmUserFriendly
                        , 
                        signatureAlgorithmUserFriendly
                    
                    );
                    return null;
                }
                SigningServer.Android.Security.Cert.X509Certificate signingCertificate = SigningServer.Android.Com.Android.Apksig.Internal.X509.Certificate.FindCertificate(signedDataCertificates, signerInfo.sid);
                if (signingCertificate == null)
                {
                    throw new SigningServer.Android.Security.SignatureException("Signing certificate referenced in SignerInfo not found in" + " SignedData");
                }
                if (signingCertificate.HasUnsupportedCriticalExtension())
                {
                    throw new SigningServer.Android.Security.SignatureException("Signing certificate has unsupported critical extensions");
                }
                bool[] keyUsageExtension = signingCertificate.GetKeyUsage();
                if (keyUsageExtension != null)
                {
                    bool digitalSignature = (keyUsageExtension.Length >= 1) && (keyUsageExtension[0]);
                    bool nonRepudiation = (keyUsageExtension.Length >= 2) && (keyUsageExtension[1]);
                    if ((!digitalSignature) && (!nonRepudiation))
                    {
                        throw new SigningServer.Android.Security.SignatureException("Signing certificate not authorized for use in digital signatures" + ": keyUsage extension missing digitalSignature and" + " nonRepudiation");
                    }
                }
                string jcaSignatureAlgorithm = SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.AlgorithmIdentifier.GetJcaSignatureAlgorithm(digestAlgorithmOid, signatureAlgorithmOid);
                SigningServer.Android.Security.Signature s = SigningServer.Android.Security.Signature.GetInstance(jcaSignatureAlgorithm);
                s.InitVerify(signingCertificate.GetPublicKey());
                if (signerInfo.signedAttrs != null)
                {
                    if (minSdkVersion < SigningServer.Android.Com.Android.Apksig.Internal.Util.AndroidSdkVersion.KITKAT)
                    {
                        throw new SigningServer.Android.Security.SignatureException("APKs with Signed Attributes broken on platforms with API Level < " + SigningServer.Android.Com.Android.Apksig.Internal.Util.AndroidSdkVersion.KITKAT);
                    }
                    try
                    {
                        SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.Attribute> signedAttributes = SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1BerParser.ParseImplicitSetOf(signerInfo.signedAttrs.GetEncoded(), typeof(SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.Attribute));
                        SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.SignedAttributes signedAttrs = new SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.SignedAttributes(signedAttributes);
                        if (maxSdkVersion >= SigningServer.Android.Com.Android.Apksig.Internal.Util.AndroidSdkVersion.N)
                        {
                            string contentType = signedAttrs.GetSingleObjectIdentifierValue(SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.Pkcs7Constants.OID_CONTENT_TYPE);
                            if (contentType == null)
                            {
                                throw new SigningServer.Android.Security.SignatureException("No Content Type in signed attributes");
                            }
                            if (!contentType.Equals(signedData.encapContentInfo.contentType))
                            {
                                return null;
                            }
                        }
                        sbyte[] expectedSignatureFileDigest = signedAttrs.GetSingleOctetStringValue(SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.Pkcs7Constants.OID_MESSAGE_DIGEST);
                        if (expectedSignatureFileDigest == null)
                        {
                            throw new SigningServer.Android.Security.SignatureException("No content digest in signed attributes");
                        }
                        sbyte[] actualSignatureFileDigest = SigningServer.Android.Security.MessageDigest.GetInstance(SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.AlgorithmIdentifier.GetJcaDigestAlgorithm(digestAlgorithmOid)).Digest(signatureFile);
                        if (!SigningServer.Android.Collections.Arrays.Equals(expectedSignatureFileDigest, actualSignatureFileDigest))
                        {
                            return null;
                        }
                    }
                    catch (SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1DecodingException e)
                    {
                        throw new SigningServer.Android.Security.SignatureException("Failed to parse signed attributes", e);
                    }
                    SigningServer.Android.IO.ByteBuffer signedAttrsOriginalEncoding = signerInfo.signedAttrs.GetEncoded();
                    s.Update((sbyte)0x31);
                    signedAttrsOriginalEncoding.Position(1);
                    s.Update(signedAttrsOriginalEncoding);
                }
                else 
                {
                    s.Update(signatureFile);
                }
                sbyte[] sigBytes = SigningServer.Android.Com.Android.Apksig.Internal.Util.ByteBufferUtils.ToByteArray(signerInfo.signature.Slice());
                if (!s.Verify(sigBytes))
                {
                    return null;
                }
                return signingCertificate;
            }
            
            public static SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> GetCertificateChain(SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> certs, SigningServer.Android.Security.Cert.X509Certificate leaf)
            {
                SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> unusedCerts = new SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate>(certs);
                SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> result = new SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate>(1);
                result.Add(leaf);
                unusedCerts.Remove(leaf);
                SigningServer.Android.Security.Cert.X509Certificate root = leaf;
                while (!root.GetSubjectDN().Equals(root.GetIssuerDN()))
                {
                    SigningServer.Android.Security.Principal targetDn = root.GetIssuerDN();
                    bool issuerFound = false;
                    for (int i = 0;i < unusedCerts.Size();i++)
                    {
                        SigningServer.Android.Security.Cert.X509Certificate unusedCert = unusedCerts.Get(i);
                        if (targetDn.Equals(unusedCert.GetSubjectDN()))
                        {
                            issuerFound = true;
                            unusedCerts.Remove(i);
                            result.Add(unusedCert);
                            root = unusedCert;
                            break;
                        }
                    }
                    if (!issuerFound)
                    {
                        break;
                    }
                }
                return result;
            }
            
            public virtual void VerifySigFileAgainstManifest(sbyte[] manifestBytes, SigningServer.Android.Com.Android.Apksig.Internal.Jar.ManifestParser.Section manifestMainSection, SigningServer.Android.Collections.Map<string, SigningServer.Android.Com.Android.Apksig.Internal.Jar.ManifestParser.Section> entryNameToManifestSection, SigningServer.Android.Collections.Map<int?, string> supportedApkSigSchemeNames, SigningServer.Android.Collections.Set<int?> foundApkSigSchemeIds, int minSdkVersion, int maxSdkVersion)
            {
                SigningServer.Android.Com.Android.Apksig.Internal.Jar.ManifestParser sf = new SigningServer.Android.Com.Android.Apksig.Internal.Jar.ManifestParser(mSigFileBytes);
                SigningServer.Android.Com.Android.Apksig.Internal.Jar.ManifestParser.Section sfMainSection = sf.ReadSection();
                if (sfMainSection.GetAttributeValue(SigningServer.Android.Util.Jar.Attributes.Name.SIGNATURE_VERSION) == null)
                {
                    mResult.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.JAR_SIG_MISSING_VERSION_ATTR_IN_SIG_FILE, mSignatureFileEntry.GetName());
                    SetIgnored();
                    return;
                }
                if (maxSdkVersion >= SigningServer.Android.Com.Android.Apksig.Internal.Util.AndroidSdkVersion.N)
                {
                    CheckForStrippedApkSignatures(sfMainSection, supportedApkSigSchemeNames, foundApkSigSchemeIds);
                    if (mResult.ContainsErrors())
                    {
                        return;
                    }
                }
                bool createdBySigntool = false;
                string createdBy = sfMainSection.GetAttributeValue("Created-By");
                if (createdBy != null)
                {
                    createdBySigntool = createdBy.IndexOf("signtool") != -1;
                }
                bool manifestDigestVerified = VerifyManifestDigest(sfMainSection, createdBySigntool, manifestBytes, minSdkVersion, maxSdkVersion);
                if (!createdBySigntool)
                {
                    VerifyManifestMainSectionDigest(sfMainSection, manifestMainSection, manifestBytes, minSdkVersion, maxSdkVersion);
                }
                if (mResult.ContainsErrors())
                {
                    return;
                }
                SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Jar.ManifestParser.Section> sfSections = sf.ReadAllSections();
                SigningServer.Android.Collections.Set<string> sfEntryNames = new SigningServer.Android.Collections.HashSet<string>(sfSections.Size());
                int sfSectionNumber = 0;
                foreach (SigningServer.Android.Com.Android.Apksig.Internal.Jar.ManifestParser.Section sfSection in sfSections)
                {
                    sfSectionNumber++;
                    string entryName = sfSection.GetName();
                    if (entryName == null)
                    {
                        mResult.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.JAR_SIG_UNNNAMED_SIG_FILE_SECTION, mSignatureFileEntry.GetName(), sfSectionNumber);
                        SetIgnored();
                        return;
                    }
                    if (!sfEntryNames.Add(entryName))
                    {
                        mResult.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.JAR_SIG_DUPLICATE_SIG_FILE_SECTION, mSignatureFileEntry.GetName(), entryName);
                        SetIgnored();
                        return;
                    }
                    if (manifestDigestVerified)
                    {
                        continue;
                    }
                    SigningServer.Android.Com.Android.Apksig.Internal.Jar.ManifestParser.Section manifestSection = entryNameToManifestSection.Get(entryName);
                    if (manifestSection == null)
                    {
                        mResult.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.JAR_SIG_NO_ZIP_ENTRY_DIGEST_IN_SIG_FILE, entryName, mSignatureFileEntry.GetName());
                        SetIgnored();
                        continue;
                    }
                    VerifyManifestIndividualSectionDigest(
                        sfSection
                        , 
                        createdBySigntool
                        , 
                        manifestSection
                        , 
                        manifestBytes
                        , 
                        minSdkVersion
                        , 
                        maxSdkVersion
                    
                    );
                }
                mSigFileEntryNames = sfEntryNames;
            }
            
            /// <summary>
            /// Returns {@code true} if the whole-file digest of the manifest against the main section of
            /// the .SF file.
            /// </summary>
            internal bool VerifyManifestDigest(SigningServer.Android.Com.Android.Apksig.Internal.Jar.ManifestParser.Section sfMainSection, bool createdBySigntool, sbyte[] manifestBytes, int minSdkVersion, int maxSdkVersion)
            {
                SigningServer.Android.Collections.Collection<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.NamedDigest> expectedDigests = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.GetDigestsToVerify(sfMainSection, ((createdBySigntool) ? "-Digest" : "-Digest-Manifest"), minSdkVersion, maxSdkVersion);
                bool digestFound = !expectedDigests.IsEmpty();
                if (!digestFound)
                {
                    mResult.AddWarning(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.JAR_SIG_NO_MANIFEST_DIGEST_IN_SIG_FILE, mSignatureFileEntry.GetName());
                    return false;
                }
                bool verified = true;
                foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.NamedDigest expectedDigest in expectedDigests)
                {
                    string jcaDigestAlgorithm = expectedDigest.jcaDigestAlgorithm;
                    sbyte[] actual = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Digest(jcaDigestAlgorithm, manifestBytes);
                    sbyte[] expected = expectedDigest.digest;
                    if (!SigningServer.Android.Collections.Arrays.Equals(expected, actual))
                    {
                        mResult.AddWarning(
                            SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.JAR_SIG_ZIP_ENTRY_DIGEST_DID_NOT_VERIFY
                            , 
                            SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeConstants.MANIFEST_ENTRY_NAME
                            , 
                            jcaDigestAlgorithm
                            , 
                            mSignatureFileEntry.GetName()
                            , 
                            SigningServer.Android.Util.Base64.GetEncoder().EncodeToString(actual)
                            , 
                            SigningServer.Android.Util.Base64.GetEncoder().EncodeToString(expected)
                        
                        );
                        verified = false;
                    }
                }
                return verified;
            }
            
            /// <summary>
            /// Verifies the digest of the manifest's main section against the main section of the .SF
            /// file.
            /// </summary>
            internal void VerifyManifestMainSectionDigest(SigningServer.Android.Com.Android.Apksig.Internal.Jar.ManifestParser.Section sfMainSection, SigningServer.Android.Com.Android.Apksig.Internal.Jar.ManifestParser.Section manifestMainSection, sbyte[] manifestBytes, int minSdkVersion, int maxSdkVersion)
            {
                SigningServer.Android.Collections.Collection<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.NamedDigest> expectedDigests = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.GetDigestsToVerify(sfMainSection, "-Digest-Manifest-Main-Attributes", minSdkVersion, maxSdkVersion);
                if (expectedDigests.IsEmpty())
                {
                    return;
                }
                foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.NamedDigest expectedDigest in expectedDigests)
                {
                    string jcaDigestAlgorithm = expectedDigest.jcaDigestAlgorithm;
                    sbyte[] actual = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Digest(jcaDigestAlgorithm, manifestBytes, manifestMainSection.GetStartOffset(), manifestMainSection.GetSizeBytes());
                    sbyte[] expected = expectedDigest.digest;
                    if (!SigningServer.Android.Collections.Arrays.Equals(expected, actual))
                    {
                        mResult.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.JAR_SIG_MANIFEST_MAIN_SECTION_DIGEST_DID_NOT_VERIFY, jcaDigestAlgorithm, mSignatureFileEntry.GetName(), SigningServer.Android.Util.Base64.GetEncoder().EncodeToString(actual), SigningServer.Android.Util.Base64.GetEncoder().EncodeToString(expected));
                    }
                }
            }
            
            /// <summary>
            /// Verifies the digest of the manifest's individual section against the corresponding
            /// individual section of the .SF file.
            /// </summary>
            internal void VerifyManifestIndividualSectionDigest(SigningServer.Android.Com.Android.Apksig.Internal.Jar.ManifestParser.Section sfIndividualSection, bool createdBySigntool, SigningServer.Android.Com.Android.Apksig.Internal.Jar.ManifestParser.Section manifestIndividualSection, sbyte[] manifestBytes, int minSdkVersion, int maxSdkVersion)
            {
                string entryName = sfIndividualSection.GetName();
                SigningServer.Android.Collections.Collection<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.NamedDigest> expectedDigests = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.GetDigestsToVerify(sfIndividualSection, "-Digest", minSdkVersion, maxSdkVersion);
                if (expectedDigests.IsEmpty())
                {
                    mResult.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.JAR_SIG_NO_ZIP_ENTRY_DIGEST_IN_SIG_FILE, entryName, mSignatureFileEntry.GetName());
                    return;
                }
                int sectionStartIndex = manifestIndividualSection.GetStartOffset();
                int sectionSizeBytes = manifestIndividualSection.GetSizeBytes();
                if (createdBySigntool)
                {
                    int sectionEndIndex = sectionStartIndex + sectionSizeBytes;
                    if ((manifestBytes[sectionEndIndex - 1] == '\n') && (manifestBytes[sectionEndIndex - 2] == '\n'))
                    {
                        sectionSizeBytes--;
                    }
                }
                foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.NamedDigest expectedDigest in expectedDigests)
                {
                    string jcaDigestAlgorithm = expectedDigest.jcaDigestAlgorithm;
                    sbyte[] actual = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Digest(jcaDigestAlgorithm, manifestBytes, sectionStartIndex, sectionSizeBytes);
                    sbyte[] expected = expectedDigest.digest;
                    if (!SigningServer.Android.Collections.Arrays.Equals(expected, actual))
                    {
                        mResult.AddError(
                            SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.JAR_SIG_MANIFEST_SECTION_DIGEST_DID_NOT_VERIFY
                            , 
                            entryName
                            , 
                            jcaDigestAlgorithm
                            , 
                            mSignatureFileEntry.GetName()
                            , 
                            SigningServer.Android.Util.Base64.GetEncoder().EncodeToString(actual)
                            , 
                            SigningServer.Android.Util.Base64.GetEncoder().EncodeToString(expected)
                        
                        );
                    }
                }
            }
            
            internal void CheckForStrippedApkSignatures(SigningServer.Android.Com.Android.Apksig.Internal.Jar.ManifestParser.Section sfMainSection, SigningServer.Android.Collections.Map<int?, string> supportedApkSigSchemeNames, SigningServer.Android.Collections.Set<int?> foundApkSigSchemeIds)
            {
                string signedWithApkSchemes = sfMainSection.GetAttributeValue(SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeConstants.SF_ATTRIBUTE_NAME_ANDROID_APK_SIGNED_NAME_STR);
                if (signedWithApkSchemes == null)
                {
                    if (!foundApkSigSchemeIds.IsEmpty())
                    {
                        mResult.AddWarning(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.JAR_SIG_NO_APK_SIG_STRIP_PROTECTION, mSignatureFileEntry.GetName());
                    }
                    return;
                }
                if (supportedApkSigSchemeNames.IsEmpty())
                {
                    return;
                }
                SigningServer.Android.Collections.Set<int?> supportedApkSigSchemeIds = supportedApkSigSchemeNames.KeySet();
                SigningServer.Android.Collections.Set<int?> supportedExpectedApkSigSchemeIds = new SigningServer.Android.Collections.HashSet<int?>(1);
                SigningServer.Android.Util.StringTokenizer tokenizer = new SigningServer.Android.Util.StringTokenizer(signedWithApkSchemes, ",");
                while (tokenizer.HasMoreTokens())
                {
                    string idText = tokenizer.NextToken().Trim();
                    if (idText.IsEmpty())
                    {
                        continue;
                    }
                    int id;
                    try
                    {
                        id = SigningServer.Android.Core.IntExtensions.ParseInt(idText);
                    }
                    catch (System.Exception ignored)
                    {
                        continue;
                    }
                    if (supportedApkSigSchemeIds.Contains(id))
                    {
                        supportedExpectedApkSigSchemeIds.Add(id);
                    }
                    else 
                    {
                        mResult.AddWarning(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.JAR_SIG_UNKNOWN_APK_SIG_SCHEME_ID, mSignatureFileEntry.GetName(), id);
                    }
                }
                foreach (int id in supportedExpectedApkSigSchemeIds)
                {
                    if (!foundApkSigSchemeIds.Contains(id))
                    {
                        string apkSigSchemeName = supportedApkSigSchemeNames.Get(id);
                        mResult.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.JAR_SIG_MISSING_APK_SIG_REFERENCED, mSignatureFileEntry.GetName(), id, apkSigSchemeName);
                    }
                }
            }
            
        }
        
        public static SigningServer.Android.Collections.Collection<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.NamedDigest> GetDigestsToVerify(SigningServer.Android.Com.Android.Apksig.Internal.Jar.ManifestParser.Section section, string digestAttrSuffix, int minSdkVersion, int maxSdkVersion)
        {
            SigningServer.Android.Util.Base64.Decoder base64Decoder = SigningServer.Android.Util.Base64.GetDecoder();
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.NamedDigest> result = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.NamedDigest>(1);
            if (minSdkVersion < SigningServer.Android.Com.Android.Apksig.Internal.Util.AndroidSdkVersion.JELLY_BEAN_MR2)
            {
                string algs = section.GetAttributeValue("Digest-Algorithms");
                if (algs == null)
                {
                    algs = "SHA SHA1";
                }
                SigningServer.Android.Util.StringTokenizer tokens = new SigningServer.Android.Util.StringTokenizer(algs);
                while (tokens.HasMoreTokens())
                {
                    string alg = tokens.NextToken();
                    string attrName = alg + digestAttrSuffix;
                    string digestBase64 = section.GetAttributeValue(attrName);
                    if (digestBase64 == null)
                    {
                        continue;
                    }
                    alg = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.GetCanonicalJcaMessageDigestAlgorithm(alg);
                    if ((alg == null) || (SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.GetMinSdkVersionFromWhichSupportedInManifestOrSignatureFile(alg) > minSdkVersion))
                    {
                        continue;
                    }
                    result.Add(new SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.NamedDigest(alg, base64Decoder.Decode(digestBase64)));
                    break;
                }
                if (result.IsEmpty())
                {
                    return result;
                }
            }
            if (maxSdkVersion >= SigningServer.Android.Com.Android.Apksig.Internal.Util.AndroidSdkVersion.JELLY_BEAN_MR2)
            {
                foreach (string alg in SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.JB_MR2_AND_NEWER_DIGEST_ALGS)
                {
                    string attrName = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.GetJarDigestAttributeName(alg, digestAttrSuffix);
                    string digestBase64 = section.GetAttributeValue(attrName);
                    if (digestBase64 == null)
                    {
                        continue;
                    }
                    sbyte[] digest = base64Decoder.Decode(digestBase64);
                    sbyte[] digestInResult = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.GetDigest(result, alg);
                    if ((digestInResult == null) || (!SigningServer.Android.Collections.Arrays.Equals(digestInResult, digest)))
                    {
                        result.Add(new SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.NamedDigest(alg, digest));
                    }
                    break;
                }
            }
            return result;
        }
        
        internal static readonly string[] JB_MR2_AND_NEWER_DIGEST_ALGS = {"SHA-512", "SHA-384", "SHA-256", "SHA-1"};
        
        internal static string GetCanonicalJcaMessageDigestAlgorithm(string algorithm)
        {
            return SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.UPPER_CASE_JCA_DIGEST_ALG_TO_CANONICAL.Get(algorithm.ToUpperCase(SigningServer.Android.Util.Locale.US));
        }
        
        public static int GetMinSdkVersionFromWhichSupportedInManifestOrSignatureFile(string jcaAlgorithmName)
        {
            int? result = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.MIN_SDK_VESION_FROM_WHICH_DIGEST_SUPPORTED_IN_MANIFEST.Get(jcaAlgorithmName.ToUpperCase(SigningServer.Android.Util.Locale.US));
            return (result != null) ? result : SigningServer.Android.Core.IntExtensions.MaxValue;
        }
        
        internal static string GetJarDigestAttributeName(string jcaDigestAlgorithm, string attrNameSuffix)
        {
            if ("SHA-1".EqualsIgnoreCase(jcaDigestAlgorithm))
            {
                return "SHA1" + attrNameSuffix;
            }
            else 
            {
                return jcaDigestAlgorithm + attrNameSuffix;
            }
        }
        
        internal static readonly SigningServer.Android.Collections.Map<string, string> UPPER_CASE_JCA_DIGEST_ALG_TO_CANONICAL;
        
        internal static readonly SigningServer.Android.Collections.Map<string, int?> MIN_SDK_VESION_FROM_WHICH_DIGEST_SUPPORTED_IN_MANIFEST;
        
        internal static sbyte[] GetDigest(SigningServer.Android.Collections.Collection<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.NamedDigest> digests, string jcaDigestAlgorithm)
        {
            foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.NamedDigest digest in digests)
            {
                if (digest.jcaDigestAlgorithm.EqualsIgnoreCase(jcaDigestAlgorithm))
                {
                    return digest.digest;
                }
            }
            return null;
        }
        
        public static SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord> ParseZipCentralDirectory(SigningServer.Android.Com.Android.Apksig.Util.DataSource apk, SigningServer.Android.Com.Android.Apksig.Apk.ApkUtils.ZipSections apkSections)
        {
            return SigningServer.Android.Com.Android.Apksig.Internal.Zip.ZipUtils.ParseZipCentralDirectory(apk, apkSections);
        }
        
        /// <summary>
        /// Returns {@code true} if the provided JAR entry must be mentioned in signed JAR archive's
        /// manifest for the APK to verify on Android.
        /// </summary>
        internal static bool IsJarEntryDigestNeededInManifest(string entryName)
        {
            if (entryName.StartsWith("META-INF/"))
            {
                return false;
            }
            return !entryName.EndsWith("/");
        }
        
        internal static SigningServer.Android.Collections.Set<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Signer> VerifyJarEntriesAgainstManifestAndSigners(SigningServer.Android.Com.Android.Apksig.Util.DataSource apk, long cdOffsetInApk, SigningServer.Android.Collections.Collection<SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord> cdRecords, SigningServer.Android.Collections.Map<string, SigningServer.Android.Com.Android.Apksig.Internal.Jar.ManifestParser.Section> entryNameToManifestSection, SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Signer> signers, int minSdkVersion, int maxSdkVersion, SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Result result)
        {
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord> cdRecordsSortedByLocalFileHeaderOffset = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord>(cdRecords);
            SigningServer.Android.Util.Collections.Sort(cdRecordsSortedByLocalFileHeaderOffset, SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord.BY_LOCAL_FILE_HEADER_OFFSET_COMPARATOR);
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Signer> firstSignedEntrySigners = null;
            string firstSignedEntryName = null;
            foreach (SigningServer.Android.Com.Android.Apksig.Internal.Zip.CentralDirectoryRecord cdRecord in cdRecordsSortedByLocalFileHeaderOffset)
            {
                string entryName = cdRecord.GetName();
                if (!SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.IsJarEntryDigestNeededInManifest(entryName))
                {
                    continue;
                }
                SigningServer.Android.Com.Android.Apksig.Internal.Jar.ManifestParser.Section manifestSection = entryNameToManifestSection.Get(entryName);
                if (manifestSection == null)
                {
                    result.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.JAR_SIG_NO_ZIP_ENTRY_DIGEST_IN_MANIFEST, entryName);
                    continue;
                }
                SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Signer> entrySigners = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Signer>(signers.Size());
                foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Signer signer in signers)
                {
                    if (signer.GetSigFileEntryNames().Contains(entryName))
                    {
                        entrySigners.Add(signer);
                    }
                }
                if (entrySigners.IsEmpty())
                {
                    result.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.JAR_SIG_ZIP_ENTRY_NOT_SIGNED, entryName);
                    continue;
                }
                if (firstSignedEntrySigners == null)
                {
                    firstSignedEntrySigners = entrySigners;
                    firstSignedEntryName = entryName;
                }
                else if (!entrySigners.Equals(firstSignedEntrySigners))
                {
                    result.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.JAR_SIG_ZIP_ENTRY_SIGNERS_MISMATCH, firstSignedEntryName, SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.GetSignerNames(firstSignedEntrySigners), entryName, SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.GetSignerNames(entrySigners));
                    continue;
                }
                SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.NamedDigest> expectedDigests = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.NamedDigest>(SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.GetDigestsToVerify(manifestSection, "-Digest", minSdkVersion, maxSdkVersion));
                if (expectedDigests.IsEmpty())
                {
                    result.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.JAR_SIG_NO_ZIP_ENTRY_DIGEST_IN_MANIFEST, entryName);
                    continue;
                }
                SigningServer.Android.Security.MessageDigest[] mds = new SigningServer.Android.Security.MessageDigest[expectedDigests.Size()];
                for (int i = 0;i < expectedDigests.Size();i++)
                {
                    mds[i] = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.GetMessageDigest(expectedDigests.Get(i).jcaDigestAlgorithm);
                }
                try
                {
                    SigningServer.Android.Com.Android.Apksig.Internal.Zip.LocalFileRecord.OutputUncompressedData(apk, cdRecord, cdOffsetInApk, SigningServer.Android.Com.Android.Apksig.Util.DataSinks.AsDataSink(mds));
                }
                catch (SigningServer.Android.Com.Android.Apksig.Zip.ZipFormatException e)
                {
                    throw new SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException("Malformed ZIP entry: " + entryName, e);
                }
                catch (SigningServer.Android.IO.IOException e)
                {
                    throw new SigningServer.Android.IO.IOException("Failed to read entry: " + entryName, e);
                }
                for (int i = 0;i < expectedDigests.Size();i++)
                {
                    SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.NamedDigest expectedDigest = expectedDigests.Get(i);
                    sbyte[] actualDigest = mds[i].Digest();
                    if (!SigningServer.Android.Collections.Arrays.Equals(expectedDigest.digest, actualDigest))
                    {
                        result.AddError(
                            SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.JAR_SIG_ZIP_ENTRY_DIGEST_DID_NOT_VERIFY
                            , 
                            entryName
                            , 
                            expectedDigest.jcaDigestAlgorithm
                            , 
                            SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeConstants.MANIFEST_ENTRY_NAME
                            , 
                            SigningServer.Android.Util.Base64.GetEncoder().EncodeToString(actualDigest)
                            , 
                            SigningServer.Android.Util.Base64.GetEncoder().EncodeToString(expectedDigest.digest)
                        
                        );
                    }
                }
            }
            if (firstSignedEntrySigners == null)
            {
                result.AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue.JAR_SIG_NO_SIGNED_ZIP_ENTRIES);
                return SigningServer.Android.Util.Collections.EmptySet();
            }
            else 
            {
                return new SigningServer.Android.Collections.HashSet<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Signer>(firstSignedEntrySigners);
            }
        }
        
        internal static SigningServer.Android.Collections.List<string> GetSignerNames(SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Signer> signers)
        {
            if (signers.IsEmpty())
            {
                return SigningServer.Android.Util.Collections.EmptyList();
            }
            SigningServer.Android.Collections.List<string> result = new SigningServer.Android.Collections.List<string>(signers.Size());
            foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Signer signer in signers)
            {
                result.Add(signer.GetName());
            }
            return result;
        }
        
        internal static SigningServer.Android.Security.MessageDigest GetMessageDigest(string algorithm)
        {
            return SigningServer.Android.Security.MessageDigest.GetInstance(algorithm);
        }
        
        internal static sbyte[] Digest(string algorithm, sbyte[] data, int offset, int length)
        {
            SigningServer.Android.Security.MessageDigest md = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.GetMessageDigest(algorithm);
            md.Update(data, offset, length);
            return md.Digest();
        }
        
        internal static sbyte[] Digest(string algorithm, sbyte[] data)
        {
            return SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.GetMessageDigest(algorithm).Digest(data);
        }
        
        public class NamedDigest
        {
            public readonly string jcaDigestAlgorithm;
            
            public readonly sbyte[] digest;
            
            internal NamedDigest(string jcaDigestAlgorithm, sbyte[] digest)
            {
                this.jcaDigestAlgorithm = jcaDigestAlgorithm;
                this.digest = digest;
            }
            
        }
        
        public class Result
        {
            /// <summary>
            /// Whether the APK's JAR signature verifies.
            /// </summary>
            public bool verified;
            
            /// <summary>
            /// List of APK's signers. These signers are used by Android.
            /// </summary>
            public readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Result.SignerInfo> signers = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Result.SignerInfo>();
            
            /// <summary>
            /// Signers encountered in the APK but not included in the set of the APK's signers. These
            /// signers are ignored by Android.
            /// </summary>
            public readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Result.SignerInfo> ignoredSigners = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Result.SignerInfo>();
            
            internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> mWarnings = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams>();
            
            internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> mErrors = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams>();
            
            internal bool ContainsErrors()
            {
                if (!mErrors.IsEmpty())
                {
                    return true;
                }
                foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.Result.SignerInfo signer in signers)
                {
                    if (signer.ContainsErrors())
                    {
                        return true;
                    }
                }
                return false;
            }
            
            internal void AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue msg, params object[] parameters)
            {
                mErrors.Add(new SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams(msg, parameters));
            }
            
            internal void AddWarning(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue msg, params object[] parameters)
            {
                mWarnings.Add(new SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams(msg, parameters));
            }
            
            public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> GetErrors()
            {
                return mErrors;
            }
            
            public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> GetWarnings()
            {
                return mWarnings;
            }
            
            public class SignerInfo
            {
                public readonly string name;
                
                public readonly string signatureFileName;
                
                public readonly string signatureBlockFileName;
                
                public readonly SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate> certChain = new SigningServer.Android.Collections.List<SigningServer.Android.Security.Cert.X509Certificate>();
                
                internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> mWarnings = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams>();
                
                internal readonly SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> mErrors = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams>();
                
                internal SignerInfo(string name, string signatureBlockFileName, string signatureFileName)
                {
                    this.name = name;
                    this.signatureBlockFileName = signatureBlockFileName;
                    this.signatureFileName = signatureFileName;
                }
                
                internal bool ContainsErrors()
                {
                    return !mErrors.IsEmpty();
                }
                
                internal void AddError(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue msg, params object[] parameters)
                {
                    mErrors.Add(new SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams(msg, parameters));
                }
                
                internal void AddWarning(SigningServer.Android.Com.Android.Apksig.ApkVerifier.Issue msg, params object[] parameters)
                {
                    mWarnings.Add(new SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams(msg, parameters));
                }
                
                public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> GetErrors()
                {
                    return mErrors;
                }
                
                public virtual SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.ApkVerifier.IssueWithParams> GetWarnings()
                {
                    return mWarnings;
                }
                
            }
            
        }
        
        internal class SignedAttributes
        {
            internal SigningServer.Android.Collections.Map<string, SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1OpaqueObject>> mAttrs;
            
            public SignedAttributes(SigningServer.Android.Collections.Collection<SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.Attribute> attrs)
            {
                SigningServer.Android.Collections.Map<string, SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1OpaqueObject>> result = new SigningServer.Android.Collections.HashMap<string, SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1OpaqueObject>>(attrs.Size());
                foreach (SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.Attribute attr in attrs)
                {
                    if (result.Put(attr.attrType, attr.attrValues) != null)
                    {
                        throw new SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.Pkcs7DecodingException("Duplicate signed attribute: " + attr.attrType);
                    }
                }
                mAttrs = result;
            }
            
            internal SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1OpaqueObject GetSingleValue(string attrOid)
            {
                SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1OpaqueObject> values = mAttrs.Get(attrOid);
                if ((values == null) || (values.IsEmpty()))
                {
                    return null;
                }
                if (values.Size() > 1)
                {
                    throw new SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.Pkcs7DecodingException("Attribute " + attrOid + " has multiple values");
                }
                return values.Get(0);
            }
            
            public virtual string GetSingleObjectIdentifierValue(string attrOid)
            {
                SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1OpaqueObject value = GetSingleValue(attrOid);
                if (value == null)
                {
                    return null;
                }
                try
                {
                    return SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1BerParser.Parse(value.GetEncoded(), typeof(SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.ObjectIdentifierChoice)).value;
                }
                catch (SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1DecodingException e)
                {
                    throw new SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.Pkcs7DecodingException("Failed to decode OBJECT IDENTIFIER", e);
                }
            }
            
            public virtual sbyte[] GetSingleOctetStringValue(string attrOid)
            {
                SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1OpaqueObject value = GetSingleValue(attrOid);
                if (value == null)
                {
                    return null;
                }
                try
                {
                    return SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1BerParser.Parse(value.GetEncoded(), typeof(SigningServer.Android.Com.Android.Apksig.Internal.Apk.V1.V1SchemeVerifier.OctetStringChoice)).value;
                }
                catch (SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1DecodingException e)
                {
                    throw new SigningServer.Android.Com.Android.Apksig.Internal.Pkcs7.Pkcs7DecodingException("Failed to decode OBJECT IDENTIFIER", e);
                }
            }
            
        }
        
        [SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1Class(Type = SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1Type.CHOICE)]
        public class OctetStringChoice
        {
            [SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1Field(Type = SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1Type.OCTET_STRING)]
            public sbyte[] value;
            
        }
        
        [SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1Class(Type = SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1Type.CHOICE)]
        public class ObjectIdentifierChoice
        {
            [SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1Field(Type = SigningServer.Android.Com.Android.Apksig.Internal.Asn1.Asn1Type.OBJECT_IDENTIFIER)]
            public string value;
            
        }
        
    }
    
}
