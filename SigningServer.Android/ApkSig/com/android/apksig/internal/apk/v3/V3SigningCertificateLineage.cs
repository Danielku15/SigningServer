// <auto-generated>
// This code was auto-generated.
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
// </auto-generated>

using System;

namespace SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3
{
    /// <summary>
    /// APK Signer Lineage.
    /// 
    /// &lt;p&gt;The signer lineage contains a history of signing certificates with each ancestor attesting to
    /// the validity of its descendant.  Each additional descendant represents a new identity that can be
    /// used to sign an APK, and each generation has accompanying attributes which represent how the
    /// APK would like to view the older signing certificates, specifically how they should be trusted in
    /// certain situations.
    /// 
    /// &lt;p&gt; Its primary use is to enable APK Signing Certificate Rotation.  The Android platform verifies
    /// the APK Signer Lineage, and if the current signing certificate for the APK is in the Signer
    /// Lineage, and the Lineage contains the certificate the platform associates with the APK, it will
    /// allow upgrades to the new certificate.
    /// 
    /// @see &lt;a href="https://source.android.com/security/apksigning/index.html"&gt;Application Signing&lt;/a&gt;
    /// </summary>
    public class V3SigningCertificateLineage
    {
        internal static readonly int FIRST_VERSION = 1;
        
        internal static readonly int CURRENT_VERSION = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.FIRST_VERSION;
        
        /// <summary>
        /// Deserializes the binary representation of an {@link V3SigningCertificateLineage}. Also
        /// verifies that the structure is well-formed, e.g. that the signature for each node is from its
        /// parent.
        /// </summary>
        public static SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.SigningCertificateNode> ReadSigningCertificateLineage(SigningServer.Android.IO.ByteBuffer inputBytes)
        {
            SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.SigningCertificateNode> result = new SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.SigningCertificateNode>();
            int nodeCount = 0;
            if (inputBytes == null || !inputBytes.HasRemaining())
            {
                return null;
            }
            SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.CheckByteOrderLittleEndian(inputBytes);
            SigningServer.Android.Security.Cert.X509Certificate lastCert = null;
            int lastSigAlgorithmId = 0;
            try
            {
                int version = inputBytes.GetInt();
                if (version != SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.CURRENT_VERSION)
                {
                    throw new System.ArgumentException("Encoded SigningCertificateLineage has a version" + " different than any of which we are aware");
                }
                SigningServer.Android.Collections.HashSet<SigningServer.Android.Security.Cert.X509Certificate> certHistorySet = new SigningServer.Android.Collections.HashSet<SigningServer.Android.Security.Cert.X509Certificate>();
                while (inputBytes.HasRemaining())
                {
                    nodeCount++;
                    SigningServer.Android.IO.ByteBuffer nodeBytes = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.GetLengthPrefixedSlice(inputBytes);
                    SigningServer.Android.IO.ByteBuffer signedData = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.GetLengthPrefixedSlice(nodeBytes);
                    int flags = nodeBytes.GetInt();
                    int sigAlgorithmId = nodeBytes.GetInt();
                    SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm sigAlgorithm = SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm.FindById(lastSigAlgorithmId);
                    byte[] signature = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ReadLengthPrefixedByteArray(nodeBytes);
                    if (lastCert != null)
                    {
                        string jcaSignatureAlgorithm = sigAlgorithm.GetJcaSignatureAlgorithmAndParams().GetFirst();
                        SigningServer.Android.Security.Spec.AlgorithmParameterSpec jcaSignatureAlgorithmParams = sigAlgorithm.GetJcaSignatureAlgorithmAndParams().GetSecond();
                        SigningServer.Android.Security.PublicKey publicKey = lastCert.GetPublicKey();
                        SigningServer.Android.Security.Signature sig = SigningServer.Android.Security.Signature.GetInstance(jcaSignatureAlgorithm);
                        sig.InitVerify(publicKey);
                        if (jcaSignatureAlgorithmParams != null)
                        {
                            sig.SetParameter(jcaSignatureAlgorithmParams);
                        }
                        sig.Update(signedData);
                        if (!sig.Verify(signature))
                        {
                            throw new SigningServer.Android.Core.SecurityException("Unable to verify signature of certificate #" + nodeCount + " using " + jcaSignatureAlgorithm + " when verifying" + " V3SigningCertificateLineage object");
                        }
                    }
                    signedData.Rewind();
                    byte[] encodedCert = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.ReadLengthPrefixedByteArray(signedData);
                    int signedSigAlgorithm = signedData.GetInt();
                    if (lastCert != null && lastSigAlgorithmId != signedSigAlgorithm)
                    {
                        throw new SigningServer.Android.Core.SecurityException("Signing algorithm ID mismatch for certificate #" + nodeBytes + " when verifying V3SigningCertificateLineage object");
                    }
                    lastCert = SigningServer.Android.Com.Android.Apksig.Internal.Util.X509CertificateUtils.GenerateCertificate(encodedCert);
                    lastCert = new SigningServer.Android.Com.Android.Apksig.Internal.Util.GuaranteedEncodedFormX509Certificate(lastCert, encodedCert);
                    if (certHistorySet.Contains(lastCert))
                    {
                        throw new SigningServer.Android.Core.SecurityException("Encountered duplicate entries in " + "SigningCertificateLineage at certificate #" + nodeCount + ".  All " + "signing certificates should be unique");
                    }
                    certHistorySet.Add(lastCert);
                    lastSigAlgorithmId = sigAlgorithmId;
                    result.Add(new SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.SigningCertificateNode(lastCert, SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm.FindById(signedSigAlgorithm), SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm.FindById(sigAlgorithmId), signature, flags));
                }
            }
            catch (System.Exception e) when ( e is SigningServer.Android.Com.Android.Apksig.Apk.ApkFormatException || e is SigningServer.Android.IO.BufferUnderflowException)
            {
                throw new global::System.IO.IOException("Failed to parse V3SigningCertificateLineage object", e);
            }
            catch (System.Exception e) when ( e is SigningServer.Android.Security.NoSuchAlgorithmException || e is SigningServer.Android.Security.InvalidKeyException || e is SigningServer.Android.Security.InvalidAlgorithmParameterException || e is SigningServer.Android.Security.SignatureException)
            {
                throw new SigningServer.Android.Core.SecurityException("Failed to verify signature over signed data for certificate #" + nodeCount + " when parsing V3SigningCertificateLineage object", e);
            }
            catch (SigningServer.Android.Security.Cert.CertificateException e)
            {
                throw new SigningServer.Android.Core.SecurityException("Failed to decode certificate #" + nodeCount + " when parsing V3SigningCertificateLineage object", e);
            }
            return result;
        }
        
        /// <summary>
        /// encode the in-memory representation of this {@code V3SigningCertificateLineage}
        /// </summary>
        public static byte[] EncodeSigningCertificateLineage(SigningServer.Android.Collections.List<SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.SigningCertificateNode> signingCertificateLineage)
        {
            SigningServer.Android.Collections.List<byte[]> nodes = new SigningServer.Android.Collections.List<byte[]>();
            foreach (SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.SigningCertificateNode node in signingCertificateLineage)
            {
                nodes.Add(SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.EncodeSigningCertificateNode(node));
            }
            byte[] encodedSigningCertificateLineage = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.EncodeAsSequenceOfLengthPrefixedElements(nodes);
            int payloadSize = 4 + encodedSigningCertificateLineage.Length;
            SigningServer.Android.IO.ByteBuffer encodedWithVersion = SigningServer.Android.IO.ByteBuffer.Allocate(payloadSize);
            encodedWithVersion.Order(SigningServer.Android.IO.ByteOrder.LITTLE_ENDIAN);
            encodedWithVersion.PutInt(SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.CURRENT_VERSION);
            encodedWithVersion.Put(encodedSigningCertificateLineage);
            return encodedWithVersion.Array();
        }
        
        public static byte[] EncodeSigningCertificateNode(SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.SigningCertificateNode node)
        {
            int parentSigAlgorithmId = 0;
            if (node.parentSigAlgorithm != null)
            {
                parentSigAlgorithmId = node.parentSigAlgorithm.GetId();
            }
            int sigAlgorithmId = 0;
            if (node.sigAlgorithm != null)
            {
                sigAlgorithmId = node.sigAlgorithm.GetId();
            }
            byte[] prefixedSignedData = SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.EncodeSignedData(node.signingCert, parentSigAlgorithmId);
            byte[] prefixedSignature = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.EncodeAsLengthPrefixedElement(node.signature);
            int payloadSize = prefixedSignedData.Length + 4 + 4 + prefixedSignature.Length;
            SigningServer.Android.IO.ByteBuffer result = SigningServer.Android.IO.ByteBuffer.Allocate(payloadSize);
            result.Order(SigningServer.Android.IO.ByteOrder.LITTLE_ENDIAN);
            result.Put(prefixedSignedData);
            result.PutInt(node.flags);
            result.PutInt(sigAlgorithmId);
            result.Put(prefixedSignature);
            return result.Array();
        }
        
        public static byte[] EncodeSignedData(SigningServer.Android.Security.Cert.X509Certificate certificate, int flags)
        {
            try
            {
                byte[] prefixedCertificate = SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.EncodeAsLengthPrefixedElement(certificate.GetEncoded());
                int payloadSize = 4 + prefixedCertificate.Length;
                SigningServer.Android.IO.ByteBuffer result = SigningServer.Android.IO.ByteBuffer.Allocate(payloadSize);
                result.Order(SigningServer.Android.IO.ByteOrder.LITTLE_ENDIAN);
                result.Put(prefixedCertificate);
                result.PutInt(flags);
                return SigningServer.Android.Com.Android.Apksig.Internal.Apk.ApkSigningBlockUtils.EncodeAsLengthPrefixedElement(result.Array());
            }
            catch (SigningServer.Android.Security.Cert.CertificateEncodingException e)
            {
                throw new SigningServer.Android.Core.RuntimeException("Failed to encode V3SigningCertificateLineage certificate", e);
            }
        }
        
        /// <summary>
        /// Represents one signing certificate in the {@link V3SigningCertificateLineage}, which
        /// generally means it is/was used at some point to sign the same APK of the others in the
        /// lineage.
        /// </summary>
        public class SigningCertificateNode
        {
            public SigningCertificateNode(SigningServer.Android.Security.Cert.X509Certificate signingCert, SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm parentSigAlgorithm, SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm sigAlgorithm, byte[] signature, int flags)
            {
                this.signingCert = signingCert;
                this.parentSigAlgorithm = parentSigAlgorithm;
                this.sigAlgorithm = sigAlgorithm;
                this.signature = signature;
                this.flags = flags;
            }
            
            public override bool Equals(object o)
            {
                if (this == o)
                    return true;
                if (!(o is SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.SigningCertificateNode))
                    return false;
                SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.SigningCertificateNode that = (SigningServer.Android.Com.Android.Apksig.Internal.Apk.V3.V3SigningCertificateLineage.SigningCertificateNode)o;
                if (!signingCert.Equals(that.signingCert))
                    return false;
                if (parentSigAlgorithm != that.parentSigAlgorithm)
                    return false;
                if (sigAlgorithm != that.sigAlgorithm)
                    return false;
                if (!SigningServer.Android.Collections.Arrays.Equals(signature, that.signature))
                    return false;
                if (flags != that.flags)
                    return false;
                return true;
            }
            
            public override int GetHashCode()
            {
                int result = SigningServer.Android.Util.Objects.Hash(signingCert, parentSigAlgorithm, sigAlgorithm, flags);
                result = 31 * result + SigningServer.Android.Collections.Arrays.GetHashCode(signature);
                return result;
            }
            
            /// <summary>
            /// the signing cert for this node.  This is part of the data signed by the parent node.
            /// </summary>
            public readonly SigningServer.Android.Security.Cert.X509Certificate signingCert;
            
            /// <summary>
            /// the algorithm used by the this node's parent to bless this data.  Its ID value is part of
            /// the data signed by the parent node. {@code null} for first node.
            /// </summary>
            public readonly SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm parentSigAlgorithm;
            
            /// <summary>
            /// the algorithm used by the this nodeto bless the next node's data.  Its ID value is part
            /// of the signed data of the next node. {@code null} for the last node.
            /// </summary>
            public SigningServer.Android.Com.Android.Apksig.Internal.Apk.SignatureAlgorithm sigAlgorithm;
            
            /// <summary>
            /// signature over the signed data (above).  The signature is from this node's parent
            /// signing certificate, which should correspond to the signing certificate used to sign an
            /// APK before rotating to this one, and is formed using {@code signatureAlgorithm}.
            /// </summary>
            public readonly byte[] signature;
            
            /// <summary>
            /// the flags detailing how the platform should treat this signing cert
            /// </summary>
            public int flags;
            
        }
        
    }
    
}
