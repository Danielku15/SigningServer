// <auto-generated>
// This code was auto-generated.
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
// </auto-generated>

using System;

namespace SigningServer.Android.Com.Android.Apksig.Internal.Util
{
    /// <summary>
    /// Growable byte array which can be appended to via {@link DataSink} interface and read from via
    /// {@link DataSource} interface.
    /// </summary>
    public class ByteArrayDataSink: SigningServer.Android.Com.Android.Apksig.Util.ReadableDataSink
    {
        internal static readonly int MAX_READ_CHUNK_SIZE = 65536;
        
        internal sbyte[] mArray;
        
        internal int mSize;
        
        public ByteArrayDataSink()
            : this (65536)
        {
            ;
        }
        
        public ByteArrayDataSink(int initialCapacity)
        {
            if (initialCapacity < 0)
            {
                throw new System.ArgumentException("initial capacity: " + initialCapacity);
            }
            mArray = new sbyte[initialCapacity];
        }
        
        public void Consume(sbyte[] buf, int offset, int length)
        {
            if (offset < 0)
            {
                throw new System.IndexOutOfRangeException("offset: " + offset);
            }
            if (offset > buf.Length)
            {
                throw new System.IndexOutOfRangeException("offset: " + offset + ", buf.length: " + buf.Length);
            }
            if (length == 0)
            {
                return;
            }
            EnsureAvailable(length);
            SigningServer.Android.Core.System.Arraycopy(buf, offset, mArray, mSize, length);
            mSize += length;
        }
        
        public void Consume(SigningServer.Android.IO.ByteBuffer buf)
        {
            if (!buf.HasRemaining())
            {
                return;
            }
            if (buf.HasArray())
            {
                Consume(buf.Array(), buf.ArrayOffset() + buf.Position(), buf.Remaining());
                buf.Position(buf.Limit());
                return;
            }
            EnsureAvailable(buf.Remaining());
            sbyte[] tmp = new sbyte[SigningServer.Android.Core.Math.Min(buf.Remaining(), SigningServer.Android.Com.Android.Apksig.Internal.Util.ByteArrayDataSink.MAX_READ_CHUNK_SIZE)];
            while (buf.HasRemaining())
            {
                int chunkSize = SigningServer.Android.Core.Math.Min(buf.Remaining(), tmp.Length);
                buf.Get(tmp, 0, chunkSize);
                SigningServer.Android.Core.System.Arraycopy(tmp, 0, mArray, mSize, chunkSize);
                mSize += chunkSize;
            }
        }
        
        internal void EnsureAvailable(int minAvailable)
        {
            if (minAvailable <= 0)
            {
                return;
            }
            long minCapacity = ((long)mSize) + minAvailable;
            if (minCapacity <= mArray.Length)
            {
                return;
            }
            if (minCapacity > SigningServer.Android.Core.IntExtensions.MAX_VALUE)
            {
                throw new global::System.IO.IOException("Required capacity too large: " + minCapacity + ", max: " + SigningServer.Android.Core.IntExtensions.MAX_VALUE);
            }
            int doubleCurrentSize = (int)SigningServer.Android.Core.Math.Min(mArray.Length * 2L, SigningServer.Android.Core.IntExtensions.MAX_VALUE);
            int newSize = (int)SigningServer.Android.Core.Math.Max(minCapacity, doubleCurrentSize);
            mArray = SigningServer.Android.Collections.Arrays.CopyOf(mArray, newSize);
        }
        
        public  long Size()
        {
            return mSize;
        }
        
        public  SigningServer.Android.IO.ByteBuffer GetByteBuffer(long offset, int size)
        {
            CheckChunkValid(offset, size);
            return SigningServer.Android.IO.ByteBuffer.Wrap(mArray, (int)offset, size).Slice();
        }
        
        public  void Feed(long offset, long size, SigningServer.Android.Com.Android.Apksig.Util.DataSink sink)
        {
            CheckChunkValid(offset, size);
            sink.Consume(mArray, (int)offset, (int)size);
        }
        
        public  void CopyTo(long offset, int size, SigningServer.Android.IO.ByteBuffer dest)
        {
            CheckChunkValid(offset, size);
            dest.Put(mArray, (int)offset, size);
        }
        
        internal void CheckChunkValid(long offset, long size)
        {
            if (offset < 0)
            {
                throw new System.IndexOutOfRangeException("offset: " + offset);
            }
            if (size < 0)
            {
                throw new System.IndexOutOfRangeException("size: " + size);
            }
            if (offset > mSize)
            {
                throw new System.IndexOutOfRangeException("offset (" + offset + ") > source size (" + mSize + ")");
            }
            long endOffset = offset + size;
            if (endOffset < offset)
            {
                throw new System.IndexOutOfRangeException("offset (" + offset + ") + size (" + size + ") overflow");
            }
            if (endOffset > mSize)
            {
                throw new System.IndexOutOfRangeException("offset (" + offset + ") + size (" + size + ") > source size (" + mSize + ")");
            }
        }
        
        public  SigningServer.Android.Com.Android.Apksig.Util.DataSource Slice(long offset, long size)
        {
            CheckChunkValid(offset, size);
            return new SigningServer.Android.Com.Android.Apksig.Internal.Util.ByteArrayDataSink.SliceDataSource((int)offset, (int)size, this);
        }
        
        /// <summary>
        /// Slice of the growable byte array. The slice's offset and size in the array are fixed.
        /// </summary>
        internal class SliceDataSource: SigningServer.Android.Com.Android.Apksig.Util.DataSource
        {
            internal readonly int mSliceOffset;
            
            internal readonly int mSliceSize;
            
            private readonly ByteArrayDataSink mParent;

            internal SliceDataSource(int offset, int size, ByteArrayDataSink parent)
            {
                mSliceOffset = offset;
                mSliceSize = size;
                mParent = parent;
            }
            
            public  long Size()
            {
                return mSliceSize;
            }
            
            public  void Feed(long offset, long size, SigningServer.Android.Com.Android.Apksig.Util.DataSink sink)
            {
                CheckChunkValid(offset, size);
                sink.Consume(mParent.mArray, (int)(mSliceOffset + offset), (int)size);
            }
            
            public  SigningServer.Android.IO.ByteBuffer GetByteBuffer(long offset, int size)
            {
                CheckChunkValid(offset, size);
                return SigningServer.Android.IO.ByteBuffer.Wrap(mParent.mArray, (int)(mSliceOffset + offset), size).Slice();
            }
            
            public  void CopyTo(long offset, int size, SigningServer.Android.IO.ByteBuffer dest)
            {
                CheckChunkValid(offset, size);
                dest.Put(mParent.mArray, (int)(mSliceOffset + offset), size);
            }
            
            public  SigningServer.Android.Com.Android.Apksig.Util.DataSource Slice(long offset, long size)
            {
                CheckChunkValid(offset, size);
                return new SigningServer.Android.Com.Android.Apksig.Internal.Util.ByteArrayDataSink.SliceDataSource((int)(mSliceOffset + offset), (int)size, mParent);
            }
            
            internal void CheckChunkValid(long offset, long size)
            {
                if (offset < 0)
                {
                    throw new System.IndexOutOfRangeException("offset: " + offset);
                }
                if (size < 0)
                {
                    throw new System.IndexOutOfRangeException("size: " + size);
                }
                if (offset > mSliceSize)
                {
                    throw new System.IndexOutOfRangeException("offset (" + offset + ") > source size (" + mSliceSize + ")");
                }
                long endOffset = offset + size;
                if (endOffset < offset)
                {
                    throw new System.IndexOutOfRangeException("offset (" + offset + ") + size (" + size + ") overflow");
                }
                if (endOffset > mSliceSize)
                {
                    throw new System.IndexOutOfRangeException("offset (" + offset + ") + size (" + size + ") > source size (" + mSliceSize + ")");
                }
            }
            
        }
        
    }
    
}
