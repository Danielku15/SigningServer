// <auto-generated>
// This code was auto-generated.
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
// </auto-generated>

using System;
using System.Threading.Tasks;
using SigningServer.Android.Collections;
using SigningServer.Android.Core;

namespace SigningServer.Android.Com.Android.Apksig.Internal.Util
{
    /// <summary>
    /// VerityTreeBuilder is used to generate the root hash of verity tree built from the input file.
    /// The root hash can be used on device for on-access verification.  The tree itself is reproducible
    /// on device, and is not shipped with the APK.
    /// </summary>
    public class VerityTreeBuilder: System.IDisposable
    {
        /// <summary>
        /// Maximum size (in bytes) of each node of the tree.
        /// </summary>
        internal static readonly int CHUNK_SIZE = 4096;
        
        /// <summary>
        /// Maximum parallelism while calculating digests.
        /// </summary>
        internal static readonly int DIGEST_PARALLELISM = SigningServer.Android.Core.Math.Min(32, Environment.ProcessorCount);
        
        /// <summary>
        /// Queue size.
        /// </summary>
        internal static readonly int MAX_OUTSTANDING_CHUNKS = 4;
        
        /// <summary>
        /// Typical prefetch size.
        /// </summary>
        internal static readonly int MAX_PREFETCH_CHUNKS = 1024;
        
        /// <summary>
        /// Minimum chunks to be processed by a single worker task.
        /// </summary>
        internal static readonly int MIN_CHUNKS_PER_WORKER = 8;
        
        /// <summary>
        /// Digest algorithm (JCA Digest algorithm name) used in the tree.
        /// </summary>
        internal static readonly string JCA_ALGORITHM = "SHA-256";
        
        /// <summary>
        /// Optional salt to apply before each digestion.
        /// </summary>
        internal readonly sbyte[] mSalt;
        
        internal readonly SigningServer.Android.Security.MessageDigest mMd;
        
        public VerityTreeBuilder(sbyte[] salt)
        {
            mSalt = salt;
            mMd = SigningServer.Android.Com.Android.Apksig.Internal.Util.VerityTreeBuilder.GetNewMessageDigest();
        }
        
        public void Dispose()
        {
        }
        
        /// <summary>
        /// Returns the root hash of the APK verity tree built from ZIP blocks.
        /// 
        /// Specifically, APK verity tree is built from the APK, but as if the APK Signing Block (which
        /// must be page aligned) and the "Central Directory offset" field in End of Central Directory
        /// are skipped.
        /// </summary>
        public virtual sbyte[] GenerateVerityTreeRootHash(SigningServer.Android.Com.Android.Apksig.Util.DataSource beforeApkSigningBlock, SigningServer.Android.Com.Android.Apksig.Util.DataSource centralDir, SigningServer.Android.Com.Android.Apksig.Util.DataSource eocd)
        {
            if (beforeApkSigningBlock.Size() % SigningServer.Android.Com.Android.Apksig.Internal.Util.VerityTreeBuilder.CHUNK_SIZE != 0)
            {
                throw new System.InvalidOperationException("APK Signing Block size not a multiple of " + SigningServer.Android.Com.Android.Apksig.Internal.Util.VerityTreeBuilder.CHUNK_SIZE + ": " + beforeApkSigningBlock.Size());
            }
            long centralDirOffsetForDigesting = beforeApkSigningBlock.Size();
            SigningServer.Android.IO.ByteBuffer eocdBuf = SigningServer.Android.IO.ByteBuffer.Allocate((int)eocd.Size());
            eocdBuf.Order(SigningServer.Android.IO.ByteOrder.LITTLE_ENDIAN);
            eocd.CopyTo(0, (int)eocd.Size(), eocdBuf);
            eocdBuf.Flip();
            SigningServer.Android.Com.Android.Apksig.Internal.Zip.ZipUtils.SetZipEocdCentralDirectoryOffset(eocdBuf, centralDirOffsetForDigesting);
            return GenerateVerityTreeRootHash(new SigningServer.Android.Com.Android.Apksig.Internal.Util.ChainedDataSource(beforeApkSigningBlock, centralDir, SigningServer.Android.Com.Android.Apksig.Util.DataSources.AsDataSource(eocdBuf)));
        }
        
        /// <summary>
        /// Returns the root hash of the verity tree built from the data source.
        /// </summary>
        public virtual sbyte[] GenerateVerityTreeRootHash(SigningServer.Android.Com.Android.Apksig.Util.DataSource fileSource)
        {
            SigningServer.Android.IO.ByteBuffer verityBuffer = GenerateVerityTree(fileSource);
            return GetRootHashFromTree(verityBuffer);
        }
        
        /// <summary>
        /// Returns the byte buffer that contains the whole verity tree.
        /// 
        /// The tree is built bottom up. The bottom level has 256-bit digest for each 4 KB block in the
        /// input file.  If the total size is larger than 4 KB, take this level as input and repeat the
        /// same procedure, until the level is within 4 KB.  If salt is given, it will apply to each
        /// digestion before the actual data.
        /// 
        /// The returned root hash is calculated from the last level of 4 KB chunk, similarly with salt.
        /// 
        /// The tree is currently stored only in memory and is never written out.  Nevertheless, it is
        /// the actual verity tree format on disk, and is supposed to be re-generated on device.
        /// </summary>
        public virtual SigningServer.Android.IO.ByteBuffer GenerateVerityTree(SigningServer.Android.Com.Android.Apksig.Util.DataSource fileSource)
        {
            int digestSize = mMd.GetDigestLength();
            int[] levelOffset = SigningServer.Android.Com.Android.Apksig.Internal.Util.VerityTreeBuilder.CalculateLevelOffset(fileSource.Size(), digestSize);
            SigningServer.Android.IO.ByteBuffer verityBuffer = SigningServer.Android.IO.ByteBuffer.Allocate(levelOffset[levelOffset.Length - 1]);
            for (int i = levelOffset.Length - 2;i >= 0;i--)
            {
                SigningServer.Android.Com.Android.Apksig.Util.DataSink middleBufferSink = new SigningServer.Android.Com.Android.Apksig.Internal.Util.ByteBufferSink(SigningServer.Android.Com.Android.Apksig.Internal.Util.VerityTreeBuilder.Slice(verityBuffer, levelOffset[i], levelOffset[i + 1]));
                SigningServer.Android.Com.Android.Apksig.Util.DataSource src;
                if (i == levelOffset.Length - 2)
                {
                    src = fileSource;
                    DigestDataByChunks(src, middleBufferSink);
                }
                else 
                {
                    src = SigningServer.Android.Com.Android.Apksig.Util.DataSources.AsDataSource(SigningServer.Android.Com.Android.Apksig.Internal.Util.VerityTreeBuilder.Slice(verityBuffer.AsReadOnlyBuffer(), levelOffset[i + 1], levelOffset[i + 2]));
                    DigestDataByChunks(src, middleBufferSink);
                }
                long totalOutput = SigningServer.Android.Com.Android.Apksig.Internal.Util.VerityTreeBuilder.DivideRoundup(src.Size(), SigningServer.Android.Com.Android.Apksig.Internal.Util.VerityTreeBuilder.CHUNK_SIZE) * digestSize;
                int incomplete = (int)(totalOutput % SigningServer.Android.Com.Android.Apksig.Internal.Util.VerityTreeBuilder.CHUNK_SIZE);
                if (incomplete > 0)
                {
                    sbyte[] padding = new sbyte[SigningServer.Android.Com.Android.Apksig.Internal.Util.VerityTreeBuilder.CHUNK_SIZE - incomplete];
                    middleBufferSink.Consume(padding, 0, padding.Length);
                }
            }
            return verityBuffer;
        }
        
        /// <summary>
        /// Returns the digested root hash from the top level (only page) of a verity tree.
        /// </summary>
        public virtual sbyte[] GetRootHashFromTree(SigningServer.Android.IO.ByteBuffer verityBuffer)
        {
            SigningServer.Android.IO.ByteBuffer firstPage = SigningServer.Android.Com.Android.Apksig.Internal.Util.VerityTreeBuilder.Slice(verityBuffer.AsReadOnlyBuffer(), 0, SigningServer.Android.Com.Android.Apksig.Internal.Util.VerityTreeBuilder.CHUNK_SIZE);
            return SaltedDigest(firstPage);
        }
        
        /// <summary>
        /// Returns an array of summed area table of level size in the verity tree.  In other words, the
        /// returned array is offset of each level in the verity tree file format, plus an additional
        /// offset of the next non-existing level (i.e. end of the last level + 1).  Thus the array size
        /// is level + 1.
        /// </summary>
        internal static int[] CalculateLevelOffset(long dataSize, int digestSize)
        {
            SigningServer.Android.Collections.List<long> levelSize = new SigningServer.Android.Collections.List<long>();
            while (true)
            {
                long chunkCount = SigningServer.Android.Com.Android.Apksig.Internal.Util.VerityTreeBuilder.DivideRoundup(dataSize, SigningServer.Android.Com.Android.Apksig.Internal.Util.VerityTreeBuilder.CHUNK_SIZE);
                long size = SigningServer.Android.Com.Android.Apksig.Internal.Util.VerityTreeBuilder.CHUNK_SIZE * SigningServer.Android.Com.Android.Apksig.Internal.Util.VerityTreeBuilder.DivideRoundup(chunkCount * digestSize, SigningServer.Android.Com.Android.Apksig.Internal.Util.VerityTreeBuilder.CHUNK_SIZE);
                levelSize.Add(size);
                if (chunkCount * digestSize <= SigningServer.Android.Com.Android.Apksig.Internal.Util.VerityTreeBuilder.CHUNK_SIZE)
                {
                    break;
                }
                dataSize = chunkCount * digestSize;
            }
            int[] levelOffset = new int[levelSize.Size() + 1];
            levelOffset[0] = 0;
            for (int i = 0;i < levelSize.Size();i++)
            {
                levelOffset[i + 1] = levelOffset[i] + SigningServer.Android.Core.Math.ToIntExact(levelSize.Get(levelSize.Size() - i - 1));
            }
            return levelOffset;
        }
        
        /// <summary>
        /// Digest data source by chunks then feeds them to the sink one by one.  If the last unit is
        /// less than the chunk size and padding is desired, feed with extra padding 0 to fill up the
        /// chunk before digesting.
        /// </summary>
        internal void DigestDataByChunks(SigningServer.Android.Com.Android.Apksig.Util.DataSource dataSource, SigningServer.Android.Com.Android.Apksig.Util.DataSink dataSink)
        {
            long size = dataSource.Size();
            int chunks = (int)SigningServer.Android.Com.Android.Apksig.Internal.Util.VerityTreeBuilder.DivideRoundup(size, SigningServer.Android.Com.Android.Apksig.Internal.Util.VerityTreeBuilder.CHUNK_SIZE);
            int ioSizeChunks = SigningServer.Android.Com.Android.Apksig.Internal.Util.VerityTreeBuilder.MAX_PREFETCH_CHUNKS;
            sbyte[][] hashes = new sbyte[chunks][];
            var tasks = new List<Task>(1);
            long maxReadSize = ioSizeChunks * SigningServer.Android.Com.Android.Apksig.Internal.Util.VerityTreeBuilder.CHUNK_SIZE;
            long readOffset = 0;
            int startChunkIndex = 0;
            while (readOffset < size)
            {
                long readLimit = SigningServer.Android.Core.Math.Min(readOffset + maxReadSize, size);
                int readSize = (int)(readLimit - readOffset);
                int bufferSizeChunks = (int)SigningServer.Android.Com.Android.Apksig.Internal.Util.VerityTreeBuilder.DivideRoundup(readSize, SigningServer.Android.Com.Android.Apksig.Internal.Util.VerityTreeBuilder.CHUNK_SIZE);
                SigningServer.Android.IO.ByteBuffer buffer = SigningServer.Android.IO.ByteBuffer.Allocate(bufferSizeChunks * SigningServer.Android.Com.Android.Apksig.Internal.Util.VerityTreeBuilder.CHUNK_SIZE);
                dataSource.CopyTo(readOffset, readSize, buffer);
                buffer.Rewind();
                int readChunkIndex = startChunkIndex;
                var task = Task.Factory.StartNew(() => {
                    SigningServer.Android.Security.MessageDigest md = CloneMessageDigest();
                    for (int offset = 0, finish = buffer.Capacity(), chunkIndex = readChunkIndex;offset < finish;offset += SigningServer.Android.Com.Android.Apksig.Internal.Util.VerityTreeBuilder.CHUNK_SIZE, ++chunkIndex)
                    {
                        SigningServer.Android.IO.ByteBuffer chunk = SigningServer.Android.Com.Android.Apksig.Internal.Util.VerityTreeBuilder.Slice(buffer, offset, offset + SigningServer.Android.Com.Android.Apksig.Internal.Util.VerityTreeBuilder.CHUNK_SIZE);
                        hashes[chunkIndex] = SaltedDigest(md, chunk);
                    }
                });
                tasks.Add(task);
                startChunkIndex += bufferSizeChunks;
                readOffset += readSize;
            }

            Task.WaitAll(tasks.ToArray());
            foreach (sbyte[] hash in hashes)
            {
                dataSink.Consume(hash, 0, hash.Length);
            }
        }
        
        /// <summary>
        /// Returns the digest of data with salt prepended.
        /// </summary>
        internal sbyte[] SaltedDigest(SigningServer.Android.IO.ByteBuffer data)
        {
            return SaltedDigest(mMd, data);
        }
        
        internal sbyte[] SaltedDigest(SigningServer.Android.Security.MessageDigest md, SigningServer.Android.IO.ByteBuffer data)
        {
            md.Reset();
            if (mSalt != null)
            {
                md.Update(mSalt);
            }
            md.Update(data);
            return md.Digest();
        }
        
        /// <summary>
        /// Divides a number and round up to the closest integer.
        /// </summary>
        internal static long DivideRoundup(long dividend, long divisor)
        {
            return (dividend + divisor - 1) / divisor;
        }
        
        /// <summary>
        /// Returns a slice of the buffer with shared the content.
        /// </summary>
        internal static SigningServer.Android.IO.ByteBuffer Slice(SigningServer.Android.IO.ByteBuffer buffer, int begin, int end)
        {
            SigningServer.Android.IO.ByteBuffer b = buffer.Duplicate();
            b.Position(0);
            b.Limit(end);
            b.Position(begin);
            return b.Slice();
        }
        
        /// <summary>
        /// Obtains a new instance of the message digest algorithm.
        /// </summary>
        internal static SigningServer.Android.Security.MessageDigest GetNewMessageDigest()
        {
            return SigningServer.Android.Security.MessageDigest.GetInstance(SigningServer.Android.Com.Android.Apksig.Internal.Util.VerityTreeBuilder.JCA_ALGORITHM);
        }
        
        /// <summary>
        /// Clones the existing message digest, or creates a new instance if clone is unavailable.
        /// </summary>
        internal SigningServer.Android.Security.MessageDigest CloneMessageDigest()
        {
            try
            {
                return (SigningServer.Android.Security.MessageDigest)mMd.Clone();
            }
            catch (SigningServer.Android.Core.CloneNotSupportedException ignored)
            {
                try
                {
                    return SigningServer.Android.Com.Android.Apksig.Internal.Util.VerityTreeBuilder.GetNewMessageDigest();
                }
                catch (SigningServer.Android.Security.NoSuchAlgorithmException e)
                {
                    throw new System.InvalidOperationException("Failed to obtain an instance of a previously available message digest", e);
                }
            }
        }
        
    }
    
}
