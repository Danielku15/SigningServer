import java.io.FileOutputStream
import java.io.OutputStreamWriter
import kotlin.io.path.exists

class CSharpAstPrinter(
    val file: CsSourceFile,
    val context: CSharpEmitterContext
) {
    var indent = 0
    var isStartOfLine = false
    val source: StringBuilder = StringBuilder()

    fun print() {
        try {
            this.source.clear()
            this.writeSourceFile(this.file)
        } finally {
            val fullFile = file.fileName
            if (!fullFile.parent.exists()) {
                fullFile.parent.toFile().mkdirs()
            }
            OutputStreamWriter(FileOutputStream(fullFile.toFile())).use {
                it.write(source.toString())
            }
        }
    }

    private fun writeSourceFile(file: CsSourceFile) {
        this.writeLine("// <auto-generated>")
        this.writeLine("// This code was auto-generated.")
        this.writeLine("// Changes to this file may cause incorrect behavior and will be lost if")
        this.writeLine("// the code is regenerated.")
        this.writeLine("// </auto-generated>")
        this.writeLine()
        for (using in file.usings) {
            this.writeUsing(using)
        }
        if (file.usings.isNotEmpty()) {
            this.writeLine()
        }
        if (file.namespace != null) {
            this.writeNamespace(file.namespace!!)
        }
    }

    private fun writeNamespace(namespace: CsNamespaceDeclaration) {
        this.writeLine("namespace ${namespace.namespace}")
        this.beginBlock()
        this.writeNamespaceMembers(namespace.declarations)
        this.endBlock()
    }

    private fun writeUsing(using: CsUsingDeclaration) {
        this.writeLine("using ${using.namespaceOrTypeName};")
    }

    private fun writeSemicolon() {
        this.writeLine(";")
    }

    private fun writeLine(txt: String? = null) {
        this.writeIndent()
        if (txt != null) {
            this.write(txt)
        }
        this.write(System.lineSeparator())
        this.isStartOfLine = true
    }

    private fun write(txt: String) {
        this.writeIndent()
        this.source.append(txt)
        this.isStartOfLine = false
    }

    private fun writeIndent() {
        if (this.isStartOfLine && this.indent > 0) {
            this.source.append(if (this.indent == 1) "    " else "    ".repeat(this.indent))
            this.isStartOfLine = false
        }
    }

    private fun beginBlock() {
        this.writeLine("{")
        this.indent++
    }

    private fun endBlock() {
        this.indent--
        this.writeLine("}")
    }

    private fun writeNamespaceMembers(members: Iterable<CsNamespaceMember>) {
        for (declaration in members) {
            this.writeMember(declaration)
        }
    }

    private fun <T> writeCommaSeparated(values: List<T>, write: (p: T) -> Unit, newLine: Boolean = false) {
        for (i in values.indices) {
            if (i > 0) {
                this.write(", ")
                if (newLine) {
                    this.writeLine()
                }
            }
            write(values[i])
        }
    }

    private fun writeClassDeclaration(d: CsClassDeclaration) {
        this.writeDocumentation(d)
        this.writeAttributes(d)
        this.writeVisibility(d.visibility)

        if (d.partial) {
            this.write("partial ")
        }

        if (d.isAbstract) {
            this.write("abstract ")
        }

        this.write("class ${d.name}")
        this.writeTypeParameters(d.typeParameters)

        if (d.baseClass != null) {
            this.write(": ")
            this.writeType(d.baseClass!!)
        }

        if (d.interfaces.isNotEmpty()) {
            if (d.baseClass != null) {
                this.write(", ")
            } else {
                this.write(": ")
            }

            this.writeCommaSeparated(d.interfaces, { i -> this.writeType(i) })
        }
        this.writeTypeParameterConstraints(d.typeParameters)

        this.writeLine()

        this.beginBlock()

        var hasConstuctor = false
        d.members.forEach {
            this.writeMember(it)
            if (it is CsConstructorDeclaration && !it.isStatic) {
                hasConstuctor = true
            }
        }

        if (d.baseClass != null && !hasConstuctor) {
            var baseClass: CsTypeReferenceType? = d
            var constructorDeclaration: CsConstructorDeclaration? = null
            loop@ while (baseClass != null && constructorDeclaration != null) {
                if (baseClass is CsStringTypeReference) {
                    constructorDeclaration = null
                    break@loop
                } else if (baseClass is CsClassDeclaration) {
                    constructorDeclaration =
                        baseClass.members.find { it is CsConstructorDeclaration } as CsConstructorDeclaration?
                    if (constructorDeclaration != null) {
                        break
                    }

                    baseClass = if (baseClass.baseClass != null && baseClass.baseClass is CsTypeReference)
                        ((baseClass.baseClass as CsTypeReference).reference) else null
                } else {
                    constructorDeclaration = null
                    break
                }
            }

            if (constructorDeclaration != null) {
                val defaultConstructor = CsConstructorDeclaration()
                defaultConstructor.parent = d
                defaultConstructor.visibility = CsVisibility.Public
                defaultConstructor.body = CsBlock().apply {
                    this.parent = defaultConstructor
                }
                defaultConstructor.parameters = constructorDeclaration.parameters
                defaultConstructor.baseConstructorArguments = constructorDeclaration.parameters.map { p ->
                    CsIdentifier(p.name)
                }.toMutableList()
                this.writeMember(defaultConstructor)
            }
        }

        this.endBlock()
    }

    private fun writeEnumDeclaration(d: CsEnumDeclaration) {
        this.writeDocumentation(d)
        this.writeVisibility(d.visibility)
        this.write("enum ${d.name}")
        this.writeLine()
        this.beginBlock()

        d.members.forEach { this.writeEnumMember(it) }

        this.endBlock()
    }

    protected fun writeEnumMember(m: CsEnumMember) {
        this.writeDocumentation(m)
        this.write(m.name)
        if (m.initializer != null) {
            this.write(" = ")
            this.writeExpression(m.initializer!!)
        }
        this.writeLine(",")
    }

    private fun writeInterfaceDeclaration(d: CsInterfaceDeclaration) {
        this.writeDocumentation(d)
        this.writeVisibility(d.visibility)

        if (d.partial) {
            this.write("partial ")
        }

        this.write("interface ${d.name}")
        this.writeTypeParameters(d.typeParameters)

        if (d.interfaces.isNotEmpty()) {
            this.write(": ")
            this.writeCommaSeparated(d.interfaces, { i -> this.writeType(i) })
        }

        this.writeTypeParameterConstraints(d.typeParameters)
        this.writeLine()
        this.beginBlock()

        d.members.forEach {
            this.writeMember(it)
        }

        this.endBlock()
    }

    private fun writeParameter(p: CsParameterDeclaration) {
        if (p.params) {
            this.write("params ")
        }
        if (p.type != null) {
            this.writeType(p.type!!, false, p.params)
        }
        this.write(" ${p.name}")

        if (p.initializer != null) {
            this.write(" = ")
            this.writeExpression(p.initializer!!)
        } else if (p.type != null && p.type!!.isOptional) {
            this.write(" = default")
        }
    }

    private fun writeParameters(parameters: List<CsParameterDeclaration>) {
        this.write("(")
        this.writeCommaSeparated(parameters, { p -> this.writeParameter(p) })
        this.write(")")
    }

    private fun writeAttributes(d: CsAttributedElement) {
        d.attributes.forEach {
            this.writeAttribute(it)
        }
    }

    private fun writeAttribute(a: CsAttribute) {
        this.write("[")
        this.writeType(a.type)
        if (a.indexedArguments.isNotEmpty() || a.namedArguments.isNotEmpty()) {
            this.write("(")
            this.writeCommaSeparated(a.indexedArguments, { x -> this.writeExpression(x) })
            if (a.indexedArguments.isNotEmpty() && a.namedArguments.isNotEmpty()) {
                this.write(", ")
            }
            this.writeCommaSeparated(a.namedArguments, { x ->
                this.write(context.toPropertyName(x.first))
                this.write(" = ")
                this.writeExpression(x.second)
            })

            this.write(")")
        }
        this.writeLine("]")
    }

    private fun writeMethodDeclaration(d: CsMethodDeclaration) {
        this.writeDocumentation(d)
        this.writeParameterDocumentation(d)

        this.writeAttributes(d)
        this.writeVisibility(d.visibility)

        if (d.isStatic) {
            this.write("static ")
        }

        if (d.isAbstract) {
            this.write("abstract ")
        } else if (d.isVirtual) {
            this.write("virtual ")
        } else if (d.isOverride) {
            this.write("override ")
        }

        this.writeType(d.returnType)

        this.write(" ${d.name}")
        this.writeTypeParameters(d.typeParameters)
        this.writeParameters(d.parameters)
        this.writeTypeParameterConstraints(d.typeParameters)

        this.writeBody(d.body)
    }

    protected fun writeParameterDocumentation(d: CsMethodDeclaration) {
        for (p in d.parameters) {
            if (p.documentation != null) {
                this.write("/// <param name=\"${p.name}\">")
                this.writeDocumentationLines(p.documentation!!, false)
                if (this.isStartOfLine) {
                    this.write("/// ")
                }
                this.writeLine("</param>")
            }
        }

    }

    private fun writeFieldDeclarat1on(d: CsFieldDeclaration) {
        this.writeDocumentation(d)
        this.writeVisibility(d.visibility)

        if (this.context.isConst(d)) {
            this.write("const ")
        } else {
            if (d.isStatic) {
                this.write("static ")
            }

            if (d.isReadonly) {
                this.write("readonly ")
            }
        }

        this.writeType(d.type)
        this.write(" ${d.name}")
        if (d.initializer != null) {
            this.write(" = ")
            this.writeExpression(d.initializer!!)
        }
        this.writeLine(";")
    }

    private fun writePropertyDeclaration(d: CsPropertyDeclaration) {
        this.writeDocumentation(d)
        this.writeVisibility(d.visibility)

        val writeAsField = this.writePropertyAsField(d)

        if (writeAsField && this.canBeConstant(d)) {
            this.write("const ")
        } else {
            if (d.isStatic) {
                this.write("static ")
            }

            if (d.isAbstract) {
                this.write("abstract ")
            } else if (d.isVirtual) {
                this.write("virtual ")
            } else if (d.isOverride) {
                this.write("override ")
            }
        }

        this.writeType(d.type)
        this.write(" ${d.name}")

        if (!writeAsField) {
            this.writeLine()
            this.beginBlock()

            if (d.getAccessor != null) {
                this.writePropertyAccessor(d.getAccessor!!)
            }

            if (d.setAccessor != null) {
                this.writePropertyAccessor(d.setAccessor!!)
            }

            this.endBlock()
        }

        if (d.initializer != null) {
            this.write(" = ")
            this.writeExpression(d.initializer!!)
            this.writeLine(";")
        } else if (writeAsField) {
            this.writeLine(";")
        }
    }

    protected fun writePropertyAccessor(accessor: CsPropertyAccessorDeclaration) {
        this.write(accessor.keyword)
        this.writeBody(accessor.body)
    }

    private fun writeConstructorDeclaration(d: CsConstructorDeclaration) {
        this.writeDocumentation(d)
        this.writeVisibility(d.visibility)
        if (d.isStatic) {
            this.write("static ")
        }
        this.write("${(d.parent as CsClassDeclaration).name}")
        this.writeParameters(d.parameters)

        if (d.baseConstructorArguments != null) {
            this.writeLine()
            this.indent++
            this.write(": base (")
            this.writeCommaSeparated(d.baseConstructorArguments!!, { e -> this.writeExpression(e) })
            this.write(")")
            this.indent--
        }

        this.writeBody(d.body)
    }

    protected fun writeBody(body: CsExpressionOrBlockBody?) {
        if (body != null) {
            if (body is CsBlock) {
                this.writeLine()
                this.writeBlock(body)
            } else {
                this.write(" => ")
                this.writeExpression(body as CsExpression)
            }
        } else {
            this.writeLine(";")
        }
    }


    protected fun writeDocumentation(d: CsDocumentedElement) {
        if (d.documentation != null) {
            this.writeLine("/// <summary>")
            this.writeDocumentationLines(d.documentation!!, true)
            this.writeLine("/// </summary>")
        }
    }

    protected fun writeDocumentationLines(documentation: String, multiLine: Boolean) {
        val lines = documentation.trim().split("\n")
        if (lines.size > 1 || multiLine) {
            if (!this.isStartOfLine) {
                this.writeLine()
            }
            for (line in lines) {
                this.writeLine("/// ${this.escapeXmlDoc(line)}")
            }
        } else if (lines.size == 1) {
            if (this.isStartOfLine) {
                this.writeLine("/// ${this.escapeXmlDoc(lines[0])}")
            } else {
                this.write(this.escapeXmlDoc(lines[0]))
            }
        }
    }

    protected fun escapeXmlDoc(s: String): String {
        return s.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")
    }

    private fun writeMember(member: CsNode) {
        if (member.skipEmit) {
            return
        }

        when (member.nodeType) {
            CsSyntaxKind.FieldDeclaration -> this.writeFieldDeclarat1on(member as CsFieldDeclaration)
            CsSyntaxKind.PropertyDeclaration -> this.writePropertyDeclaration(member as CsPropertyDeclaration)
            CsSyntaxKind.ConstructorDeclaration -> this.writeConstructorDeclaration(member as CsConstructorDeclaration)
            CsSyntaxKind.MethodDeclaration -> this.writeMethodDeclaration(member as CsMethodDeclaration)
            CsSyntaxKind.ClassDeclaration -> this.writeClassDeclaration(member as CsClassDeclaration)
            CsSyntaxKind.EnumDeclaration -> this.writeEnumDeclaration(member as CsEnumDeclaration)
            CsSyntaxKind.InterfaceDeclaration -> this.writeInterfaceDeclaration(member as CsInterfaceDeclaration)
            else -> throw IllegalStateException("Unsupported member" + member.nodeType)
        }
        this.writeLine()
    }

    private fun canBeConstant(d: CsPropertyDeclaration): Boolean {
        return (
                d.isStatic &&
                        d.setAccessor == null &&
                        d.type is CsPrimitiveTypeNode &&
                        d.initializer != null &&
                        (d.getAccessor == null || d.getAccessor!!.body == null)
                )
    }

    private fun writePropertyAsField(d: CsPropertyDeclaration): Boolean {
        if (
            d.parent is CsClassDeclaration &&
            d.visibility === CsVisibility.Private &&
            (d.getAccessor == null || d.getAccessor!!.body == null)
        ) {
            return true
        }
        return this.canBeConstant(d)
    }

    private fun writeType(
        type: CsTypeNode,
        forNew: Boolean = false,
        asNativeArray: Boolean = false,
        forTypeConstraint: Boolean = false
    ) {
        when (type.nodeType) {
            CsSyntaxKind.PrimitiveTypeNode -> {
                if (forTypeConstraint) {
                    when ((type as CsPrimitiveTypeNode).type) {
                        CsPrimitiveType.Bool, CsPrimitiveType.Int, CsPrimitiveType.Double -> this.write("struct")
                        CsPrimitiveType.Object, CsPrimitiveType.Dynamic, CsPrimitiveType.String, CsPrimitiveType.Void ->
                            this.write("class")
                        else -> throw IllegalStateException("Unsupported primitive in type constraint")
                    }
                } else {
                    when ((type as CsPrimitiveTypeNode).type) {
                        CsPrimitiveType.Bool ->
                            this.write("bool")
                        CsPrimitiveType.Dynamic ->
                            this.write("dynamic")
                        CsPrimitiveType.Double ->
                            this.write("double")
                        CsPrimitiveType.Int ->
                            this.write("int")
                        CsPrimitiveType.Object ->
                            this.write("object")
                        CsPrimitiveType.String ->
                            this.write("string")
                        CsPrimitiveType.Void ->
                            this.write("void")
                        CsPrimitiveType.Var ->
                            this.write("var")
                        CsPrimitiveType.Float -> this.write("float")
                        CsPrimitiveType.Long -> this.write("long")
                        CsPrimitiveType.Short -> this.write("short")
                        CsPrimitiveType.Byte -> this.write("sbyte")
                        CsPrimitiveType.Char -> this.write("char")
                    }
                }
            }
            CsSyntaxKind.ArrayTypeNode -> {
                val arrayType = type as CsArrayTypeNode
                this.writeType(arrayType.elementType)
                this.write("[]")
            }
            CsSyntaxKind.MapTypeNode -> {
                val mapType = type as CsMapTypeNode
                if (!mapType.valueIsValueType) {
                    if (forNew) {
                        this.write("SigningServer.Android.Collections.Map<")
                    } else {
                        this.write("SigningServer.Android.Collections.IMap<")
                    }
                } else {
                    if (forNew) {
                        this.write("SigningServer.Android.Collections.ValueTypeMap<")
                    } else {
                        this.write("SigningServer.Android.Collections.IValueTypeMap<")
                    }
                }
                this.writeType(mapType.keyType)
                this.write(", ")
                this.writeType(mapType.valueType)
                this.write(">")
            }
            CsSyntaxKind.TypeReference -> {
                val typeReference = type as CsTypeReference
                when (val targetType = typeReference.reference) {
                    is CsStringTypeReference -> {
                        this.write(targetType.text)
                    }
                    is CsNamedTypeDeclaration -> {
                        this.write(this.context.getFullName(targetType))
                    }
                    is CsTypeParameterDeclaration -> {
                        this.write((type as CsTypeParameterDeclaration).name)
                    }
                    is CsTypeNode -> {
                        this.writeType(targetType as CsTypeNode, forNew)
                    }
                    else ->
                        throw IllegalStateException("Unsupported type reference" + targetType)
                }

                if (typeReference.typeArguments != null && typeReference.typeArguments!!.isNotEmpty()) {
                    this.write("<")
                    this.writeCommaSeparated(typeReference.typeArguments!!, { p -> this.writeType(p) })
                    this.write(">")
                }
            }
            CsSyntaxKind.ClassDeclaration, CsSyntaxKind.InterfaceDeclaration, CsSyntaxKind.EnumDeclaration ->
                this.write(this.context.getFullName(type as CsNamedTypeDeclaration))

            CsSyntaxKind.TypeParameterDeclaration -> this.write((type as CsTypeParameterDeclaration).name)
            CsSyntaxKind.EnumMember -> this.write(this.context.getFullName((type as CsEnumMember).parent as CsNamedTypeDeclaration))
            CsSyntaxKind.UnresolvedTypeNode -> {
                if ((type as CsUnresolvedTypeNode).resolved != null) {
                    this.writeType(type.resolved!!, forNew, asNativeArray, forTypeConstraint)
                } else {
                    throw IllegalStateException("Unresolved type node: " + type)
                }
            }
            else -> throw IllegalStateException("Unsupported type node: " + type.nodeType)
        }
        if (type.isNullable && !forNew && !forTypeConstraint) {
            this.write("?")
        }
    }

    private fun writePrefixUnaryExpression(expr: CsPrefixUnaryExpression) {
        this.write(expr.operator)
        this.writeExpression(expr.operand)
    }

    private fun writeBaseLiteral(expr: CsBaseLiteral) {
        this.write("base")
    }

    private fun writeBinaryExpression(expr: CsBinaryExpression) {
        this.writeExpression(expr.left)
        this.write(" ")
        this.write(expr.operator)
        this.write(" ")
        this.writeExpression(expr.right)
    }

    private fun writeConditionalExpression(expr: CsConditionalExpression) {
        this.writeExpression(expr.condition)
        this.write(" ? ")
        this.writeExpression(expr.whenTrue)
        this.write(" : ")
        this.writeExpression(expr.whenFalse)
    }

    private fun writeLambdaExpression(expr: CsLambdaExpression) {
        this.write("(")
        this.writeCommaSeparated(expr.parameters, { p -> this.writeParameter(p) })
        this.write(") => ")
        if (expr.body is CsBlock) {
            this.writeBlock(expr.body as CsBlock)
        } else {
            this.writeExpression(expr.body as CsExpression)
        }
    }

    private fun writeNumericLiteral(expr: CsNumericLiteral) {
        this.write(expr.value)
    }

    private fun writeStringTemplateExpression(expr: CsStringTemplateExpression) {
        this.write("string.Format(System.Globalization.CultureInfo.InvariantCulture, @\"")
        val exprs = ArrayList<CsExpression>()
        expr.chunks.forEach {
            if (it is CsStringLiteral) {
                val escapedText = it.text.replace("\"", "\"\"")
                this.write(escapedText)
            } else {
                this.write("{${exprs.size}}")
                exprs.add(it as CsExpression)
            }
        }
        this.write("\"")
        exprs.forEach {
            this.write(", ")
            this.writeExpression(it)
        }
        this.write(")")
    }

    private fun writeArrayCreationExpression(expr: CsArrayCreationExpression) {
        if (expr.type != null) {
            this.write("new ")
            this.writeType(expr.type!!, true)
            if (expr.values != null) {
                if (expr.values!!.isNotEmpty()) {
                    this.writeLine("{")
                    this.indent++
                    this.writeCommaSeparated(expr.values!!, {
                        if (expr.values!!.size > 10) {
                            this.writeLine()
                        }
                        this.writeExpression(it)
                    })
                    this.indent--
                    this.writeLine("}")
                } else {
                    this.writeLine("()")
                }
            } else {
                this.write("[")
                this.writeExpression(expr.sizeExpression!!)
                this.write("]")
            }
        } else if (expr.values != null && expr.values!!.size > 0) {
            this.write("new [] {")
            this.writeCommaSeparated(expr.values!!, {
                if (expr.values!!.size > 10) {
                    this.writeLine()
                }
                this.writeExpression(it)
            })
            this.write("}")
        } else {
            this.context.addCsNodeDiagnostics(expr, "Unknown array type", true)
        }
    }

    private fun writeTypeOfExpression(expr: CsTypeOfExpression) {
        this.write("typeof")
        this.write("(")
        this.writeExpression(expr.expression)
        this.write(")")
    }

    private fun writeMemberAccessExpression(expr: CsMemberAccessExpression) {
        this.writeExpression(expr.expression)
        this.write(".")
        val name = this.context.getSymbolName(expr) ?: expr.member
        this.write(name)
    }

    private fun writeElementAccessExpression(expr: CsElementAccessExpression) {
        this.writeExpression(expr.expression)
        this.write("[")
        this.writeExpression(expr.argumentExpression)
        this.write("]")
    }

    private fun writeNewExpression(expr: CsNewExpression) {
        this.write("new ")
        this.writeType(expr.type, true)
        this.write("(")
        this.writeCommaSeparated(expr.arguments, { a -> this.writeExpression(a) })
        this.write(")")
    }

    private fun writeCastExpression(expr: CsCastExpression) {
        this.write("(")
        this.writeType(expr.type)
        this.write(")")
        this.writeExpression(expr.expression); }

    private fun writeNonNullExpression(expr: CsNonNullExpression) {
        this.writeExpression(expr.expression)
        this.write("!")
    }

    private fun writeIdentifier(expr: CsIdentifier) {
        val name = this.context.getSymbolName(expr) ?: expr.text
        this.write(name)
    }

    private fun writeNullSafeExpression(expr: CsNullSafeExpression) {
        this.writeExpression(expr.expression)
        this.write("?")
    }

    private fun writeInvocationExpression(expr: CsInvocationExpression) {
        this.writeExpression(expr.expression)
        if (expr.typeArguments.isNotEmpty()) {
            this.write("<")
            this.writeCommaSeparated(expr.typeArguments, { t -> this.writeType(t) })
            this.write(">")
        }
        this.write("(")
        if (expr.arguments.size > 5) {
            this.writeLine()
            this.indent++
            this.writeCommaSeparated(expr.arguments, { a ->
                this.writeExpression(a)
                this.writeLine()
            }, true)
            this.indent--
            this.writeLine()
        } else {
            this.writeCommaSeparated(expr.arguments, { a -> this.writeExpression(a) })
        }
        this.write(")")
    }

    private fun writeNullLiteral(expr: CsNullLiteral) {
        this.write("null")
    }

    private fun writeBooleanLiteral(expr: CsBooleanLiteral) {
        this.write(if (expr.isTrue) "true" else "false")
    }

    private fun writeThisLiteral(expr: CsThisLiteral) {
        this.write("this")
    }

    private fun writeStringLiteral(expr: CsStringLiteral) {
        // TODO: adapt original literal?
        this.write("\"" + expr.text.replace("\"", "\\") + "\"")
    }

    private fun writeIsExpression(expr: CsIsExpression) {
        this.writeExpression(expr.expression)
        this.write(" is ")
        this.writeType(expr.type)
    }

    private fun writeParenthesizedExpression(expr: CsParenthesizedExpression) {
        this.write("(")
        this.writeExpression(expr.expression)
        this.write(")")
    }

    private fun writeTypeParameter(p: CsTypeParameterDeclaration) {
        this.write(p.name)
    }

    private fun writeTypeParameterConstraints(typeParameters: Iterable<CsTypeParameterDeclaration>?) {
        if (typeParameters != null) {
            this.indent++
            typeParameters.forEach {
                if (it.constraint != null) {
                    this.writeLine()
                    this.write("where ")
                    this.write(it.name)
                    this.write(" : ")
                    this.writeType(it.constraint!!, false, false, true)
                }
            }
            this.indent--
        }
    }

    private fun writeTypeParameters(typeParameters: List<CsTypeParameterDeclaration>?) {
        if (typeParameters != null && typeParameters.isNotEmpty()) {
            this.write("<")
            for (i in typeParameters.indices) {
                if (i > 0) {
                    this.write(", ")
                }
                this.writeTypeParameter(typeParameters[i])
            }
            this.write(">")
        }
    }

    private fun writeExpression(expr: CsExpression) {
        when (expr.nodeType) {
            CsSyntaxKind.PrefixUnaryExpression -> this.writePrefixUnaryExpression(expr as CsPrefixUnaryExpression)
            CsSyntaxKind.PostfixUnaryExpression -> this.writePostfixUnaryExpression(expr as CsPostfixUnaryExpression)
            CsSyntaxKind.NullLiteral -> this.writeNullLiteral(expr as CsNullLiteral)
            CsSyntaxKind.FalseLiteral, CsSyntaxKind.TrueLiteral -> this.writeBooleanLiteral(expr as CsBooleanLiteral)
            CsSyntaxKind.ThisLiteral -> this.writeThisLiteral(expr as CsThisLiteral)
            CsSyntaxKind.BaseLiteral -> this.writeBaseLiteral(expr as CsBaseLiteral)
            CsSyntaxKind.StringLiteral -> this.writeStringLiteral(expr as CsStringLiteral)
            CsSyntaxKind.BinaryExpression -> this.writeBinaryExpression(expr as CsBinaryExpression)
            CsSyntaxKind.ConditionalExpression -> this.writeConditionalExpression(expr as CsConditionalExpression)
            CsSyntaxKind.LambdaExpression -> this.writeLambdaExpression(expr as CsLambdaExpression)
            CsSyntaxKind.NumericLiteral -> this.writeNumericLiteral(expr as CsNumericLiteral)
            CsSyntaxKind.StringTemplateExpression -> this.writeStringTemplateExpression(expr as CsStringTemplateExpression)
            CsSyntaxKind.IsExpression -> this.writeIsExpression(expr as CsIsExpression)
            CsSyntaxKind.ParenthesizedExpression -> this.writeParenthesizedExpression(expr as CsParenthesizedExpression)
            CsSyntaxKind.ArrayCreationExpression -> this.writeArrayCreationExpression(expr as CsArrayCreationExpression)
            CsSyntaxKind.MemberAccessExpression -> this.writeMemberAccessExpression(expr as CsMemberAccessExpression)
            CsSyntaxKind.AnonymousObjectCreationExpression -> this.writeAnonymousObjectCreationExpression(expr as CsAnonymousObjectCreationExpression)
            CsSyntaxKind.AnonymousObjectProperty -> this.writeAnonymousObjectProperty(expr as CsAnonymousObjectProperty)
            CsSyntaxKind.ElementAccessExpression -> this.writeElementAccessExpression(expr as CsElementAccessExpression)
            CsSyntaxKind.InvocationExpression -> this.writeInvocationExpression(expr as CsInvocationExpression)
            CsSyntaxKind.NewExpression -> this.writeNewExpression(expr as CsNewExpression)
            CsSyntaxKind.CastExpression -> this.writeCastExpression(expr as CsCastExpression)
            CsSyntaxKind.NonNullExpression -> this.writeNonNullExpression(expr as CsNonNullExpression)
            CsSyntaxKind.NullSafeExpression -> this.writeNullSafeExpression(expr as CsNullSafeExpression)
            CsSyntaxKind.Identifier -> this.writeIdentifier(expr as CsIdentifier)
            CsSyntaxKind.DefaultExpression -> this.writeDefaultExpression(expr as CsDefaultExpression)
            CsSyntaxKind.TypeOfExpression -> this.writeTypeOfExpression(expr as CsTypeOfExpression)
            CsSyntaxKind.TypeReference -> this.writeType(expr as CsTypeReference)
            CsSyntaxKind.ArrayInitializerExpression -> this.writeArrayInitializerExpression(expr as CsArrayInitializerExpression)
            else -> throw kotlin.IllegalStateException("Unhandled expression type: ${expr.nodeType}")
        }
    }

    private fun writeStatement(s: CsStatement) {
        when (s.nodeType) {
            CsSyntaxKind.EmptyStatement -> this.writeEmptyStatement()
            CsSyntaxKind.Block -> this.writeBlock(s as CsBlock)
            CsSyntaxKind.VariableStatement -> this.writeVariableStatement(s as CsVariableStatement)
            CsSyntaxKind.ExpressionStatement -> this.writeExpressionStatement(s as CsExpressionStatement)
            CsSyntaxKind.IfStatement -> this.writeIfStatement(s as CsIfStatement)
            CsSyntaxKind.DoStatement -> this.writeDoStatement(s as CsDoStatement)
            CsSyntaxKind.WhileStatement -> this.writeWhileStatement(s as CsWhileStatement)
            CsSyntaxKind.ForStatement -> this.writeForStatement(s as CsForStatement)
            CsSyntaxKind.ForEachStatement -> this.writeForEachStatement(s as CsForEachStatement)
            CsSyntaxKind.BreakStatement -> this.writeBreakStatement()
            CsSyntaxKind.ContinueStatement -> this.writeContinueStatement()
            CsSyntaxKind.ReturnStatement -> this.writeReturnStatement(s as CsReturnStatement)
            CsSyntaxKind.SwitchStatement -> this.writeSwitchStatement(s as CsSwitchStatement)
            CsSyntaxKind.ThrowStatement -> this.writeThrowStatement(s as CsThrowStatement)
            CsSyntaxKind.TryStatement -> this.writeTryStatement(s as CsTryStatement)
            else -> throw kotlin.IllegalStateException("Unhandled statement type: ${s.nodeType}")
        }
    }

    private fun writeTryStatement(s: CsTryStatement) {
        this.writeLine("try")
        this.writeBlock(s.tryBlock)
        if (s.catchClauses.isNotEmpty()) {
            s.catchClauses.forEach { this.writeCatchClause(it) }
        }
        if (s.finallyBlock != null) {
            this.writeLine("finally")
            this.writeBlock(s.finallyBlock!!)
        }
    }

    private fun writeThrowStatement(s: CsThrowStatement) {
        this.write("throw")
        if (s.expression != null) {
            this.write(" ")
            this.writeExpression(s.expression!!)
        }
        this.writeSemicolon()
    }

    private fun writeReturnStatement(r: CsReturnStatement) {
        this.write("return")
        if (r.expression != null) {
            this.write(" ")
            this.writeExpression(r.expression!!)
        }
        this.writeSemicolon()
    }

    private fun writeContinueStatement() {
        this.write("continue")
        this.writeSemicolon()
    }

    private fun writeBreakStatement() {
        this.write("break")
        this.writeSemicolon()
    }

    private fun writeCatchClause(c: CsCatchClause) {
        this.write("catch (")
        this.writeParameter(c.parameter)
        this.writeLine(")")
        this.writeBlock(c.block)
    }

    private fun writeSwitchStatement(s: CsSwitchStatement) {
        this.write("switch (")
        this.writeExpression(s.expression)
        this.writeLine(")")
        this.beginBlock()

        s.caseClauses.forEach {
            if (it is CsDefaultClause) {
                this.writeDefaultClause(it)
            } else {
                this.writeCaseClause(it as CsCaseClause)
            }
        }

        this.endBlock()
    }

    private fun writeCaseClause(c: CsCaseClause) {
        this.write("case ")
        this.writeExpression(c.expression)
        this.writeLine(":")
        this.indent++
        c.statements.forEach { this.writeStatement(it) }
        this.indent--
    }

    private fun writeDefaultClause(c: CsDefaultClause) {
        this.writeLine("default:")
        this.indent++
        c.statements.forEach { this.writeStatement(it) }
        this.indent--
    }


    private fun writeForEachStatement(s: CsForEachStatement) {
        this.write("foreach (")
        if (s.initializer is CsVariableDeclarationList) {
            this.writeVariableDeclarationList(s.initializer as CsVariableDeclarationList)
        } else {
            this.writeExpression(s.initializer as CsExpression)
        }
        this.write(" in ")
        this.writeExpression(s.expression)
        this.writeLine(")")

        if (s.statement is CsBlock) {
            this.writeStatement(s.statement)
        } else {
            this.indent++
            this.writeStatement(s.statement)
            this.indent--
        }
    }

    private fun writeForStatement(s: CsForStatement) {
        this.write("for (")
        for ((index, init) in s.initializer.withIndex()) {
            if (index > 0) {
                this.write(", ")
            }
            if (init is CsVariableDeclarationList) {
                this.writeVariableDeclarationList(init)
            } else {
                this.writeExpression(s.initializer as CsExpression)
            }
        }

        this.write(";")

        if (s.condition != null) {
            this.writeExpression(s.condition!!)
        }
        this.write(";")

        for ((index, inc) in s.incrementor.withIndex()) {
            if (index > 0) {
                this.write(", ")
            }
            this.writeExpression(inc)
        }
        this.writeLine(")")

        if (s.statement is CsBlock) {
            this.writeStatement(s.statement)
        } else {
            this.indent++
            this.writeStatement(s.statement)
            this.indent--
        }
    }

    private fun writeWhileStatement(s: CsWhileStatement) {
        this.write("while (")
        this.writeExpression(s.expression)
        this.writeLine(")")
        if (s.statement is CsBlock) {
            this.writeStatement(s.statement)
        } else {
            this.indent++
            this.writeStatement(s.statement)
            this.indent--
        }
    }

    private fun writeDoStatement(s: CsDoStatement) {
        this.writeLine("do")
        this.writeStatement(s.statement)
        this.write("while (")
        this.writeExpression(s.expression)
        this.write(")")
        this.writeSemicolon()
    }

    private fun writeIfStatement(s: CsIfStatement) {
        this.write("if (")
        this.writeExpression(s.expression)
        this.writeLine(")")
        if (s.thenStatement is CsBlock) {
            this.writeStatement(s.thenStatement)
        } else {
            this.indent++
            this.writeStatement(s.thenStatement)
            this.indent--
        }

        if (s.elseStatement != null) {
            this.write("else ")
            if (s.elseStatement is CsIfStatement) {
                this.writeStatement(s.elseStatement!!)
            } else if (s.elseStatement is CsBlock) {
                this.writeLine()
                this.writeStatement(s.elseStatement!!)
            } else {
                this.writeLine()
                this.indent++
                this.writeStatement(s.elseStatement!!)
                this.indent--
            }
        }
    }

    private fun writeExpressionStatement(s: CsExpressionStatement) {
        this.writeExpression(s.expression)
        this.writeSemicolon()
    }

    private fun writeVariableStatement(v: CsVariableStatement) {
        this.writeVariableDeclarationList(v.declarationList)
        this.writeSemicolon()
    }

    private fun writeEmptyStatement() {
        this.writeSemicolon()
    }

    private fun writeVariableDeclarationList(declarationList: CsVariableDeclarationList) {
        this.writeType(declarationList.declarations[0].type)

        declarationList.declarations.indices.forEach { i ->
            val d = declarationList.declarations[i]
            if (i == 0) {
                this.write(" ")
            } else {
                this.write(", ")
            }

            if (d.deconstructNames != null) {
                this.write("(")
                d.deconstructNames!!.indices.forEach { i ->
                    val v = d.deconstructNames!![i]
                    if (i > 0) {
                        this.write(", ")
                    }
                    this.write(v)
                }
                this.write(")")
            } else {
                this.write(d.name)
            }

            if (d.initializer != null) {
                this.write(" = ")
                this.writeExpression(d.initializer!!)
            }
        }
    }

    private fun writeBlock(b: CsBlock) {
        this.beginBlock()
        b.statements.forEach { this.writeStatement(it) }
        this.endBlock()
    }

    private fun writeVisibility(visibility: CsVisibility) {
        when (visibility) {
            CsVisibility.Public -> this.write("public ")
            CsVisibility.Private -> this.write("private ")
            CsVisibility.Protected -> this.write("protected ")
            CsVisibility.Internal -> this.write("internal ")
            else -> {}
        }
    }

    private fun writeDefaultExpression(expr: CsDefaultExpression) {
        this.write("default")
        if (expr.type != null) {
            this.write("(")
            this.writeType(expr.type!!)
            this.write(")")
        }
    }

    private fun writeArrayInitializerExpression(expr: CsArrayInitializerExpression) {
        this.write("{")
        this.writeCommaSeparated(expr.values!!, {
            if (expr.values!!.size > 10) {
                this.writeLine()
            }
            this.writeExpression(it)
        })
        this.write("}")
    }

    private fun writePostfixUnaryExpression(expr: CsPostfixUnaryExpression) {
        this.writeExpression(expr.operand)
        this.write(expr.operator)
    }

    private fun writeAnonymousObjectCreationExpression(expr: CsAnonymousObjectCreationExpression) {
        this.write("new")
        this.beginBlock()

        expr.properties.forEach {
            this.writeAnonymousObjectProperty(it)
        }

        this.endBlock()
    }

    private fun writeAnonymousObjectProperty(expr: CsAnonymousObjectProperty) {
        this.write(expr.name)
        this.write(" = ")
        this.writeExpression(expr.value)
        this.writeLine(",")
    }
}